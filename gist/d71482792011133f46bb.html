<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Seedbox Config</title>
    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <meta name="generator" content="Jekyll v4.2.2" />
    <meta property="og:title" content="Seedbox Config" />
    <meta name="author" content="Tomáš Krupka" />
    <meta property="og:locale" content="en_US" />
    <meta
      name="description"
      content='#!/bin/sh # ***** BEGIN LICENSE BLOCK ***** # Version: MPL 1.1 # # The contents of this file are subject to the Mozilla Public License Version # 1.1 (the "License"); you may not use this file except in compliance with # the License. You may obtain a copy of the License at # http://www.mozilla.org/MPL/ # # Software distributed under the License is distributed on an "AS IS" basis, # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License # for the specific language governing rights and limitations under the # License. # # The Original Code is IRC Auto Downloader # # The Initial Developer of the Original Code is # David Nilsson. # Portions created by the Initial Developer are Copyright (C) 2010, 2011 # the Initial Developer. All Rights Reserved. # # Contributor(s): # # ***** END LICENSE BLOCK ***** AUTODL_IRSSI_ZIP_URL="http://update.autodl-community.com/autodl-irssi-community.zip" GIT_PATH_RUTORRENT_PLUGIN="https://github.com/autodl-community/autodl-rutorrent.git" WEBMIN_URL="http://www.webmin.com/download/webmin-current.tar.gz" RUTORRENT_TRUNK_DIR="https://rutorrent.googlecode.com/svn/trunk" # The official tarballs are tried if subversion fails. RUTORRENT_VERSION="3.6" RUTORRENT_CORE_NAME="rutorrent-$RUTORRENT_VERSION.tar.gz" RUTORRENT_CORE_URL="http://dl.bintray.com/novik65/generic/$RUTORRENT_CORE_NAME" #RUTORRENT_CORE_URL="http://rutorrent.googlecode.com/files/$RUTORRENT_CORE_NAME" RUTORRENT_PLUGINS_NAME="plugins-$RUTORRENT_VERSION.tar.gz" #RUTORRENT_PLUGINS_URL="http://rutorrent.googlecode.com/files/$RUTORRENT_PLUGINS_NAME" RUTORRENT_PLUGINS_URL="http://dl.bintray.com/novik65/generic/$RUTORRENT_PLUGINS_NAME" #RUTORRENT_CORE_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_CORE_NAME/download" #RUTORRENT_PLUGINS_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_PLUGINS_NAME/download" RUTORRENT_PLUGINS= # These are the ruTorrent plugins that will get installed. To remove one, either # remove the whole line or comment it (prepend a &#39;#&#39; to the start of the line). # If the line starts with &#39;#&#39;, the plugin is not installed. RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS _getdir" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS _task" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS autotools" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS chunks" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS cookies" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS cpuload" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS create" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS data" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS datadir" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS diskspace" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS edit" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS erasedata" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS extsearch" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS feeds" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS geoip" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS httprpc" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS ipad" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS loginmgr" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS logoff" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS mediainfo" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS ratio" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS retrackers" #RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS rpc" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS rss" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS rssurlrewrite" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS scheduler" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS seedingtime" #RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS show_peers_like_wtorrent" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS source" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS theme" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS throttle" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS tracklabels" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS trafic" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS unpack" # For building rtorrent LIBCURL_NAME="curl-7.36.0" LIBCURL_URL="http://curl.haxx.se/download/$LIBCURL_NAME.tar.gz" SIGCPP20_NAME="libsigc++-2.3.1" SIGCPP20_URL="http://ftp.gnome.org/pub/GNOME/sources/libsigc++/2.3/$SIGCPP20_NAME.tar.gz" XMLRPC_SVN_DIR="https://svn.code.sf.net/p/xmlrpc-c/code/stable" LIBTORRENT_VERSION="0.13.4" LIBTORRENT_NAME="libtorrent-$LIBTORRENT_VERSION" LIBTORRENT_URL="http://libtorrent.rakshasa.no/downloads/$LIBTORRENT_NAME.tar.gz" LIBTORRENT_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$LIBTORRENT_NAME.tar.gz/download" RTORRENT_VERSION="0.9.4" RTORRENT_NAME="rtorrent-$RTORRENT_VERSION" RTORRENT_URL="http://libtorrent.rakshasa.no/downloads/$RTORRENT_NAME.tar.gz" RTORRENT_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RTORRENT_NAME.tar.gz/download" HTPASSWD_PY_SCRIPT_URL="http://trac.edgewall.org/export/10433/trunk/contrib/htpasswd.py" HTPASSWD_PY_SCRIPT_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/htpasswd.py/download" NGINX_NAME="nginx-1.7.0" NGINX_URL="http://nginx.org/download/$NGINX_NAME.tar.gz" LIGHTTPD_NAME="lighttpd-1.4.35" LIGHTTPD_URL="http://download.lighttpd.net/lighttpd/releases-1.4.x/$LIGHTTPD_NAME.tar.gz" MOD_SCGI_VERSION="1.14" MOD_SCGI_URL="http://python.ca/scgi/releases/scgi-$MOD_SCGI_VERSION.tar.gz" UNRAR_VERSION="4.0.7" UNRAR_URL="http://www.rarlab.com/rar/unrarsrc-$UNRAR_VERSION.tar.gz" # Dirs relative to user&#39;s home directory RTORRENT_REL_DOWNLOAD_DIR="downloads" RTORRENT_REL_WATCH_DIR="rtorrent/watch" RTORRENT_REL_SESSION_DIR="rtorrent/session" REQUIRED_PERL_MODULES="Time::HiRes XML::LibXML Archive::Zip Net::SSLeay HTML::Parser Digest::SHA1 JSON" REQUIRED_PHP_MODULES="json xml sockets" # If set to y, add &#39;load perl&#39; to .irssi/startup IRSSI_LOAD_PERL=n IGNORE_IRSSI=n # Start port. When we need a new port number, this port is incremented by one. CURRENT_PORT=23875 DEFAULT_PORT_FTP=21 DEFAULT_PORT_FTPES=990 DEFAULT_UMASK=022 RPC_PREFIX=RPC LSB_DEFAULT_START="2 3 4 5" LSB_DEFAULT_STOP="0 1 6" # Setting these to anything other than 80 and 443 may not work with Apache (since the # code assumed it would always be 80 and 443). HTTP_PORT=80 HTTPS_PORT=443 SCGI_HOST="127.0.0.1" INTERACTIVE=n USE_RUTORRENT_PLUGIN=n REINSTALL_RUTORRENT_PLUGIN=n INSTALL_AUTODL_IRSSI=n RUTORRENT_PASSWORD_PROTECTED=n USERS= RUTORRENT_BASE_PATH= INSTALL_STARTUP_SCRIPT=n BUILD_RTORRENT=n INSTALL_WEB_SERVER= INSTALL_RUTORRENT=n INSTALL_VSFTPD=n FTP_PORT= USE_ENCRYPTED_FTP=n INSTALL_WEBMIN=n USER_TIMEZONE= RUTORRENT_SITE_REALM="My ruTorrent web site" AUTODL_STARTUP_DESC="Start autodl-irssi and rtorrent" PHPCGI_STARTUP_DESC="Start php-cgi" NGINX_STARTUP_DESC="Start nginx" LIGHTTPD_STARTUP_DESC="Start lighttpd" PATH="$PATH:/usr/local/bin" # Find an echo that supports -e echo=echo for cmd in echo /bin/echo; do $cmd &gt;/dev/null 2&gt;&amp;1 || continue if ! $cmd -e "" | grep -qE &#39;^-e&#39;; then echo=$cmd break fi done CSI=$($echo -e "\033[") CEND="${CSI}0m" CDGREEN="${CSI}32m" CRED="${CSI}1;31m" CGREEN="${CSI}1;32m" CYELLOW="${CSI}1;33m" CBLUE="${CSI}1;34m" CMAGENTA="${CSI}1;35m" CCYAN="${CSI}1;36m" CQUESTION="$CMAGENTA" CWARNING="$CRED" CMSG="$CCYAN" errorExit() { cat &lt;&lt; EOF $CWARNING ***ERROR*** $* ***ERROR*** $CEND Help channel: ${CGREEN}#autodl-community@irc.p2p-network.net$CEND EOF exit 1 } exitHelp() { cat &lt;&lt; EOF autodl-irssi and ruTorrent plugin installer sh $0 [options] Options: --rtorrent Will build and install rtorrent, libtorrent and xmlrpc-c from source code. --rtorrent-noexec-patch Patch rtorrent to disallow remote users from executing code. --apache Install Apache web server. --nginx Install nginx web server. --lighttpd Install lighttpd web server. --rutorrent Install ruTorrent. Requires a web server, eg. --apache. --vsftpd Install vsftpd. --ftpes Use encrypted FTP (FTPES). --ftp-port &lt;port&gt; FTP server port. --webmin Install Webmin. -p --rutorrent-plugin Use or install the autodl-irssi ruTorrent plugin. If it&#39;s already installed, it will be updated (svn up), unless --reinstall-plugin option is used in which case it will be re-installed. -i --reinstall-plugin Re-install the autodl-irssi ruTorrent plugin if it&#39;s already installed. -a --install-autodl Install autodl-irssi. -u user:autodlPass:webUser:webPass --user user:autodlPass:webUser:webPass The $(uname -s) user, autodl-irssi password, ruTorrent user, ruTorrent password. You can use more than one -u option. If autodlPassword is not set, a random password will be used. -w --password-protected Use this option if ruTorrent is password protected. It&#39;s required if you want to use more than one ruTorrent user. Not needed if you install ruTorrent. -r PATH --rutorrent-base-path PATH Path to ruTorrent, eg. /var/www/rutorrent. Not needed if you install ruTorrent. -s --install-startup-script Install a startup script (service) which will start Irssi and rtorrent when the computer boots. -h --help Show this help text Examples (as root user): sh $0 --rtorrent --apache --rutorrent --vsftpd --ftpes --webmin -p -a -s -u user1::user1:pass1 -u user2::user2:pass2 Installs rtorrent, Apache, ruTorrent, vsftpd (encrypted), Webmin the autodl-irssi plugin, autodl-irssi, installs a service (starting Irssi and rtorrent) for both users. sh $0 -p -a -u user::user:pass -r /var/www/rutorrent -s Installs autodl-irssi + ruTorrent plugin for user &#39;user&#39;. ruTorrent has not been password protected. Also installs the startup script. sh $0 -p -a -u user1::user1:pass1 -u user2::user2:pass2 -w -r /var/www/rutorrent -s Installs autodl-irssi + ruTorrent plugin for users &#39;user1&#39; and &#39;user2&#39;. ruTorrent has been password protected. Also installs the startup script. sh $0 --rtorrent -a -u user1 -u user2 -u user3 -u user4 -s Installs rtorrent, autodl-irssi and the startup script. Help fchannel: #autodl-community@irc.p2p-network.net EOF exit 1 } parseCommandLine() { while [ $# -gt 0 ]; do local arg="$1" shift if [ "$arg" = "-p" ] || [ "$arg" = "--rutorrent-plugin" ]; then USE_RUTORRENT_PLUGIN=y elif [ "$arg" = "-i" ] || [ "$arg" = "--reinstall-plugin" ]; then REINSTALL_RUTORRENT_PLUGIN=y elif [ "$arg" = "-a" ] || [ "$arg" = "--install-autodl" ]; then INSTALL_AUTODL_IRSSI=y elif [ "$arg" = "-u" ] || [ "$arg" = "--user" ]; then USERS="$USERS $1" shift elif [ "$arg" = "-w" ] || [ "$arg" = "--password-protected" ]; then RUTORRENT_PASSWORD_PROTECTED=y elif [ "$arg" = "-r" ] || [ "$arg" = "--rutorrent-base-path" ]; then RUTORRENT_BASE_PATH="$1" shift elif [ "$arg" = "-s" ] || [ "$arg" = "--install-startup-script" ]; then INSTALL_STARTUP_SCRIPT=y elif [ "$arg" = "--rtorrent" ]; then BUILD_RTORRENT=y elif [ "$arg" = "--apache" ]; then INSTALL_WEB_SERVER=apache elif [ "$arg" = "--nginx" ]; then INSTALL_WEB_SERVER=nginx elif [ "$arg" = "--lighttpd" ]; then INSTALL_WEB_SERVER=lighttpd elif [ "$arg" = "--rutorrent" ]; then INSTALL_RUTORRENT=y elif [ "$arg" = "--vsftpd" ]; then INSTALL_VSFTPD=y elif [ "$arg" = "--ftpes" ]; then USE_ENCRYPTED_FTP=y elif [ "$arg" = "--ftp-port" ]; then FTP_PORT="$1" shift elif [ "$arg" = "--webmin" ]; then INSTALL_WEBMIN=y else exitHelp fi done } # Sets os and os_long to the OS type and OS name respectively detectOs() { local DISTRIB_ID= local DISTRIB_DESCRIPTION= if [ -f /etc/lsb-release ]; then . /etc/lsb-release fi if [ -f /etc/fedora-release ]; then os=fedora os_long="$(cat /etc/fedora-release)" # Must be before a whole bunch of other OS tests elif [ "$DISTRIB_ID" = "Ubuntu" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" elif [ "$DISTRIB_ID" = "LinuxMint" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" # Must be before Debian elif [ "$DISTRIB_ID" = "Peppermint" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" elif [ "$DISTRIB_ID" = "MEPIS" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" elif [ -f /etc/clearos-release ]; then os=fedora os_long="$(cat /etc/clearos-release)" elif [ -f /etc/debian_version ]; then os=debian local prefix= if ! uname -s | grep -q GNU; then prefix="GNU/" fi os_long="Debian $prefix$(uname -s) $(cat /etc/debian_version)" elif [ -f /etc/redhat-release ]; then os=fedora os_long="$(cat /etc/redhat-release)" else echo -e "\e[1;31mYour OS is not detected as an OS supported by this script. This script only supports \e[5;32mDebian and Fedora\e[0m \e[1;31mbased OSes.\e[0m" exit 1 fi os_long="${os_long:-$(uname -s)}" } # In-place editing like sed -i but more portable... sed_i() { local cmd="$1" local file="$2" isProgramInstalled ed || errorExit "ed is not installed!" local addr="," echo "$cmd" | grep -qE &#39;^/&#39; &amp;&amp; addr= ed -s "$file" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF $addr$cmd w q EOF } getFirst() { echo $1 } # Returns true if $1 is one of $2..$n arrayIsPresent() { local val="$1" shift for v in "$@"; do [ "$v" = "$val" ] &amp;&amp; return 0 done return 1 } canGeneratePasswords() { [ -c /dev/urandom ] } generatePassword() { newPassword=$(cat /dev/urandom | tr -dc _A-Z-a-z-0-9 | head -c17) } isProgramInstalled() { which "$1" &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } isPerlModuleInstalled() { perl -M$1 -e &#39;&#39; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } # Add $1 or $2 if it exists, to PACKAGES if program $1 isn&#39;t present addProgram() { isProgramInstalled $1 || PACKAGES="$PACKAGES ${2:-$1}" } # Add $2 to PACKAGES if perl module $1 isn&#39;t present addPerlModule() { isPerlModuleInstalled $1 || PACKAGES="$PACKAGES $2" } installPackages() { [ -z "$INSTALL" ] &amp;&amp; return [ -z "$PACKAGES" ] &amp;&amp; return $INSTALL $PACKAGES PACKAGES= } installPerlModule() { isPerlModuleInstalled $1 || $INSTALL $2 } installProgram() { isProgramInstalled $1 || $INSTALL ${2:-$1} } installBuildTools() { [ "$BUILD_TOOLS_INSTALLED" = y ] &amp;&amp; return PACKAGES="$BUILD_TOOLS" installPackages BUILD_TOOLS_INSTALLED=y } # Detects missing Perl modules and stores them in MISSING_PERL_MODULES detectMissingPerlModules() { OLD_PERL_MODULES= MISSING_PERL_MODULES= for module in $REQUIRED_PERL_MODULES; do isPerlModuleInstalled $module || MISSING_PERL_MODULES="$MISSING_PERL_MODULES $module" done # Make sure the JSON module is new if isPerlModuleInstalled JSON &amp;&amp; ! perl -MJSON -e &#39;&amp;decode_json("{}")&#39; &gt; /dev/null 2&gt;&amp;1; then echo "${CWARNING}Old JSON module is installed. Need to install from CPAN.$CEND" MISSING_PERL_MODULES="$MISSING_PERL_MODULES JSON" OLD_PERL_MODULES="$OLD_PERL_MODULES JSON" fi if echo "$MISSING_PERL_MODULES" | grep -wq JSON; then MISSING_PERL_MODULES="JSON::XS $MISSING_PERL_MODULES" fi if echo "$MISSING_PERL_MODULES" | grep -q &#39;XML::LibXML&#39;; then # Sometimes the cpan script doesn&#39;t install the required dependencies MISSING_PERL_MODULES="XML::NamespaceSupport XML::SAX $MISSING_PERL_MODULES" fi } # Detect where cpan is installed and place the path in the CPAN variable. # PCLinuxOS/Mandriva append the version number... detectCpanBin() { for file in $(which cpan 2&gt; /dev/null) $(ls /usr/bin/cpan-* 2&gt; /dev/null); do if [ -x "$file" ]; then CPAN="$file" return fi done isPerlModuleInstalled CPAN &amp;&amp; return errorExit "Could not find the cpan script or the CPAN Perl module. Can&#39;t install missing Perl modules." } isValidTzName() { echo "$1" | LC_ALL=C grep -qE &#39;^[A-Z][^/ ]*(/[A-Z][^/ ]*)?$&#39; &amp;&amp; return 0 return 1 } detectTimeZone() { [ -n "$USER_TIMEZONE" ] &amp;&amp; return local hash= local hasher= local files= local zoneinfoPath=/usr/share/zoneinfo [ -d "$zoneinfoPath" ] || return if hasher=md5sum; isProgramInstalled $hasher || hasher=sha1sum; isProgramInstalled $hasher; then hash=$($hasher /etc/localtime | awk &#39;{print $1}&#39;) files="$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E "^$hash\\&gt;" | awk &#39;{print $2}&#39;)" elif hasher=md5; isProgramInstalled $hasher || hasher=sha1; isProgramInstalled $hasher; then hash=$($hasher /etc/localtime | sed -e &#39;s/^.* = \([a-zA-Z0-9]*\)$/\1/&#39;) files="$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E "$hash\$" | sed -e &#39;s/^[^ ]* (\([^)]*\)).*/\1/&#39;)" else return fi # Detect all possible timezone names local timezones= for path in $files; do local tz="${path#$zoneinfoPath/}" while true; do isValidTzName "$tz" &amp;&amp; break local newTz="${tz#*/}" [ "$newTz" = "$tz" ] &amp;&amp; tz= &amp;&amp; break tz="$newTz" done isValidTzName "$tz" &amp;&amp; timezones="$timezones $tz" done # Now find the ones PHP likes... local okRegions="(Africa|America|Antarctica|Arctic|Asia|Atlantic|Australia|Europe|Indian|Pacific)" for tz in $timezones; do echo "$tz" | grep -qE "^$okRegions/" &amp;&amp; USER_TIMEZONE="$tz" &amp;&amp; return done # Return the first one we found for tz in $timezones; do USER_TIMEZONE="$tz" return done } getNumCpus() { [ -n "$NUMCPUS" ] &amp;&amp; return [ -f /proc/cpuinfo ] &amp;&amp; NUMCPUS=$(cat /proc/cpuinfo | grep &#39;^processor&#39; | wc -l) &amp;&amp; return isProgramInstalled sysctl &amp;&amp; sysctl -n hw.ncpu | grep -qE &#39;^[1-9][0-9]*$&#39; &amp;&amp; NUMCPUS=$(sysctl -n hw.ncpu) &amp;&amp; return NUMCPUS=1 } # Appends $value to $varName in $file, creating the var if it doesn&#39;t exist. The # value is not appended if it already exists. appendFileStringVar() { local file="$1" local varName="$2" local value="$3" [ -f "$file" ] || errorExit "File &#39;$file&#39; does not exist" local varLine=$(grep -E "^$varName=" "$file" | tail -n1) if [ -z "$varLine" ]; then echo "$varName=\"$value\"" &gt;&gt; "$file" else echo "$varLine" | grep -qE "[=&#39;\" ]$value(\"|&#39;| |$)" &amp;&amp; return local q= echo "$varLine" | grep -qE "^$varName=&#39;" &amp;&amp; q="&#39;" echo "$varLine" | grep -qE "^$varName=\"" &amp;&amp; q=&#39;"&#39; sed_i "s#^\\($varName=\\)$q\\(.*\\)$q#\\1\"\\2 $value\"#" "$file" fi } # Set a variable in a script file to a new value. The variable is created if it does not exist setScriptVariable() { local file="$1" local name=$2 local value="$3" [ -f "$file" ] || errorExit "File does not exist: $file" local newLine="$name=\"$value\"" if grep -qE "^$name=" $file; then sed_i "s!^$name=.*\$!$newLine!" "$file" else echo "$newLine" &gt;&gt; "$file" fi } userExists() { id -rg "$1" &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } setSvnOpts() { SVN_OPTS= isProgramInstalled svn || return # svn sometimes gives an error message &#39;broken pipe&#39;. Ignore it. if svn help co 2&gt;/dev/null | grep -q &#39;non-interactive&#39; &amp;&amp; svn help co 2&gt;/dev/null | grep -q &#39;trust-server-cert&#39;; then SVN_OPTS="--non-interactive --trust-server-cert" fi } downloadFile() { local filename="$1" shift for url in "$@"; do for i in 1 2 3 4 5; do wget --no-check-certificate -O "$filename" "$url" &amp;&amp; return 0 done done return 1 } buildMakeProgram() { local url="$1" local name="$2" local builddir="$3" local srcdir="$4" local makefile="${5:-Makefile}" buildStart echo "${CMSG}Downloading $name source code...$CEND" cd "$BUILD_DIR" local filename="${url##*/}" downloadFile "$filename" "$url" || errorExit "Could not download $name source code." tar xzf "$filename" srcdir="${srcdir:-${filename%.tar.gz}}" cd "$srcdir/$builddir" local make=${MAKE:-make} echo "${CMSG}Building $name...$CEND" $make -f $makefile all || errorExit "Could not build $name." $make -f $makefile install || errorExit "Could not install $name." echo "${CMSG}$name is now installed$CEND" buildEnd } buildProgram() { local prog="$1" echo "${CMSG}Building $prog...$CEND" ./configure --prefix=$PREFIX $2 || errorExit "Could not configure $prog. Try again, or try logging out and in and try again." getNumCpus local make=${MAKE:-make} local makeopts="-j$NUMCPUS" $make $makeopts || $make || errorExit "Could not build $prog" $make install || errorExit "Could not install $prog" local ldsoconf=/etc/ld.so.conf touch "$ldsoconf" grep -qE "^$PREFIX/lib$" $ldsoconf || echo "$PREFIX/lib" &gt;&gt; $ldsoconf ldconfig || errorExit "ldconfig failed" echo "${CMSG}$prog is now installed.$CEND" } downloadAndBuild() { local prog="$1" local urls="$2" local name="$3" local configOptions="$4" local patchUrl="$5" cd "$BUILD_DIR" echo "${CMSG}Downloading $prog source code...$CEND" downloadFile "$name.tar.gz" $urls || errorExit "Could not download $prog source code." tar xzf $name.tar.gz if echo "$patchUrl" | grep &#39;^[a-z]*://&#39;; then echo "${CMSG}Patching $prog...$CEND" PACKAGES="patch" installPackages isProgramInstalled patch || errorExit "patch is not installed!" downloadFile the.patch "$patchUrl" || errorExit "Could not download the patch file." patch -p1 -d $name &lt; the.patch || errorExit "Could not patch $prog." elif [ -n "$patchUrl" ]; then echo "${CMSG}Patching $prog...$CEND" cd $name eval $patchUrl cd .. fi cd $name buildProgram "$prog" "$configOptions" } checkoutAndBuild() { local prog="$1" local url="$2" local configOptions="$3" cd "$BUILD_DIR" echo "${CMSG}Downloading $prog source code...$CEND" svn export $SVN_OPTS "$url" "$prog" || errorExit "Could not download $prog source code." cd "$prog" buildProgram "$prog" "$configOptions" } buildStart() { PREFIX=/usr/local OLD_PATH="$PATH" PATH="$PATH:$PREFIX/bin" PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig export PKG_CONFIG_PATH BUILD_DIR="$(echo ~)/build-tmp" rm -rf "$BUILD_DIR" mkdir "$BUILD_DIR" || errorExit "Could not create build directory." } buildEnd() { cd rm -rf "$BUILD_DIR" [ -n "$OLD_PATH" ] &amp;&amp; PATH="$OLD_PATH" unset OLD_PATH unset PKG_CONFIG_PATH } buildRtorrent() { installBuildTools osHandler_$os installRtorrentBuildTools isProgramInstalled pkg-config || errorExit "pkg-config is not installed." # Minimum version is 7.15.4 but I had problems with 7.15.5 on CentOS. Set # it to 7.18.0 (the version Ubuntu Server 8.04 is using). if ! pkg-config --atleast-version=7.18.0 libcurl; then downloadAndBuild "libcurl" "$LIBCURL_URL" "$LIBCURL_NAME" "" # Prevent &#39;Unknown keyword &#39;URL&#39; in ....&#39; error sed_i &#39;s/^URL:/#URL:/&#39; $PREFIX/lib/pkgconfig/libcurl.pc fi if ! pkg-config --exists sigc++-2.0; then downloadAndBuild "sigc++-2.0" "$SIGCPP20_URL" "$SIGCPP20_NAME" "" fi checkoutAndBuild "xmlrpc-c" "$XMLRPC_SVN_DIR" "--disable-cplusplus" downloadAndBuild "libtorrent" "$LIBTORRENT_URL $LIBTORRENT_URL2" "$LIBTORRENT_NAME" "" patchLibtorrent downloadAndBuild "rtorrent" "$RTORRENT_URL $RTORRENT_URL2" "$RTORRENT_NAME" "--with-xmlrpc-c" "" } patchLibtorrent() { # For gcc 4.6.0 ed -s "src/torrent/data/block_transfer.h" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF /#define LIBTORRENT_BLOCK_TRANSFER_H a #include &lt;stddef.h&gt; . w q EOF ed -s "src/data/memory_chunk.cc" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF /#include "config.h" a #include &lt;stddef.h&gt; . w q EOF } installRtorrent() { buildStart buildRtorrent buildEnd } installUnrar() { isProgramInstalled unrar &amp;&amp; return installBuildTools buildMakeProgram "$UNRAR_URL" "unrar" "" "unrar" "makefile.unix" } installModScgi() { local modScgiFile="$1" local modulesPath="$2" [ -f "$modScgiFile" ] &amp;&amp; errorExit "mod_scgi file already exists." [ -d "$modulesPath" ] || errorExit "Apache modules path &#39;$modulesPath&#39; does not exist." buildMakeProgram "$MOD_SCGI_URL" "mod_scgi" "apache2" echo "LoadModule scgi_module $modulesPath/mod_scgi.so" &gt; $modScgiFile } isPortUsed() { local port="$1" netstat -an | grep tcp | grep -w LISTEN | grep -qE "[.:]$port[ ]" &amp;&amp; return 0 return 1 } isValidIpAddress() { # It&#39;s not 100% accurate ... ;) echo $1 | grep -qE &#39;^[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?$&#39; } getIpAddress() { isValidIpAddress "$OUR_IP_ADDRESS" &amp;&amp; return echo "${CMSG}Detecting your IP address...$CEND" isValidIpAddress "$OUR_IP_ADDRESS" || OUR_IP_ADDRESS=$(wget --no-check-certificate http://www.whatismyip.com/automation/n09230945.asp -O - -o /dev/null) isValidIpAddress "$OUR_IP_ADDRESS" || OUR_IP_ADDRESS=$(ifconfig -a | grep "inet addr" | head -n1 | awk -F: &#39;{print $2}&#39; | awk &#39;{print $1}&#39;) isValidIpAddress "$OUR_IP_ADDRESS" || OUR_IP_ADDRESS="1.2.3.4" } getNewPortNumber() { while true; do newPortNumber=$CURRENT_PORT CURRENT_PORT=$(expr $CURRENT_PORT + 1) isValidPortNumber $newPortNumber || errorExit "Invalid port number. Change CURRENT_PORT." isPortUsed $newPortNumber || break echo "${CWARNING}Port $newPortNumber is in use, trying next port...$CEND" done } # Returns true if it&#39;s a valid ruTorrent base path isValidRutorrentBasePath() { [ -n "$1" ] &amp;&amp; [ -d "$1/conf" ] } isValidPassword() { echo "$1" | grep -qE "^ " &amp;&amp; return 1 echo "$1" | grep -qE " \$" &amp;&amp; return 1 echo "$1" | grep -qE &#39;^$&#39; &amp;&amp; return 1 echo "$1" | grep -q &#39;:&#39; &amp;&amp; return 1 echo "&#39;$1&#39;" | grep -q &#39; &#39; &amp;&amp; return 1 return 0 } isValidPortNumber() { echo "$1" | grep -qiE &#39;^[0-9]+$&#39; || return 1 echo "$1" | grep -qiE &#39;[0-9][0-9][0-9][0-9][0-9][0-9]&#39; &amp;&amp; return 1 [ $1 -ge 1024 ] &amp;&amp; [ $1 -le 65535 ] } isValidWebUser() { [ -z "$1" ] &amp;&amp; return 1 echo "$1" | LC_ALL=C grep -qE &#39;[A-Z:]&#39; &amp;&amp; return 1 return 0 } initUsers() { local users= for packedUser in $USERS; do extractPackedUser $packedUser if [ -z "$autodlPort" ]; then getNewPortNumber autodlPort=$newPortNumber fi if [ -z "$scgiPort" ]; then getNewPortNumber scgiPort=$newPortNumber fi if [ -z "$rtorrentPort" ]; then getNewPortNumber rtorrentPort=$newPortNumber fi if canGeneratePasswords; then if [ -z "$autodlPassword" ]; then generatePassword autodlPassword="$newPassword" fi fi users="$users $osUser:$autodlPassword:$webUser:$webPass:$autodlPort:$scgiPort:$rtorrentPort" done USERS="$users" } extractPackedUser() { local packedUser="$1" osUser="$(echo $packedUser | cut -d: -f1)" autodlPassword="$(echo $packedUser | cut -d: -f2)" webUser="$(echo $packedUser | cut -d: -f3)" webPass="$(echo $packedUser | cut -d: -f4)" autodlPort="$(echo $packedUser | cut -d: -f5)" scgiPort="$(echo $packedUser | cut -d: -f6)" rtorrentPort="$(echo $packedUser | cut -d: -f7)" } getUserGroup() { local user="$1" userExists "$user" || errorExit "The user &#39;$user&#39; does not exist." group=$(grep -w $(id -rg $user) /etc/group | cut -d: -f1) [ -z "$group" ] &amp;&amp; group="$user" } getUserDir() { local user="$1" [ -z "$user" ] &amp;&amp; errorExit "Invalid user (blank)." userDir="$(eval echo ~$user)" [ -d "$userDir" ] || errorExit "User $user&#39;s home directory does not exist." } resetOwner() { local user="$1" shift if [ "$ISROOT" = y ]; then getUserGroup "$user" chown -R $user:$group "$@" fi } # Updates MISSING_PHP_MODULES with all missing required PHP modules detectMissingPhpModules() { MISSING_PHP_MODULES= local php=${WWW_PHP_CGI:-php} for module in $REQUIRED_PHP_MODULES; do $php -m 2&gt; /dev/null | grep -wq $module || MISSING_PHP_MODULES="$MISSING_PHP_MODULES $module" done } installMissingPhpPackages() { PACKAGES= for module in $MISSING_PHP_MODULES; do PACKAGES="$PACKAGES php-$module" done installPackages } installMissingPhp5Packages() { PACKAGES= for module in $MISSING_PHP_MODULES; do PACKAGES="$PACKAGES php5-$module" done installPackages } enablePhpIniModules() { local phpIni="$1" shift for module in "$@"; do grep -qE "^extension=$module.so" "$phpIni" &amp;&amp; continue sed_i "s/^; *\\(extension=$module.so.*\\)/\\1/" "$phpIni" grep -qE "^extension=$module.so" "$phpIni" &amp;&amp; continue echo "extension=$module.so" &gt;&gt; "$phpIni" done } installMissingPhpModules() { detectMissingPhpModules [ -z "$MISSING_PHP_MODULES" ] &amp;&amp; return osHandler_$os installPhpModules detectMissingPhpModules [ -z "$MISSING_PHP_MODULES" ] &amp;&amp; return cat &lt;&lt; EOF $CWARNING The following PHP modules appear to be missing: $MISSING_PHP_MODULES If the autodl-irssi ruTorrent plugin isn&#39;t working, you now know why. Install them using your package manager or enable them in your php.ini file, and restart your web server.$CEND EOF } addLogrotateConfig() { local serviceName="$1" local logFiles="$2" local postrotateScript="$3" local logrotate_d=/etc/logrotate.d [ -d "$logrotate_d" ] || errorExit "Missing logrotate dir: $logrotate_d" cat &gt; "$logrotate_d/$serviceName" &lt;&lt; EOF $logFiles { missingok daily rotate 14 notifempty compress delaycompress sharedscripts postrotate $postrotateScript endscript } EOF [ $? -eq 0 ] || errorExit "Could not write logrotate file $logrotate_d/$serviceName" } detectPhpCgi() { WWW_PHP_CGI=${WWW_PHP_CGI:-$(which php-cgi | head -n1)} [ -x "$WWW_PHP_CGI" ] || errorExit "Could not find php-cgi" "$WWW_PHP_CGI" -v | grep -q &#39;cgi-fcgi&#39; || errorExit "$WWW_PHP_CGI does not support FastCGI" } # $i is the i&#39;th user number getUserRpcMount() { local i=$1 verifyWebServerVars # Make sure /RPC10 accesses aren&#39;t going to /RPC1 by padding with zeros. This is # easier than making sure every web server handles it correctly. Eg., lighttpd&#39;s # scgi.server table is read in order, so if you add /RPC1 before /RPC10, then # /RPC10 accesses will go to /RPC1. A fix would of course be to place /RPC10 # before /RPC1 but it&#39;s easy to forget. Now we use /RPC00001 .. /RPC99999 echo "/$RPC_PREFIX$(printf &#39;%05d&#39; $i)" } createSelfSignedCertFile() { local pemfile="$1" if [ ! -f "$OTHER_PEM_FILE" ]; then echo "${CMSG}Creating the self-signed certificate.$CEND" rm -f "$pemfile" openssl req -new -newkey rsa:1024 -days 1000 -nodes -x509 -keyout "$pemfile" -out "$pemfile" -batch \ || errorExit "Failed to create self-signed certificate." OTHER_PEM_FILE="$pemfile" CREATED_CERT_FILE=y else rm -f "$pemfile" cp "$OTHER_PEM_FILE" "$pemfile" || errorExit "Failed to copy self-signed certificate." fi chmod 0600 "$pemfile" } detectHtpasswd() { [ -z "$htpasswd" ] &amp;&amp; isProgramInstalled htpasswd &amp;&amp; htpasswd=htpasswd [ -z "$htpasswd" ] &amp;&amp; isProgramInstalled htpasswd2 &amp;&amp; htpasswd=htpasswd2 if [ -z "$htpasswd" ]; then installProgram python if isProgramInstalled python; then cd downloadFile "htpasswd.py" "$HTPASSWD_PY_SCRIPT_URL" "$HTPASSWD_PY_SCRIPT_URL2" \ &amp;&amp; htpasswd="python $(pwd)/htpasswd.py" fi fi [ -z "$htpasswd" ] &amp;&amp; errorExit "Could not find htpasswd" } verifyWebServerVars() { [ -z "$WWW_PEMFILE" ] &amp;&amp; errorExit "You have not initialized WWW_PEMFILE" [ -z "$WWW_PASSWORD_FILE" ] &amp;&amp; errorExit "You have not initialized WWW_PASSWORD_FILE" [ -z "$WWW_ROOT" ] &amp;&amp; errorExit "You have not initialized WWW_ROOT" [ -z "$WWW_USER" ] &amp;&amp; errorExit "You have not initialized WWW_USER" [ -z "$WWW_GROUP" ] &amp;&amp; errorExit "You have not initialized WWW_GROUP" } initializeWwwRootVar() { WWW_ROOT=${WWW_ROOT:-/var/rutorrent} } createWebServerUserGroup() { verifyWebServerVars if ! grep -qE "^$WWW_GROUP:" /etc/group; then groupadd -r $WWW_GROUP 2&gt;/dev/null || groupadd $WWW_GROUP || errorExit "Could not create web server group." fi if ! grep -qE "^$WWW_USER:" /etc/passwd; then local useradd="useradd -d $WWW_ROOT -g $WWW_GROUP -s /bin/sh" $useradd -M -r $WWW_USER 2&gt;/dev/null || $useradd $WWW_USER || errorExit "Could not create web server user." fi } resetAuthPasswordFilePermissions() { [ -n "$WWW_USER" ] || errorExit "WWW_USER not initialized" [ -n "$WWW_GROUP" ] || errorExit "WWW_GROUP not initialized" chmod 0400 "$WWW_PASSWORD_FILE"* chown $WWW_USER:$WWW_GROUP "$WWW_PASSWORD_FILE"* } createAuthPasswordFile() { verifyWebServerVars : &gt; "$WWW_PASSWORD_FILE" resetAuthPasswordFilePermissions } # Some web servers (eg. nginx) can&#39;t allow just ONE user access to a certain # location. To fix that, create one password file per user. createOnePasswordFilePerUser() { for packedUser in $USERS; do extractPackedUser $packedUser grep "^$webUser:" "$WWW_PASSWORD_FILE" &gt; "${WWW_PASSWORD_FILE}_$webUser" done resetAuthPasswordFilePermissions } updatePhpTimezone() { if [ ! -f "$WWW_PHP_INI" ]; then echo "${CWARNING}Could not find php.ini file: $WWW_PHP_INI$CEND" return fi [ -z "$USER_TIMEZONE" ] &amp;&amp; return local zws="[ ]*" local newLine="date.timezone = $USER_TIMEZONE" if grep -qE "^${zws}date\\.timezone[ =]" "$WWW_PHP_INI"; then return elif grep -qE "^${zws}[;#]${zws}date\\.timezone[ =]" "$WWW_PHP_INI"; then sed_i "s!^${zws}[;#]${zws}date\\.timezone[ =].*\$!$newLine!" "$WWW_PHP_INI" else cat &gt;&gt; "$WWW_PHP_INI" &lt;&lt; EOF [Date] $newLine EOF fi } doDetectTimeZone() { echo "${CMSG}Detecting timezone...$CEND" detectTimeZone if [ -n "$USER_TIMEZONE" ]; then echo "${CMSG}Timezone: $USER_TIMEZONE$CEND" updatePhpTimezone else echo "${CWARNING}Could not detect timezone!$CEND" fi } webServerCommonInitialization() { mkdir -p $WWW_ROOT doDetectTimeZone createSelfSignedCertFile "$WWW_PEMFILE" createAuthPasswordFile } resetWebServerPermissions() { verifyWebServerVars chown -R $WWW_USER:$WWW_GROUP $WWW_ROOT || errorExit "Could not set web server as owner of $WWW_ROOT" } createPhpcgiSocket() { PHPCGI_SOCKET_DIR=/etc/phpcgi PHPCGI_SOCKET_FILE="$PHPCGI_SOCKET_DIR/php-cgi.socket" mkdir -p "$PHPCGI_SOCKET_DIR" chown $WWW_USER:$WWW_GROUP "$PHPCGI_SOCKET_DIR" chmod 0770 "$PHPCGI_SOCKET_DIR" } verifyApacheServerVars() { verifyWebServerVars [ -z "$APACHE_SITE_FILE" ] &amp;&amp; errorExit "You have not initialized APACHE_SITE_FILE" } apacheCreateApxs2Symlink() { # The makefile uses apxs2, so make a symlink if ! isProgramInstalled apxs2; then local apxs=$(which apxs 2&gt;/dev/null) &amp;&amp; ln -s "$apxs" "${apxs}2" fi } initializeApacheVars() { local apacheUser="$1" local apacheGroup="$2" local apacheSitesDir="$3" [ -n "$apacheUser" ] || errorExit "Invalid apache user: $apacheUser" [ -n "$apacheGroup" ] || errorExit "Invalid apache group: $apacheGroup" [ -d "$apacheSitesDir" ] || errorExit "Invalid apache sites dir: $apacheSitesDir" [ -d "$APACHE_DIR" ] || errorExit "Invalid apache dir: $APACHE_DIR" APACHE_SITE_NAME=${APACHE_SITE_NAME:-rutorrent.conf} APACHE_SITE_FILE=$apacheSitesDir/$APACHE_SITE_NAME initializeWwwRootVar WWW_PASSWORD_FILE=$APACHE_DIR/rutorrent_passwd WWW_PEMFILE=$APACHE_DIR/rutorrent.pem WWW_USER="$apacheUser" WWW_GROUP="$apacheGroup" } apacheGetRpcLocationDirectives() { if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF &lt;Location "$rpcMount"&gt; AuthType Basic AuthName "$RUTORRENT_SITE_REALM" AuthUserFile "$WWW_PASSWORD_FILE" Require user $webUser &lt;/Location&gt; EOF i=$(expr $i + 1) done fi } apacheGetVirtualHost() { local port=$1 local ssl=$2 cat &lt;&lt; EOF &lt;VirtualHost *:$port&gt; $(if [ "$ssl" = y ]; then echo " SSLEngine On" echo " SSLCertificateFile $WWW_PEMFILE" fi) ServerAdmin admin@rutorrent ServerName localhost DocumentRoot $WWW_ROOT &lt;Directory /&gt; AllowOverride None Order deny,allow Deny from all &lt;/Directory&gt; &lt;Location /&gt; AuthType Basic AuthName "$RUTORRENT_SITE_REALM" AuthUserFile "$WWW_PASSWORD_FILE" Require valid-user Order allow,deny Allow from all &lt;/Location&gt; &lt;Location ~ "^/rutorrent/(conf|share)"&gt; Order deny,allow Deny from all &lt;/Location&gt; &lt;Location ~ "/\\\\.svn"&gt; Order deny,allow Deny from all &lt;/Location&gt; $(apacheGetRpcLocationDirectives) &lt;/VirtualHost&gt; EOF } apacheWriteSiteFile() { verifyApacheServerVars cat &gt; "$APACHE_SITE_FILE" &lt;&lt; EOF ServerName localhost $(apacheGetVirtualHost $HTTP_PORT n) $(apacheGetVirtualHost $HTTPS_PORT y) EOF if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount="$(getUserRpcMount $i)" echo "${lp}SCGIMount $rpcMount $SCGI_HOST:$scgiPort" &gt;&gt; "$APACHE_SITE_FILE" i=$(expr $i + 1) done fi } apacheCommonInitialization() { local buildTools="$1" local modulesDir="$2" webServerCommonInitialization apacheWriteSiteFile if [ -n "$APACHE_SCGI_FILE" ] &amp;&amp; [ ! -f "$APACHE_SCGI_FILE" ]; then installBuildTools PACKAGES="$buildTools" installPackages apacheCreateApxs2Symlink # Compiling mod_scgi will fail unless we remove this warning-as-error flag local configVarsFile="$APACHE_DIR/modules/build/config_vars.mk" [ -f "$configVarsFile" ] &amp;&amp; sed_i &#39;s/-Werror=format-security//g&#39; "$configVarsFile" installModScgi "$APACHE_SCGI_FILE" "$modulesDir" fi } installCommonWebServerStuff_mandriva() { # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="php-cli gzip curl openssl logrotate" installPackages PACKAGE="unrar" installPackages PACKAGES="php-geoip" installPackages } # Used by Mandriva, Unity Linux, and PCLinuxOS installApache_mandriva() { installCommonWebServerStuff_mandriva PACKAGES="apache-mpm-prefork apache-mod_ssl apache-mod_php" installPackages WWW_PHP_INI=/etc/php.ini APACHE_DIR=/etc/httpd local APACHE_CONF_D=$APACHE_DIR/conf.d local APACHE_SITES_DIR=$APACHE_DIR/conf/vhosts.d APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf initializeApacheVars apache apache "$APACHE_SITES_DIR" apacheCommonInitialization "libopenssl-devel apache-devel" $APACHE_DIR/modules for file in 00_default_vhosts.conf 01_default_ssl_vhost.conf; do [ -f "$APACHE_SITES_DIR/$file" ] &amp;&amp; mv -f "$APACHE_SITES_DIR/$file" "$APACHE_SITES_DIR/$file-bak" done resetWebServerPermissions chkconfig httpd on service httpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" } installCommonWebServerStuff_gentoo() { # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="dev-lang/php logrotate" addProgram gzip app-arch/gzip addProgram curl net-misc/curl addProgram openssl dev-libs/openssl addProgram unrar app-arch/unrar installPackages ACCEPT_LICENSE=MaxMind export ACCEPT_LICENSE PACKAGES="dev-php5/pecl-geoip" installPackages unset ACCEPT_LICENSE } installApache_gentoo() { installCommonWebServerStuff_gentoo PACKAGES="www-servers/apache app-admin/apache-tools" installPackages PACKAGES="www-apache/mod_scgi" installPackages WWW_PHP_INI=$(ls /etc/php/apache2-php5*/php.ini | tail -n1) [ -f "$WWW_PHP_INI" ] || errorExit "Could not find Apache php.ini file" APACHE_DIR=/etc/apache2 local APACHE_CONF=$APACHE_DIR/httpd.conf local APACHE_SITES_DIR=$APACHE_DIR/vhosts.d local SERVER_ROOT=$(grep -E ^ServerRoot $APACHE_CONF | head -n1 | sed -e &#39;s!^.*[ ][^/]*\(/[^"]*\).*!\1!&#39;) APACHE_SCGI_FILE="$APACHE_DIR/modules.d/scgi.conf" [ -d "$SERVER_ROOT" ] || errorExit "Apache server root dir does not exist: $SERVER_ROOT" initializeApacheVars apache apache "$APACHE_SITES_DIR" apacheCommonInitialization "" $SERVER_ROOT/modules for file in 00_default_ssl_vhost.conf 00_default_vhost.conf; do [ -f "$APACHE_SITES_DIR/$file" ] &amp;&amp; mv -f "$APACHE_SITES_DIR/$file" "$APACHE_SITES_DIR/$file-bak" done appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS "-D SCGI" appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS "-D PHP5" appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS "-D SSL" cat &gt;&gt; $APACHE_SITE_FILE &lt;&lt; EOF Listen $HTTP_PORT Listen $HTTPS_PORT EOF resetWebServerPermissions rc-update add apache2 default osHandler_$os restart_$INSTALL_WEB_SERVER } nginxGetRpcMounts() { if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser getUserScgiSocketPath "$osUser" local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF $lp location ~ ^$rpcMount\$ { $lp include scgi_params; $lp scgi_pass unix:$scgiSocketPath; $lp auth_basic "$RUTORRENT_SITE_REALM"; $lp auth_basic_user_file "${WWW_PASSWORD_FILE}_$webUser"; $lp } EOF i=$(expr $i + 1) done fi } nginxGetServerSection() { local port=$1 local ssl=$2 cat &lt;&lt; EOF server { listen $port; server_name localhost; auth_basic "$RUTORRENT_SITE_REALM"; auth_basic_user_file "$WWW_PASSWORD_FILE"; $(if [ "$ssl" = y ]; then cat &lt;&lt; EOF2 ssl on; ssl_certificate $WWW_PEMFILE; ssl_certificate_key $WWW_PEMFILE; EOF2 fi) location ~ ^/rutorrent/(?:share|conf) { deny all; } location ~ /\.ht { deny all; } location ~ /\.svn { deny all; } location / { root $WWW_ROOT; index index.php index.html index.htm; } location ~ \.php$ { root "$WWW_ROOT"; fastcgi_pass unix:$PHPCGI_SOCKET_FILE; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name; include fastcgi_params; } $(nginxGetRpcMounts) } EOF } nginxWriteConfFile() { getNumCpus cat &gt; $NGINX_CONF &lt;&lt; EOF worker_processes $NUMCPUS; user $WWW_USER $WWW_GROUP; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # I have to set min length to 0 and http version to 1.0 or it won&#39;t compress # the XML-RPC (SCGI) responses. Those responses can be quite large if you&#39;re # using many torrent files. gzip on; gzip_min_length 0; gzip_http_version 1.0; gzip_types text/plain text/xml application/xml application/json text/css application/x-javascript text/javascript application/javascript; $(nginxGetServerSection $HTTP_PORT n) $(nginxGetServerSection $HTTPS_PORT y) } EOF [ $? -eq 0 ] || errorExit "Could not write to file $NGINX_CONF" } buildNginx() { buildStart PREFIX=$NGINX_DIR NGINX_BIN=$PREFIX/sbin/nginx NGINX_CONF=$PREFIX/conf/nginx.conf NGINX_PID_FILE=$PREFIX/nginx.pid NGINX_ACCESS_LOG=$PREFIX/logs/access.log NGINX_ERROR_LOG=$PREFIX/logs/error.log local configureFlags="\ --prefix=$PREFIX \ --sbin-path=$NGINX_BIN \ --conf-path=$NGINX_CONF \ --pid-path=$NGINX_PID_FILE \ --lock-path=$PREFIX/logs/nginx.lock \ --error-log-path=$NGINX_ERROR_LOG \ --http-log-path=$NGINX_ACCESS_LOG \ --user=$WWW_USER \ --group=$WWW_GROUP \ --with-http_ssl_module" export CFLAGS="$NGINX_CFLAGS" downloadAndBuild "nginx" "$NGINX_URL" "$NGINX_NAME" "$configureFlags" patchNginx unset CFLAGS buildEnd } patchNginx() { # Get rid of the -Werror flag for gcc 4.6.0 sed_i "s!-Werror[a-zA-Z0-9=-]*!!" "auto/cc/gcc" } installNginx() { SCGI_USE_UNIX_DOMAIN_SOCKET=y CREATE_ONE_PASSWORD_FILE_PER_USER=y installBuildTools osHandler_$os preNginxInstall installUnrar NGINX_DIR=/usr/local/nginx initializeWwwRootVar WWW_PASSWORD_FILE=$NGINX_DIR/rutorrent_passwd WWW_PEMFILE=$NGINX_DIR/rutorrent.pem WWW_USER=${WWW_USER:-nginx} WWW_GROUP=${WWW_GROUP:-nginx} detectPhpCgi createWebServerUserGroup createPhpcgiSocket buildNginx webServerCommonInitialization nginxWriteConfFile addLogrotateConfig nginx \ "$NGINX_ACCESS_LOG $NGINX_ERROR_LOG" \ "[ -f \"$NGINX_PID_FILE\" ] &amp;&amp; kill -USR1 \$(cat \"$NGINX_PID_FILE\") &gt;/dev/null 2&gt;&amp;1; true" resetWebServerPermissions osHandler_$os installPhpCgiService osHandler_$os installNginxService } preNginxInstall_gentoo() { installCommonWebServerStuff_gentoo PACKAGES="libpcre openssl zlib php" installPackages WWW_PHP_INI=$(ls /etc/php/cgi-php5*/php.ini | tail -n1) [ -f "$WWW_PHP_INI" ] || errorExit "Could not find php-cgi php.ini file" } preLighttpdInstall_gentoo() { preNginxInstall_gentoo } lighttpdGetRpcRequire() { if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF "$rpcMount" =&gt; ( "method" =&gt; "basic", "realm" =&gt; "$RUTORRENT_SITE_REALM", "require" =&gt; "user=$webUser", ), EOF i=$(expr $i + 1) done fi } lighttpdGetScgiServerTable() { echo &#39;scgi.server = (&#39; if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser getUserScgiSocketPath "$osUser" local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF $lp "$rpcMount" =&gt; ( $lp ( $lp "socket" =&gt; "$scgiSocketPath", $lp "check-local" =&gt; "disable", $lp "disable-time" =&gt; 0, $lp ), $lp ), EOF i=$(expr $i + 1) done fi echo &#39;)&#39; } lighttpdWriteConfFile() { cat &gt; $LIGHTTPD_CONF &lt;&lt; EOF server.follow-symlink = "disable" server.max-connections = 512 server.max-fds = 1024 server.max-keep-alive-idle = 15 dir-listing.activate = "disable" server.pid-file = "$LIGHTTPD_PID_FILE" server.errorlog = "$LIGHTTPD_ERROR_LOG" accesslog.filename = "$LIGHTTPD_ACCESS_LOG" $(if [ $(uname -s) = Linux ]; then echo &#39;server.event-handler = "linux-sysepoll"&#39; echo &#39;server.network-backend = "linux-sendfile"&#39; fi) server.username = "$WWW_USER" server.groupname = "$WWW_GROUP" server.modules = ( # "mod_rewrite", # "mod_redirect", # "mod_alias", "mod_access", "mod_auth", # "mod_status", # "mod_simple_vhost", # "mod_evhost", # "mod_userdir", # "mod_secdownload", "mod_fastcgi", # "mod_proxy", # "mod_cgi", "mod_scgi", # "mod_ssi", # "mod_compress", # "mod_usertrack", # "mod_expire", # "mod_rrdtool", "mod_accesslog", ) fastcgi.server = ( ".php" =&gt; ( ( "socket" =&gt; "$PHPCGI_SOCKET_FILE", ), ), ) index-file.names = ( "index.php", "index.html", "index.htm" ) static-file.exclude-extensions = ( ".fcgi", ".php", ".rb", "~", ".inc" ) mimetype.assign = ( ".html" =&gt; "text/html", ".htm" =&gt; "text/html", ".txt" =&gt; "text/plain", ".csv" =&gt; "text/plain", ".ini" =&gt; "text/plain", ".jpg" =&gt; "image/jpeg", ".jpeg" =&gt; "image/jpeg", ".gif" =&gt; "image/gif", ".png" =&gt; "image/png", ".bmp" =&gt; "image/bmp", ".css" =&gt; "text/css", ".js" =&gt; "application/javascript", ".ico" =&gt; "image/x-icon", ".json" =&gt; "application/json", ".torrent" =&gt; "application/x-bittorrent", ".pdf" =&gt; "application/pdf", ".bz2" =&gt; "application/x-bzip2", ".gz" =&gt; "application/x-gzip", ".tar.gz" =&gt; "application/x-tgz", ".tar" =&gt; "application/x-tar", ".tar.bz2" =&gt; "application/x-bzip-compressed-tar", ".tbz" =&gt; "application/x-bzip-compressed-tar", ".tgz" =&gt; "application/x-tgz", ".zip" =&gt; "application/zip", ".mp3" =&gt; "audio/mpeg", ".flac" =&gt; "audio/x-flac", ".m3u" =&gt; "audio/x-mpegurl", ".wma" =&gt; "audio/x-ms-wma", ".wax" =&gt; "audio/x-ms-wax", ".ogg" =&gt; "audio/ogg", ".wav" =&gt; "audio/x-wav", ".dtd" =&gt; "text/xml", ".xml" =&gt; "text/xml", ".mpeg" =&gt; "video/mpeg", ".mpg" =&gt; "video/mpeg", ".mp4" =&gt; "video/mp4", ".wmv" =&gt; "video/x-ms-wmv", ".avi" =&gt; "video/x-msvideo", ) server.document-root = "$WWW_ROOT" server.port = $HTTP_PORT \$SERVER["socket"] == ":$HTTPS_PORT" { ssl.engine = "enable" ssl.pemfile = "$WWW_PEMFILE" } url.access-deny = (".htaccess") \$HTTP["url"] =~ "^/rutorrent/(?:share|conf)" { url.access-deny = ("") } \$HTTP["url"] =~ "/\\.svn" { url.access-deny = ("") } auth.backend = "htpasswd" auth.backend.htpasswd.userfile = "$WWW_PASSWORD_FILE" auth.require = ( $(lighttpdGetRpcRequire) "/" =&gt; ( "method" =&gt; "basic", "realm" =&gt; "$RUTORRENT_SITE_REALM", "require" =&gt; "valid-user", ), ) $(lighttpdGetScgiServerTable) EOF [ $? -eq 0 ] || errorExit "Could not write to file $LIGHTTPD_CONF" } buildLighttpd() { buildStart PREFIX=$LIGHTTPD_DIR LIGHTTPD_BIN=$PREFIX/sbin/lighttpd LIGHTTPD_CONF=$PREFIX/lighttpd.conf # The log dir will be set to owner lighttpd since it&#39;s started as non-root. # Put the pid file there so it can write to it. LIGHTTPD_LOG_DIR=$PREFIX/logs LIGHTTPD_PID_FILE=$LIGHTTPD_LOG_DIR/lighttpd.pid LIGHTTPD_ERROR_LOG=$LIGHTTPD_LOG_DIR/error.log LIGHTTPD_ACCESS_LOG=$LIGHTTPD_LOG_DIR/access.log local configureFlags="\ --prefix=$PREFIX \ --with-openssl \ --with-pcre \ --with-zlib \ --without-bzip2" downloadAndBuild "lighttpd" "$LIGHTTPD_URL" "$LIGHTTPD_NAME" "$configureFlags" buildEnd } installLighttpd() { SCGI_USE_UNIX_DOMAIN_SOCKET=y installBuildTools osHandler_$os preLighttpdInstall installUnrar LIGHTTPD_DIR=/usr/local/lighttpd initializeWwwRootVar WWW_PASSWORD_FILE=$LIGHTTPD_DIR/rutorrent_passwd WWW_PEMFILE=$LIGHTTPD_DIR/rutorrent.pem WWW_USER=${WWW_USER:-lighttpd} WWW_GROUP=${WWW_GROUP:-lighttpd} detectPhpCgi createWebServerUserGroup createPhpcgiSocket buildLighttpd webServerCommonInitialization lighttpdWriteConfFile addLogrotateConfig lighttpd \ "$LIGHTTPD_ACCESS_LOG $LIGHTTPD_ERROR_LOG" \ "[ -f \"$LIGHTTPD_PID_FILE\" ] &amp;&amp; kill -HUP \$(cat \"$LIGHTTPD_PID_FILE\") &gt;/dev/null 2&gt;&amp;1; true" mkdir -p "$LIGHTTPD_LOG_DIR" chown -R $WWW_USER:$WWW_GROUP "$LIGHTTPD_LOG_DIR" resetWebServerPermissions osHandler_$os installPhpCgiService osHandler_$os installLighttpdService } # Add $name=$value to the file, or modify an existing line if present in the file setVsftpdValue() { local confFile="$1" local name="$2" local value="$3" local newLine="$name=$value" sed_i "s!^[ ]*$name[ =:].*\$!$newLine!" "$confFile" grep -qE "^$newLine$" "$confFile" || echo "$newLine" &gt;&gt; "$confFile" } # Same as setVsftpdValue but makes sure the option exists setVsftpdValue2() { local confFile="$1" local name="$2" local value="$3" [ -z "$VSFTPD_PATH" ] &amp;&amp; return grep -q "$name" "$VSFTPD_PATH" &amp;&amp; setVsftpdValue "$confFile" "$name" "$value" } updateVsftpdConf() { local confFile="$1" touch "$confFile" VSFTPD_PATH=$(which vsftpd 2&gt;/dev/null) setVsftpdValue "$confFile" anonymous_enable NO setVsftpdValue "$confFile" dirlist_enable YES setVsftpdValue "$confFile" download_enable YES setVsftpdValue "$confFile" guest_enable NO setVsftpdValue "$confFile" listen YES setVsftpdValue "$confFile" listen_ipv6 NO setVsftpdValue "$confFile" local_enable YES setVsftpdValue "$confFile" local_umask $DEFAULT_UMASK setVsftpdValue "$confFile" max_per_ip 0 setVsftpdValue "$confFile" pasv_enable YES setVsftpdValue "$confFile" port_enable YES setVsftpdValue "$confFile" pasv_promiscuous NO setVsftpdValue "$confFile" port_promiscuous NO setVsftpdValue "$confFile" pasv_min_port 0 setVsftpdValue "$confFile" pasv_max_port 0 setVsftpdValue "$confFile" write_enable YES if [ "$USE_ENCRYPTED_FTP" = y ]; then local pemfile=/etc/vsftpd.pem createSelfSignedCertFile "$pemfile" FTP_SERVER_TYPE="FTPES - Encrypted (FTP over explicit TLS/SSL)" FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTPES} setVsftpdValue "$confFile" listen_port $FTP_PORT setVsftpdValue "$confFile" ssl_enable YES setVsftpdValue "$confFile" allow_anon_ssl NO setVsftpdValue "$confFile" force_local_data_ssl YES setVsftpdValue "$confFile" force_local_logins_ssl YES setVsftpdValue "$confFile" ssl_sslv2 NO setVsftpdValue "$confFile" ssl_sslv3 NO setVsftpdValue "$confFile" ssl_tlsv1 YES setVsftpdValue "$confFile" rsa_cert_file "$pemfile" setVsftpdValue2 "$confFile" implicit_ssl NO setVsftpdValue2 "$confFile" require_cert NO setVsftpdValue2 "$confFile" require_ssl_reuse NO setVsftpdValue2 "$confFile" ssl_request_cert YES setVsftpdValue2 "$confFile" strict_ssl_read_eof NO setVsftpdValue2 "$confFile" strict_ssl_write_shutdown NO setVsftpdValue2 "$confFile" validate_cert NO else FTP_SERVER_TYPE="FTP - Non-encrypted" FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTP} setVsftpdValue "$confFile" listen_port $FTP_PORT setVsftpdValue "$confFile" ssl_enable NO fi # The private key is in rsa_cert_file sed_i &#39;g/rsa_private_key_file/d&#39; "$confFile" } installVsftpd_chkconfig() { local vsftpdConf="$1" installProgram vsftpd [ -f "$vsftpdConf" ] || errorExit "Invalid vsftpd.conf file: $vsftpdConf" updateVsftpdConf "$vsftpdConf" chkconfig vsftpd on if ! service vsftpd restart; then if [ "$SELINUX_ENABLED" = y ]; then errorExit "Could not restart vsftpd. SELinux could be the reason." else errorExit "Could not restart vsftpd" fi fi } installVsftpd_gentoo() { installProgram net-ftp/vsftpd local vsftpdConf=/etc/vsftpd/vsftpd.conf if ! [ -f $vsftpdConf ]; then touch $vsftpdConf [ -f $vsftpdConf.example ] &amp;&amp; cp $vsftpdConf.example $vsftpdConf fi updateVsftpdConf $vsftpdConf rc-update add vsftpd default /etc/init.d/vsftpd restart } installService_chkconfig1() { CHKCONFIG_SERVICE_NAME=$1 CHKCONFIG_SERVICE_FILE=/etc/init.d/$CHKCONFIG_SERVICE_NAME CHKCONFIG_LOCK_FILE=/var/lock/subsys/$CHKCONFIG_SERVICE_NAME } installService_chkconfig2() { chmod +x "$CHKCONFIG_SERVICE_FILE" || errorExit "Could not set +x bit, file $CHKCONFIG_SERVICE_FILE." chkconfig --add $CHKCONFIG_SERVICE_NAME || errorExit "Could not install service $CHKCONFIG_SERVICE_FILE. Run this script as root." service $CHKCONFIG_SERVICE_NAME restart } getChkconfigScriptContents() { local desc="$1" cat &lt;&lt; EOF # chkconfig: 2345 85 15 # description: $desc EOF } getLsbStartupScriptContents() { local startupName="$1" local desc="$2" cat &lt;&lt; EOF ### BEGIN INIT INFO # Provides: $startupName # Required-Start: \$local_fs \$network \$syslog # Required-Stop: \$local_fs \$syslog # Default-Start: $LSB_DEFAULT_START # Default-Stop: $LSB_DEFAULT_STOP # Short-Description: $desc # Description: $desc ### END INIT INFO EOF } # You must define v_{startIt,stopIt,restartIt,showStatus} and isStarted funcs getLsbStartupFooter() { cat &lt;&lt; EOF resetPath # Some include files may have reset it LOCKFILE=$1 updateLock() { [ -z "\$LOCKFILE" ] &amp;&amp; return if isStarted; then touch \$LOCKFILE else rm -f \$LOCKFILE fi } RETVAL=0 case \$1 in start) v_startIt ;; stop) v_stopIt ;; force-reload|restart) v_restartIt ;; try-restart) isStarted &amp;&amp; v_restartIt ;; status) v_showStatus ;; *) echo "Usage: \$0 {start|stop|restart|try-restart|force-reload|status}" RETVAL=1 ;; esac updateLock exit \$RETVAL EOF } getCommonStartupScriptContents_autodl() { local USER="$1" local STARTUPNAME="$2" cat &lt;&lt; EOF NAME=$STARTUPNAME USER=$USER SESSIONNAME=autodl resetPath() { PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\$PATH" } resetPath # Make sure the path is correct, and make sure we&#39;re in the home dir. USER_INIT="umask $DEFAULT_UMASK; cd; PATH=\\\$PATH:\$PATH" # Run user command, ignoring any messages sent to stdout (eg. &#39;No mail.&#39;) runUserCmd() { su - \$USER -c "\$USER_INIT; \$1" &gt;/dev/null &amp;&amp; return 0 return 1 } isStarted() { su - \$USER -c "\$USER_INIT; screen -ls | grep -qE \\"[ ][0-9]+\\\\.\$SESSIONNAME[ ]\\"" &gt;/dev/null &amp;&amp; return 0 return 1 } startIt() { isStarted &amp;&amp; return 0 local START_IRSSI=n local START_RTORRENT=n which irssi &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_IRSSI=y which rtorrent &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_RTORRENT=y case \$START_IRSSI\$START_RTORRENT in yy) runUserCmd "screen -S \$SESSIONNAME -d -t rtorrent -m rtorrent" runUserCmd "screen -d -r \$SESSIONNAME -X screen -t irssi irssi" ;; yn) runUserCmd "screen -S \$SESSIONNAME -d -t irssi -m irssi" ;; ny) runUserCmd "screen -S \$SESSIONNAME -d -t rtorrent -m rtorrent" ;; nn) ;; esac return 0 } stopIt() { isStarted || return 0 runUserCmd "screen -d -r \$SESSIONNAME -p irssi -X stuff \\"/quit /quit \\"" runUserCmd "screen -d -r \$SESSIONNAME -p rtorrent -X xon" for i in 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4; do isStarted || break sleep 1 done # If it&#39;s still not stopped, kill the whole screen session if isStarted; then echo -n "Couldn&#39;t stop it. Killing screen session..." runUserCmd "screen -d -r \$SESSIONNAME -p rtorrent -X xon" sleep 2 runUserCmd "screen -d -r \$SESSIONNAME -X quit" echo "Done." fi return 0 } v_restartIt() { v_stopIt v_startIt } v_showStatus() { if isStarted; then echo "\$NAME is running." else echo "\$NAME is stopped." fi } EOF } getChkconfigScriptContents_autodl() { getChkconfigScriptContents "$AUTODL_STARTUP_DESC" } # LSB style script, also supports chkconfig # $1 = user name # $2 = service name getLsbStartupHeader_autodl() { local USER="$1" local STARTUPNAME="$2" cat &lt;&lt; EOF $(getChkconfigScriptContents_autodl) $(getLsbStartupScriptContents "$STARTUPNAME" "$AUTODL_STARTUP_DESC") $(getCommonStartupScriptContents_autodl "$USER" "$STARTUPNAME") EOF } installService_mandriva() { local serviceName="$1" local headerCommand="$2" installService_chkconfig1 $serviceName cat &gt; "$CHKCONFIG_SERVICE_FILE" &lt;&lt; EOF #!/bin/bash $(eval $headerCommand) . /etc/rc.d/init.d/functions v_startIt() { gprintf "Starting %s:" "\$NAME" startIt &amp;&amp; success "startup" || failure "startup" echo } v_stopIt() { gprintf "Stopping %s:" "\$NAME" stopIt &amp;&amp; success "stop" || failure "stop" echo } $(getLsbStartupFooter "$CHKCONFIG_LOCK_FILE") EOF [ $? -eq 0 ] || errorExit "Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root." installService_chkconfig2 } installService_mandriva_autodl() { local user=$1 installService_mandriva autodl_$user "getLsbStartupHeader_autodl \"$user\" \"\$CHKCONFIG_SERVICE_NAME\"" } installService_mandriva_phpcgi() { installService_mandriva phpcgi getLsbStartupHeader_phpcgi } installService_mandriva_nginx() { installService_mandriva nginx getLsbStartupHeader_nginx } installService_mandriva_lighttpd() { installService_mandriva lighttpd getLsbStartupHeader_lighttpd } installService_gentoo() { local scriptName="$1" local desc="$2" local headerCommand="$3" local serviceFile="/etc/init.d/$scriptName" cat &gt; "$serviceFile" &lt;&lt; EOF #!/sbin/runscript name=$scriptName description="$desc" depend() { need localmount need net } $(eval $headerCommand) start() { ebegin "Starting \$name" startIt eend \$? } stop() { ebegin "Stopping \$name" stopIt eend \$? } status() { if isStarted; then einfo "status: started" return 0 else einfo "status: stopped" return 1 fi } EOF [ $? -eq 0 ] || errorExit "Could not write to file $serviceFile. Run this script as root." chmod +x "$serviceFile" rc-update add $scriptName default || errorExit "Could not add service $scriptName" $serviceFile restart } installService_gentoo_autodl() { local user="$1" installService_gentoo autodl_$user "$AUTODL_STARTUP_DESC" "getCommonStartupScriptContents_autodl \"$user\" \"\$scriptName\"" } installService_gentoo_phpcgi() { installService_gentoo phpcgi "$PHPCGI_STARTUP_DESC" "getCommonStartupScriptContents_phpcgi \"$WWW_USER\" \"$WWW_PHP_CGI\"" } installService_gentoo_nginx() { installService_gentoo nginx "$NGINX_STARTUP_DESC" "getCommonStartupScriptContents_nginx \"$NGINX_BIN\"" } installService_gentoo_lighttpd() { installService_gentoo lighttpd "$LIGHTTPD_STARTUP_DESC" "getCommonStartupScriptContents_lighttpd \"$LIGHTTPD_BIN\"" } installService_bsd_autodl() { local user="$1" local scriptName="$2" local file="$3" cat &gt; "$file" &lt;&lt; EOF #!/bin/sh # PROVIDE: autodl_$user # REQUIRE: FILESYSTEMS NETWORKING # KEYWORD: shutdown . /etc/rc.subr name=$scriptName desc="$AUTODL_STARTUP_DESC" start_cmd=v_startIt stop_cmd=v_stopIt restart_cmd=v_restartIt reload_cmd=v_restartIt status_cmd=v_showStatus extra_commands="status" v_startIt() { echo -n "Starting \$NAME" startIt &amp;&amp; echo "." || echo ". ERROR." } v_stopIt() { echo -n "Stopping \$NAME..." stopIt &amp;&amp; echo "done." || echo "ERROR." } $(getCommonStartupScriptContents_autodl "$user" "$scriptName") load_rc_config \$name run_rc_command "\$1" EOF [ $? -eq 0 ] || errorExit "Could not write to file $file. Run this script as root." chmod +x "$file" } getCommonStartupScriptContents_simpleService() { local USER="$1" local BINPATH="$2" local START_CMD="$3" local PID_FILE="$4" cat &lt;&lt; EOF USER=$USER BINPATH="$BINPATH" NAME=\${BINPATH##*/} PID_FILE="$PID_FILE" resetPath() { PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\$PATH" } resetPath getPids() { if [ -n "\$PID_FILE" ]; then pids= [ -f "\$PID_FILE" ] || return local the_pids="\$(cat "\$PID_FILE" 2&gt;/dev/null)" for pid in \$the_pids; do PS_FORMAT= LINES= COLUMNS= ps ax | grep -qE "^[ ]*\$pid[ ]" &amp;&amp; pids="\$pids \$pid" done [ -z "\$pids" ] &amp;&amp; rm -f "\$PID_FILE" else # ps uses the COLUMNS variable... Make sure it&#39;s off so we get the full path. pids=\$(PS_FORMAT= LINES= COLUMNS= ps aux | grep -v grep | grep \$BINPATH | awk &#39;{print \$2}&#39;) fi } isStarted() { getPids [ -n "\$pids" ] &amp;&amp; return 0 return 1 } startIt() { isStarted &amp;&amp; return 0 if [ \$USER = root ]; then $START_CMD else su - \$USER "-c $START_CMD" fi [ -n "\$PID_FILE" ] &amp;&amp; sleep 2 # Allow it some time to create the pid file if ! isStarted; then for i in 1 2 3 4 5; do sleep 1 isStarted &amp;&amp; break done isStarted || return 1 fi return 0 } stopIt() { isStarted || return 0 kill \$pids 2&gt;/dev/null for i in 0 1 2 3 4 5 6 7 8 9; do isStarted || break sleep 1 done isStarted &amp;&amp; kill -KILL \$pids 2&gt;/dev/null return 0 } v_startIt() { startIt } v_stopIt() { stopIt } v_restartIt() { v_stopIt v_startIt } v_showStatus() { if isStarted; then echo "\$NAME is running." else echo "\$NAME is stopped." fi } EOF } getCommonStartupScriptContents_phpcgi() { [ -n "$PHPCGI_SOCKET_FILE" ] || errorExit "PHPCGI_SOCKET_FILE is not initialized" getCommonStartupScriptContents_simpleService "$1" "$2" \ "PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 \$BINPATH -q -b \"$PHPCGI_SOCKET_FILE\" &amp;" } getLsbStartupHeader_phpcgi() { getChkconfigScriptContents "$PHPCGI_STARTUP_DESC" getLsbStartupScriptContents phpcgi "$PHPCGI_STARTUP_DESC" getCommonStartupScriptContents_phpcgi "$WWW_USER" "$WWW_PHP_CGI" } getCommonStartupScriptContents_nginx() { getCommonStartupScriptContents_simpleService "root" "$1" "\$BINPATH" "$NGINX_PID_FILE" } getLsbStartupHeader_nginx() { getChkconfigScriptContents "$NGINX_STARTUP_DESC" getLsbStartupScriptContents nginx "$NGINX_STARTUP_DESC" getCommonStartupScriptContents_nginx "$NGINX_BIN" } getCommonStartupScriptContents_lighttpd() { getCommonStartupScriptContents_simpleService "root" "$1" "\$BINPATH -f $LIGHTTPD_CONF 2&gt;/dev/null" "$LIGHTTPD_PID_FILE" } getLsbStartupHeader_lighttpd() { getChkconfigScriptContents "$LIGHTTPD_STARTUP_DESC" getLsbStartupScriptContents lighttpd "$LIGHTTPD_STARTUP_DESC" getCommonStartupScriptContents_lighttpd "$LIGHTTPD_BIN" } addLsbHeaderToStartupScript() { local scriptPath="$1" local provides="${2:-$scriptPath}" local desc="${3:-$provides}" [ -x "$scriptPath" ] || return grep -qE &#39;^### BEGIN INIT INFO&#39; "$scriptPath" &amp;&amp; return ed -s "$scriptPath" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF 1a $(getLsbStartupScriptContents "$provides" "$desc") . w q EOF } installMissingPerlModules() { detectMissingPerlModules [ -z "$MISSING_PERL_MODULES" ] &amp;&amp; return cat &lt;&lt; EOF $CWARNING The following Perl modules are still missing: $MISSING_PERL_MODULES I&#39;ll try to use the cpan script to install them.$CEND EOF # Some Perl modules will fail to build unless Test::More is installed MISSING_PERL_MODULES="Test::More $MISSING_PERL_MODULES" echo "${CMSG}Installing cpan and required build tools...$CEND" installBuildTools osHandler_$os installCpanTools detectCpanBin if [ -n "$CPAN" ]; then $CPAN $MISSING_PERL_MODULES else local mods= for mod in $MISSING_PERL_MODULES; do [ -n "$mods" ] &amp;&amp; mods="$mods," mods="$mods \"$mod\"" done perl -MCPAN -e "CPAN::Shell-&gt;install($mods)" fi detectMissingPerlModules [ -z "$MISSING_PERL_MODULES" ] &amp;&amp; return errorExit "CPAN somehow failed to install the missing Perl modules. Missing: $MISSING_PERL_MODULES" } osHandler_debian() { case $1 in init) INSTALL="apt-get -y install" FEATURES="service rtorrent apache nginx lighttpd vsftpd webmin" BUILD_TOOLS="build-essential make file pkg-config libtool m4" ;; init2) apt-get update installProgram ed # Make sure Debian 6 doesn&#39;t fail when adding new services. We need ed for this # so run it after installing ed... addLsbHeaderToStartupScript /etc/init.d/webmin "webmin" "webmin" ;; installTools) PACKAGES= addProgram irssi addProgram mediainfo addProgram git-core addProgram svn subversion addProgram wget addProgram unzip addProgram screen installPackages # Make sure subversion won&#39;t complain about invalid certs $INSTALL ca-certificates ;; installAutodlTools) PACKAGES= addProgram perl addPerlModule Archive::Zip libarchive-zip-perl addPerlModule HTML::Parser libhtml-parser-perl addPerlModule Digest::SHA1 libdigest-sha-perl installPackages installPerlModule Net::SSLeay libnet-ssleay-perl installPerlModule XML::LibXML libxml-libxml-perl installPerlModule JSON::XS libjson-xs-perl installPerlModule JSON libjson-perl ;; installCpanTools) # Need to remove the old JSON or cpan may fail to build the modules if echo "$OLD_PERL_MODULES" | grep -qE &#39;(^| )JSON( |$)&#39;; then apt-get -y remove libjson-perl fi PACKAGES= if echo "$MISSING_PERL_MODULES" | grep -q &#39;XML::LibXML&#39;; then PACKAGES="$PACKAGES libxml2 libxml2-dev zlib1g zlib1g-dev" fi if echo "$MISSING_PERL_MODULES" | grep -q &#39;Net::SSLeay&#39;; then # There&#39;s no libssl package PACKAGES="$PACKAGES openssl libssl-dev zlib1g zlib1g-dev" fi installPackages ;; installRtorrentBuildTools) PACKAGES="libsigc++-2.0-dev libssl-dev libncurses-dev" if apt-cache search libcurl4-openssl-dev 2&gt; /dev/null | grep -q &#39;libcurl4-openssl-dev&#39;; then PACKAGES="$PACKAGES libcurl4-openssl-dev" else PACKAGES="$PACKAGES libcurl3-openssl-dev" fi installPackages ;; installPhpModules) installMissingPhp5Packages ;; _installService) local serviceName="$2" local headerCommand="$3" local serviceFile=/etc/init.d/$serviceName local lockFile= cat &gt; "$serviceFile" &lt;&lt; EOF #!/bin/sh $(eval $headerCommand) . /lib/lsb/init-functions v_startIt() { log_begin_msg "Starting \$NAME..." startIt log_end_msg \$? } v_stopIt() { log_begin_msg "Stopping \$NAME..." stopIt log_end_msg \$? } $(getLsbStartupFooter "$lockFile") EOF [ $? -eq 0 ] || errorExit "Could not write to file $serviceFile. Run this script as root." chmod +x "$serviceFile" || errorExit "Could not set +x bit, file $serviceFile." update-rc.d $serviceName defaults || errorExit "Could not install service $serviceFile. Run this script as root." invoke-rc.d $serviceName restart ;; installAutodlService) local user=$2 osHandler_$os _installService autodl_$user "getLsbStartupHeader_autodl \"$user\" \"\$serviceName\"" ;; _installCommonWebServerStuff) # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="php5-cli gzip curl openssl logrotate" installPackages # Ubuntu 8 doesn&#39;t have php5-geoip PACKAGES="php5-geoip" installPackages PACKAGES="unrar" installPackages ;; installApache) osHandler_$os _installCommonWebServerStuff PACKAGES="apache2-mpm-prefork libapache2-mod-php5 php5 " installPackages PACKAGES="libapache2-mod-scgi"; installPackages WWW_PHP_INI=/etc/php5/apache2/php.ini APACHE_DIR=/etc/apache2 APACHE_SITE_NAME=rutorrent.conf APACHE_SCGI_FILE=$APACHE_DIR/mods-available/scgi.load initializeApacheVars www-data www-data "$APACHE_DIR/sites-available" apacheCommonInitialization "apache2-prefork-dev" /usr/lib/apache2/modules a2enmod ssl || errorExit "Could not enable mod_ssl" a2enmod scgi || errorExit "Could not enable mod_scgi" # Ubuntu Server 6 doesn&#39;t come with this module a2enmod auth_basic a2dissite default a2dissite default-ssl a2ensite $APACHE_SITE_NAME || errorExit "Could not enable site" if ! grep -qE "^[ ]*Listen.*[: ]$HTTPS_PORT\\&gt;" "$APACHE_DIR/ports.conf"; then echo "Listen $HTTPS_PORT" &gt;&gt; "$APACHE_DIR/ports.conf" fi resetWebServerPermissions invoke-rc.d apache2 restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; restart_apache) invoke-rc.d apache2 restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; installVsftpd) installProgram vsftpd updateVsftpdConf /etc/vsftpd.conf invoke-rc.d vsftpd restart || errorExit "Could not restart vsftpd" ;; preNginxInstall) WWW_PHP_INI=/etc/php5/cgi/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="libpcre3-dev libssl-dev zlib1g-dev php5-cgi" installPackages # Make sure it builds on Debian GNU/kFreeBSD 6.0. if [ "$(uname -s)" != Linux ]; then NGINX_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64" fi ;; installPhpCgiService) osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi ;; installNginxService) osHandler_$os _installService nginx getLsbStartupHeader_nginx ;; restart_nginx) invoke-rc.d phpcgi restart || errorExit "Could not start php-cgi" invoke-rc.d nginx restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; preLighttpdInstall) WWW_PHP_INI=/etc/php5/cgi/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="libpcre3-dev libssl-dev zlib1g-dev php5-cgi" installPackages ;; installLighttpdService) osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd ;; restart_lighttpd) invoke-rc.d phpcgi restart || errorExit "Could not start php-cgi" invoke-rc.d lighttpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; postWebminInstall) addLsbHeaderToStartupScript /etc/init.d/webmin "webmin" "webmin" ;; *) ;; esac } osHandler_fedora() { case $1 in init) INSTALL="yum -y install" FEATURES="service rtorrent apache nginx lighttpd vsftpd webmin" BUILD_TOOLS="gcc gcc-c++ make kernel-headers pkgconfig file libtool m4" ;; init2) installProgram which installProgram ed ;; installTools) PACKAGES= addProgram svn subversion addProgram wget addProgram unzip addProgram screen addProgram git installPackages ;; installAutodlTools) if grep -q "release 4[. ]" /etc/redhat-release; then IRSSI_LOAD_PERL=y fi PACKAGES= addProgram perl addProgram irssi addPerlModule Time::HiRes perl-Time-HiRes addPerlModule Archive::Zip perl-Archive-Zip addPerlModule Net::SSLeay perl-Net-SSLeay addPerlModule HTML::Parser perl-HTML-Parser addPerlModule XML::LibXML perl-XML-LibXML addPerlModule Digest::SHA1 perl-Digest-SHA1 addPerlModule JSON::XS perl-JSON-XS addPerlModule JSON perl-JSON installPackages ;; installCpanTools) # Need to remove the old JSON or cpan may fail to build the modules if echo "$OLD_PERL_MODULES" | grep -qE &#39;(^| )JSON( |$)&#39;; then yum -y remove perl-JSON fi # CentOS doesn&#39;t have &#39;perl-CPAN&#39;. It&#39;s in the &#39;perl&#39; package though. PACKAGES="perl-CPAN" if echo "$MISSING_PERL_MODULES" | grep -q &#39;XML::LibXML&#39;; then PACKAGES="$PACKAGES libxml2 libxml2-devel zlib zlib-devel" fi if echo "$MISSING_PERL_MODULES" | grep -q &#39;Net::SSLeay&#39;; then PACKAGES="$PACKAGES openssl openssl-devel zlib zlib-devel" fi installPackages ;; installRtorrentBuildTools) # CentOS 5: curl-devel, no libsigc++20 # Fedora 14: libcurl-devel PACKAGES="libsigc++20-devel ncurses-devel openssl-devel libcurl-devel curl-devel" installPackages ;; installPhpModules) ;; _installService) local serviceName="$2" local headerCommand="$3" installService_chkconfig1 $serviceName cat &gt; "$CHKCONFIG_SERVICE_FILE" &lt;&lt; EOF #!/bin/bash $(eval $headerCommand) . /etc/rc.d/init.d/functions v_startIt() { echo -n "Starting \$NAME: " startIt &amp;&amp; success || failure echo } v_stopIt() { echo -n "Stopping \$NAME: " stopIt &amp;&amp; success || failure echo } $(getLsbStartupFooter "$CHKCONFIG_LOCK_FILE") EOF [ $? -eq 0 ] || errorExit "Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root." installService_chkconfig2 ;; installAutodlService) local user=$2 osHandler_$os _installService autodl_$user "getLsbStartupHeader_autodl \"$user\" \"\$CHKCONFIG_SERVICE_NAME\"" ;; _installCommonWebServerStuff) PACKAGE="php-cli gzip curl openssl unrar logrotate" installPackages # CentOS 4: will get an error about a php v4 dependency, so can&#39;t put it in above PACKAGE var PACKAGES="php-pecl-geoip" installPackages ;; installApache) osHandler_$os _installCommonWebServerStuff # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="httpd httpd-tools mod_ssl mod_scgi php" installPackages WWW_PHP_INI=/etc/php.ini APACHE_DIR=/etc/httpd local APACHE_CONF_D=$APACHE_DIR/conf.d APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf initializeApacheVars apache apache "$APACHE_CONF_D" apacheCommonInitialization "httpd-devel" $APACHE_DIR/modules [ -f "$APACHE_CONF_D/welcome.conf" ] &amp;&amp; mv -f "$APACHE_CONF_D/welcome.conf" "$APACHE_CONF_D/welcome.conf-bak" # Remove an Apache warning by commenting out the default SSL VirtualHost sed_i &#39;/^&lt;VirtualHost _default_:443&gt;/,/^&lt;\/VirtualHost&gt;/s/^/#/&#39; $APACHE_CONF_D/ssl.conf resetWebServerPermissions chkconfig httpd on service httpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; restart_apache) service httpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; installVsftpd) installVsftpd_chkconfig /etc/vsftpd/vsftpd.conf ;; preNginxInstall) WWW_PHP_INI=/etc/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="pcre-devel openssl-devel zlib-devel php-cgi" installPackages ;; installPhpCgiService) osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi ;; installNginxService) osHandler_$os _installService nginx getLsbStartupHeader_nginx ;; restart_nginx) service phpcgi restart || errorExit "Could not start php-cgi" service nginx restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; preLighttpdInstall) WWW_PHP_INI=/etc/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="pcre-devel openssl-devel zlib-devel php-cgi" installPackages ;; installLighttpdService) osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd ;; restart_lighttpd) service phpcgi restart || errorExit "Could not start php-cgi" service lighttpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; *) ;; esac } isWebServerRpcModule() { ! arrayIsPresent rpc $RUTORRENT_PLUGINS &amp;&amp; ! arrayIsPresent httprpc $RUTORRENT_PLUGINS &amp;&amp; return 0 return 1 } canInstallService() { return $(arrayIsPresent service $FEATURES) } canInstallRtorrent() { return $(arrayIsPresent rtorrent $FEATURES) } canInstallApache() { return $(arrayIsPresent apache $FEATURES) } canInstallNginx() { return $(arrayIsPresent nginx $FEATURES) } canInstallLighttpd() { return $(arrayIsPresent lighttpd $FEATURES) } canInstallVsftpd() { return $(arrayIsPresent vsftpd $FEATURES) } canInstallWebmin() { return $(arrayIsPresent webmin $FEATURES) } getRequiredPrograms() { REQUIRED_PROGRAMS="which svn wget unzip ed sed grep tar expr ps awk kill printf" if [ "$INSTALL_AUTODL_IRSSI" = y ]; then REQUIRED_PROGRAMS="$REQUIRED_PROGRAMS perl" # NetBSD and DragonFly BSD don&#39;t compile Irssi with Perl support by default [ "$IGNORE_IRSSI" != y ] &amp;&amp; REQUIRED_PROGRAMS="$REQUIRED_PROGRAMS irssi" fi } verifyInstalledPrograms() { getRequiredPrograms local MISSING_PROGRAMS= for prog in $REQUIRED_PROGRAMS; do local name=$prog [ "$prog" = svn ] &amp;&amp; name=subversion isProgramInstalled "$prog" || MISSING_PROGRAMS="$MISSING_PROGRAMS $name" done [ -n "$MISSING_PROGRAMS" ] &amp;&amp; errorExit "Can&#39;t continue. The following programs are not installed: $MISSING_PROGRAMS" } initPluginDirVar() { AUTODL_IRSSI_PLUGIN_DIR="$RUTORRENT_BASE_PATH/plugins/autodl-irssi" } getRtorrentDirs() { local user="$1" getUserDir "$user" RTORRENT_DOWNLOAD_DIR="$userDir/$RTORRENT_REL_DOWNLOAD_DIR" RTORRENT_WATCH_DIR="$userDir/$RTORRENT_REL_WATCH_DIR" RTORRENT_SESSION_DIR="$userDir/$RTORRENT_REL_SESSION_DIR" } getUserScgiSocketPath() { local user="$1" getRtorrentDirs "$user" scgiSocketPath="$RTORRENT_SESSION_DIR/rpc.socket" } waitenter() { local msg="${1-Press ENTER to continue...}" echo -n "$CCYAN$msg$CEND" read dummy } askQuestion() { local question="$1" local default="$2" if [ -z "$default" ]; then echo -n "$CQUESTION$question$CEND " read answer else echo -n "$CQUESTION$question$CEND [$CGREEN$default$CEND] " read answer fi if [ -z "$answer" ]; then answer="$default" fi } # Asks the user a question, and sets answer to y or n depending on the user&#39;s answer askYesNo() { local question="$1" local default="$2" while true; do askQuestion "$question" "$default" if echo "$answer" | grep -qiE &#39;^y(es)?$&#39;; then answer=y return 1 elif echo "$answer" | grep -qiE &#39;^no?$&#39;; then answer=n return 0 fi done } askOsUser() { local stopIfEmpty=${1:-n} local user= while true; do askQuestion "Enter name of user:" "" user="$answer" [ -z "$user" ] &amp;&amp; [ "$stopIfEmpty" = y ] &amp;&amp; break userExists "$user" &amp;&amp; break echo "${CWARNING}User $user does not exist.$CEND" askYesNo "Do you want to create user $user?" "No" [ "$answer" = n ] &amp;&amp; continue echo "${CMSG}Creating user $user.$CEND" if ! useradd -m -s /bin/sh "$user"; then echo "${CWARNING}Could not create user $user.$CEND" continue fi echo "${CMSG}Enter the user&#39;s password:$CEND" if ! passwd "$user"; then echo "${CWARNING}Failed to set password.$CEND" continue fi userExists "$user" &amp;&amp; break done answer="$user" } # Adds another user to USERS addUser() { local osUser="$1" local webUser="$2" local autodlPassword= local webpass= if [ "$INSTALL_RUTORRENT" = y ] || [ "$USE_RUTORRENT_PLUGIN" = y ]; then if ! canGeneratePasswords; then cat &lt;&lt; EOF $CQUESTION The password makes sure only you can change your autodl-irssi settings. This is NOT your login password. Use any password, but each user should use a unique password. The password is used by the PHP code to access autodl-irssi settings. You don&#39;t need to remember this password. It can&#39;t contain any spaces or a colon &#39;:&#39;.$CEND EOF while true; do askQuestion "Enter the autodl-irssi password (this is not your login password):" "" autodlPassword="$answer" isValidPassword "$autodlPassword" &amp;&amp; break echo "${CWARNING}Invalid password. Try again.$CEND" done fi if [ "$RUTORRENT_PASSWORD_PROTECTED" = y ]; then while true; do askQuestion "Enter your ruTorrent password:" "" webpass="$answer" isValidPassword "$webpass" &amp;&amp; break echo "${CWARNING}Invalid password. Try again.$CEND" done fi USERS="$USERS $osUser:$autodlPassword:$webUser:$webpass" else USERS="$USERS $osUser" fi } installUser() { local userPluginDir="$1" local osUser="$2" local webUser="${3:-$osUser}" local port="$4" local autodlPassword="$5" getUserGroup "$osUser" getUserDir "$osUser" cat &lt;&lt; EOF ========================= ${CGREEN}Installing autodl-irssi$CEND ========================= Use the ruTorrent plugin: $CGREEN$USE_RUTORRENT_PLUGIN$CEND OS user: $CGREEN$osUser$CEND EOF if [ "$USE_RUTORRENT_PLUGIN" = y ]; then [ "$RUTORRENT_PASSWORD_PROTECTED" = y ] &amp;&amp; echo "ruTorrent user: $CGREEN$webUser$CEND" echo "port: $CGREEN$port$CEND" echo "password: $CGREEN$autodlPassword$CEND" fi cat &lt;&lt; EOF group: $CGREEN$group$CEND home: $CGREEN$userDir$CEND EOF if [ "$USE_RUTORRENT_PLUGIN" = y ]; then isValidPortNumber "$port" || errorExit "Invalid port number: $port" isValidPassword "$autodlPassword" || errorExit "Invalid password: $autodlPassword" isValidWebUser "$webUser" || errorExit "Invalid web user: $webUser" fi mkdir -p "$userDir/.irssi/scripts/autorun" cd "$userDir/.irssi/scripts" || errorExit "Could not CD into user dir. Run the script as root." echo "${CMSG}Downloading autodl-irssi.zip...$CEND" if ! downloadFile autodl-irssi.zip "$AUTODL_IRSSI_ZIP_URL"; then errorExit "Could not download autodl-irssi zip file" fi echo "${CMSG}Unpacking autodl-irssi...$CEND" unzip -o autodl-irssi.zip &gt; /dev/null || errorExit "Could not unpack autodl-irssi zip file" rm -f autodl-irssi.zip cp autodl-irssi.pl autorun/ || errorExit "Could not copy autodl-irssi.pl to Irssi autorun dir." mkdir -p "$userDir/.autodl" touch "$userDir/.autodl/autodl.cfg" if ! [ -s "$userDir/.autodl/autodl.cfg" ]; then [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; cat &gt; "$userDir/.autodl/autodl.cfg" &lt;&lt; EOF [options] upload-type = rtorrent EOF fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if [ ! -d "$AUTODL_IRSSI_PLUGIN_DIR" ]; then errorExit "The autodl-irssi ruTorrent plugin has not been installed. Install it." fi cat &gt; "$userDir/.autodl/autodl2.cfg" &lt;&lt; EOF [options] gui-server-port = $port gui-server-password = $autodlPassword EOF rm -f "$AUTODL_IRSSI_PLUGIN_DIR/conf.php" mkdir -p "$userPluginDir" cat &gt; "$userPluginDir/conf.php" &lt;&lt; EOF &lt;?php \$autodlPort = $port; \$autodlPassword = "$autodlPassword"; ?&gt; EOF [ $? -eq 0 ] || errorExit "Could not write to $userPluginDir/conf.php. Run this script as root." # Only set perms to 0400 if the code knows the owner (web server owner) and will reset it [ "$ISROOT" = y ] &amp;&amp; [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; chmod 0400 "$userPluginDir/conf.php" else # Don&#39;t use the autodl-irssi ruTorrent plugin : &gt; "$userDir/.autodl/autodl2.cfg" fi # The Perl module isn&#39;t loaded by default if [ "$IRSSI_LOAD_PERL" = y ]; then if [ ! -f "$userDir/.irssi/startup" ] || ! grep -q &#39;load perl&#39; "$userDir/.irssi/startup"; then echo "load perl" &gt;&gt; "$userDir/.irssi/startup" fi fi # Make sure we redownload the tracker files since the ones in the zip file are possibly # old versions. local autodlStateFile="$userDir/.autodl/AutodlState.xml" [ -f "$autodlStateFile" ] &amp;&amp; sed_i &#39;g/&lt;trackers-version&gt;/d&#39; "$autodlStateFile" resetOwner "$osUser" "$userDir/.autodl" "$userDir/.irssi" chmod 0700 "$userDir/.autodl" "$userDir/.irssi" } getRutorrentUserConfDir() { userConfDir="$RUTORRENT_BASE_PATH/conf/users/$webUser" } getRutorrentUserShareDir() { userShareDir="$RUTORRENT_BASE_PATH/share/users/$webUser" } resetRutorrentUserPermissions() { for packedUser in $USERS; do extractPackedUser $packedUser getRutorrentUserConfDir getRutorrentUserShareDir # Make sure only the web server and the user itself can access its share/conf dirs chown $osUser:$WWW_GROUP "$userShareDir" "$userConfDir" chmod 0770 "$userShareDir" "$userConfDir" done } ############################################################################ # # This is where we start # ############################################################################ SELINUX_ENABLED=n isProgramInstalled selinuxenabled &amp;&amp; selinuxenabled &amp;&amp; SELINUX_ENABLED=y echo "SELinux enabled: $SELINUX_ENABLED" ISROOT=n [ $(id -u) -eq 0 ] &amp;&amp; ISROOT=y echo "Is root user: $ISROOT" if [ $# -gt 0 ]; then parseCommandLine "$@" INTERACTIVE=n else INTERACTIVE=y fi detectOs cat &lt;&lt; EOF Detected OS: $CGREEN$os_long$CEND Type: $CGREEN$os$CEND Type sh $0 --help for all command line options. EOF osHandler_$os init if [ "$INTERACTIVE" = y ]; then if [ "$ISROOT" = n ]; then cat &lt;&lt; EOF $CRED You&#39;re not the root user! This install script may fail if you&#39;re not the root user. To start it as the root user do one of the following: Ubuntu and Ubuntu clones: ${CGREEN}sudo sh $0$CRED Any other OS: ${CGREEN}su sh $0$CRED $CEND EOF waitenter "Press Ctrl+C to exit or ENTER to continue..." fi cat &lt;&lt; EOF $CMSG Press ENTER to use the default answer in [brackets].$CEND EOF webServers= canInstallLighttpd &amp;&amp; webServers="$webServers lighttpd" canInstallNginx &amp;&amp; webServers="$webServers nginx" canInstallApache &amp;&amp; webServers="$webServers apache" if [ -n "$webServers" ]; then cat &lt;&lt; EOF $CQUESTION If you want to install ruTorrent you must install a web server, eg. Apache. If you&#39;ve already installed another web server, you must first uninstall it or disable it. List of supported web servers:$CEND EOF canInstallLighttpd &amp;&amp; echo " ${CGREEN}lighttpd$CEND ${CQUESTION}lighttpd web server (lightweight)$CEND" canInstallNginx &amp;&amp; echo " ${CGREEN}nginx$CEND ${CQUESTION}nginx web server (lightweight)$CEND" canInstallApache &amp;&amp; echo " ${CGREEN}apache$CEND ${CQUESTION}Apache web server$CEND" echo " ${CGREEN}none$CEND ${CQUESTION}Don&#39;t install a web server$CEND" while true; do INSTALL_WEB_SERVER= echo "${CQUESTION}Select one of:$CGREEN$webServers none$CEND" askQuestion "Enter name of web server" "$(getFirst $webServers)" [ "$answer" = none ] &amp;&amp; break INSTALL_WEB_SERVER="$answer" arrayIsPresent $INSTALL_WEB_SERVER $webServers &amp;&amp; break done if [ -n "$INSTALL_WEB_SERVER" ]; then askYesNo "Do you want to install ruTorrent?" "Yes" INSTALL_RUTORRENT="$answer" else INSTALL_RUTORRENT=n fi fi if canInstallRtorrent; then cat &lt;&lt; EOF $CQUESTION ruTorrent requires a working rtorrent built with XML-RPC support.$CEND EOF askYesNo "Do you want to build rtorrent?" "Yes" BUILD_RTORRENT="$answer" fi askYesNo "Do you want to install the autodl-irssi ruTorrent plugin?" "Yes" USE_RUTORRENT_PLUGIN="$answer" if [ "$INSTALL_RUTORRENT" = y ]; then REINSTALL_RUTORRENT_PLUGIN=n RUTORRENT_PASSWORD_PROTECTED=y elif [ "$USE_RUTORRENT_PLUGIN" = y ]; then echo "" while true; do echo "${CQUESTION}The ruTorrent www base path is where you installed ruTorrent.$CEND" askQuestion "What is the ruTorrent www base path, eg. /var/www/rutorrent:" "" RUTORRENT_BASE_PATH="$answer" isValidRutorrentBasePath "$RUTORRENT_BASE_PATH" &amp;&amp; break echo "$CWARNING$RUTORRENT_BASE_PATH is not the ruTorrent base path.$CEND" done initPluginDirVar if [ -d "$AUTODL_IRSSI_PLUGIN_DIR" ]; then echo "" askYesNo "The autodl-irssi ruTorrent plugin seems to be installed. Do you want to re-install it?" "No" REINSTALL_RUTORRENT_PLUGIN="$answer" else REINSTALL_RUTORRENT_PLUGIN=n fi cat &lt;&lt; EOF $CQUESTION To use more than one ruTorrent user, you must password protect ruTorrent.$CEND EOF askYesNo "Is ruTorrent password protected?" "No" RUTORRENT_PASSWORD_PROTECTED="$answer" else RUTORRENT_PASSWORD_PROTECTED=n fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then INSTALL_AUTODL_IRSSI=y else askYesNo "Do you want to install autodl-irssi?" "Yes" INSTALL_AUTODL_IRSSI="$answer" fi if canInstallService &amp;&amp; ([ "$INSTALL_AUTODL_IRSSI" = y ] || [ "$INSTALL_RUTORRENT" = y ]); then cat &lt;&lt; EOF $CQUESTION If you want to automatically start Irssi and rtorrent when the computer boots, install the startup script.$CEND EOF askYesNo "Do you want to install the startup script?" "Yes" INSTALL_STARTUP_SCRIPT="$answer" fi askUser=n if [ "$USE_RUTORRENT_PLUGIN" = y ] || [ "$INSTALL_AUTODL_IRSSI" = y ] || \ [ "$INSTALL_STARTUP_SCRIPT" = y ] || [ "$INSTALL_RUTORRENT" = y ]; then askUser=y fi if [ "$askUser" = y ]; then if [ "$RUTORRENT_PASSWORD_PROTECTED" = n ]; then cat &lt;&lt; EOF $CQUESTION This is the user running rtorrent and/or Irssi.$CEND ${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND EOF askOsUser addUser "$answer" "" else while true; do cat &lt;&lt; EOF $CQUESTION ===================== USER ===================== This is the user running rtorrent and/or Irssi. ${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND ${CCYAN}Press ENTER to stop adding users.$CEND EOF askOsUser y osUser="$answer" [ -z "$osUser" ] &amp;&amp; break while true; do cat &lt;&lt; EOF $CQUESTION The ruTorrent user is the name you use to log in to ruTorrent.$CEND EOF askQuestion "Enter ruTorrent user:" "$osUser" webUser="$answer" isValidWebUser "$webUser" &amp;&amp; break echo "${CWARNING}Invalid web user name &#39;$webUser&#39;. Use only lower case letters." done addUser "$osUser" "$webUser" done fi fi if canInstallVsftpd; then cat &lt;&lt; EOF $CQUESTION vsftpd is a very secure FTP daemon.$CEND EOF askYesNo "Do you want to install vsftpd?" "Yes" INSTALL_VSFTPD="$answer" if [ "$INSTALL_VSFTPD" = y ]; then askYesNo "Do you want to use encrypted FTP (FTPES)" "Yes" USE_ENCRYPTED_FTP="$answer" port=$DEFAULT_PORT_FTP [ "$USE_ENCRYPTED_FTP" = y ] &amp;&amp; port=$DEFAULT_PORT_FTPES askQuestion "Enter FTP port number" "$port" FTP_PORT="$answer" fi fi if canInstallWebmin; then cat &lt;&lt; EOF $CQUESTION Webmin is a web-based administration tool for your OS.$CEND EOF askYesNo "Do you want to install Webmin?" "Yes" INSTALL_WEBMIN="$answer" fi fi cmdline="sh $0" [ "$USE_RUTORRENT_PLUGIN" = y ] &amp;&amp; cmdline="$cmdline -p" [ "$REINSTALL_RUTORRENT_PLUGIN" = y ] &amp;&amp; cmdline="$cmdline -i" [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; cmdline="$cmdline -a" for user in $USERS; do cmdline="$cmdline -u $user"; done [ "$RUTORRENT_PASSWORD_PROTECTED" = y ] &amp;&amp; cmdline="$cmdline -w" [ -n "$RUTORRENT_BASE_PATH" ] &amp;&amp; cmdline="$cmdline -r &#39;$RUTORRENT_BASE_PATH&#39;" [ "$INSTALL_STARTUP_SCRIPT" = y ] &amp;&amp; cmdline="$cmdline -s" if [ -z "$INSTALL_WEB_SERVER" ]; then : elif [ "$INSTALL_WEB_SERVER" = apache ]; then cmdline="$cmdline --apache" elif [ "$INSTALL_WEB_SERVER" = nginx ]; then cmdline="$cmdline --nginx" elif [ "$INSTALL_WEB_SERVER" = lighttpd ]; then cmdline="$cmdline --lighttpd" else errorExit "Invalid web server: $INSTALL_WEB_SERVER" fi [ "$BUILD_RTORRENT" = y ] &amp;&amp; cmdline="$cmdline --rtorrent" [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; cmdline="$cmdline --rutorrent" [ "$INSTALL_VSFTPD" = y ] &amp;&amp; cmdline="$cmdline --vsftpd" [ -n "$FTP_PORT" ] &amp;&amp; cmdline="$cmdline --ftp-port $FTP_PORT" [ "$USE_ENCRYPTED_FTP" = y ] &amp;&amp; cmdline="$cmdline --ftpes" [ "$INSTALL_WEBMIN" = y ] &amp;&amp; cmdline="$cmdline --webmin" cat &lt;&lt; EOF You can execute this command as the root user (Ubuntu: use ${CRED}sudo$CEND): $CGREEN$cmdline$CEND Use the autodl-irssi ruTorrent plugin: $USE_RUTORRENT_PLUGIN Re-install the autodl-irssi ruTorrent plugin: $REINSTALL_RUTORRENT_PLUGIN Install autodl-irssi: $INSTALL_AUTODL_IRSSI Users: $USERS ruTorrent is password protected: $RUTORRENT_PASSWORD_PROTECTED ruTorrent base path: $RUTORRENT_BASE_PATH Install startup script: $INSTALL_STARTUP_SCRIPT Install web server: $INSTALL_WEB_SERVER Build rtorrent: $BUILD_RTORRENT Install ruTorrent: $INSTALL_RUTORRENT Install vsftpd: $INSTALL_VSFTPD FTP port: $FTP_PORT Use FTPES: $USE_ENCRYPTED_FTP Install Webmin: $INSTALL_WEBMIN EOF if [ -n "$INSTALL_WEB_SERVER" ]; then for port in $HTTP_PORT $HTTPS_PORT; do isPortUsed $port || continue cat &lt;&lt; EOF $CWARNING Port $port is in use. If it&#39;s not used by $INSTALL_WEB_SERVER, you may need to disable or uninstall that other web server before continuing.$CEND EOF done fi if [ "$INTERACTIVE" = y ]; then echo "" waitenter "Press Ctrl+C to cancel or ENTER to install." fi osHandler_$os init2 initUsers initPluginDirVar [ -n "$INSTALL_WEB_SERVER" ] || [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; RUTORRENT_PASSWORD_PROTECTED=y [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; [ -z "$INSTALL_WEB_SERVER" ] &amp;&amp; errorExit "You must install a web server if you want to install ruTorrent, eg. use --apache --rutorrent" [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; REINSTALL_RUTORRENT_PLUGIN=n [ "$BUILD_RTORRENT" = y ] &amp;&amp; ! canInstallRtorrent &amp;&amp; errorExit "Can&#39;t build rtorrent." [ "$INSTALL_STARTUP_SCRIPT" = y ] &amp;&amp; ! canInstallService &amp;&amp; errorExit "Can&#39;t install startup script." [ "$INSTALL_VSFTPD" = y ] &amp;&amp; ! canInstallVsftpd &amp;&amp; errorExit "Can&#39;t install vsftpd." [ "$INSTALL_WEBMIN" = y ] &amp;&amp; ! canInstallWebmin &amp;&amp; errorExit "Can&#39;t install webmin." if [ -z "$INSTALL_WEB_SERVER" ]; then : elif [ "$INSTALL_WEB_SERVER" = apache ]; then canInstallApache || errorExit "Can&#39;t install Apache." elif [ "$INSTALL_WEB_SERVER" = nginx ]; then canInstallNginx || errorExit "Can&#39;t install nginx." elif [ "$INSTALL_WEB_SERVER" = lighttpd ]; then canInstallLighttpd || errorExit "Can&#39;t install lighttpd." else errorExit "Invalid web server: $INSTALL_WEB_SERVER" fi [ -n "$FTP_PORT" ] &amp;&amp; [ "$FTP_PORT" -lt 1 -o "$FTP_PORT" -gt 65535 ] &amp;&amp; errorExit "Invalid FTP port: $FTP_PORT" if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if [ -z "$INSTALL_WEB_SERVER" ] &amp;&amp; ! isValidRutorrentBasePath "$RUTORRENT_BASE_PATH"; then errorExit "$RUTORRENT_BASE_PATH is not a valid ruTorrent base path." fi fi if [ "$INSTALL_AUTODL_IRSSI" = y ]; then cat &lt;&lt; EOF ${CMSG}Installing required tools and Perl modules... Some Perl modules may not be present, but will be installed from CPAN.$CEND EOF else echo "${CMSG}Installing required tools...$CEND" fi osHandler_$os installTools setSvnOpts [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; osHandler_$os installAutodlTools verifyInstalledPrograms [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; installMissingPerlModules cat &lt;&lt; EOF $CMSG All required programs and Perl modules are now installed. Ignore any errors you saw.$CEND EOF INSTALLED_RTORRENT=n if [ "$BUILD_RTORRENT" = y ]; then cat &lt;&lt; EOF $CMSG Building rtorrent and dependencies...$CEND EOF installRtorrent INSTALLED_RTORRENT=y fi if [ -z "$INSTALL_WEB_SERVER" ]; then : elif [ "$INSTALL_WEB_SERVER" = apache ]; then echo "" echo "${CMSG}Installing Apache$CEND" osHandler_$os installApache installUnrar elif [ "$INSTALL_WEB_SERVER" = nginx ]; then echo "" echo "${CMSG}Installing nginx$CEND" installNginx elif [ "$INSTALL_WEB_SERVER" = lighttpd ]; then echo "" echo "${CMSG}Installing lighttpd$CEND" installLighttpd else errorExit "Invalid web server: $INSTALL_WEB_SERVER" fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if isProgramInstalled php; then installMissingPhpModules else cat &lt;&lt; EOF $CWARNING Could not find the php executable. PHP is not installed or the PHP CLI version is not installed. The autodl-irssi ruTorrent plugin requires the following PHP modules: $CGREEN$REQUIRED_PHP_MODULES$CWARNING They&#39;re normally installed and enabled by default. If not you will need to install them (if needed) and then enable each one in php.ini, eg. extension=MODULE.so and then restart your web server.$CEND EOF fi fi if [ "$INSTALL_RUTORRENT" = y ]; then isProgramInstalled php || errorExit "php is not installed!" verifyWebServerVars echo "" echo "${CMSG}Installing ruTorrent$CEND" [ -d "$WWW_ROOT" ] || errorExit "Invalid web root: &#39;$WWW_ROOT&#39; (does not exist)" RUTORRENT_DIRNAME=rutorrent [ -f "$WWW_ROOT/index.html" ] || cat &gt; "$WWW_ROOT/index.html" &lt;&lt; EOF &lt;html&gt;&lt;head&gt;&lt;title&gt;Root page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="$RUTORRENT_DIRNAME/"&gt;ruTorrent&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; EOF cd "$WWW_ROOT" rm -rf "$RUTORRENT_DIRNAME" tmpName=rutorrent-tmp rm -rf $tmpName if ! svn co $SVN_OPTS "$RUTORRENT_TRUNK_DIR" $tmpName &gt;/dev/null; then # Subversion failed. Try the official tar balls mkdir -p $tmpName cd $tmpName downloadFile "$RUTORRENT_CORE_NAME" "$RUTORRENT_CORE_URL" "$RUTORRENT_CORE_URL2" || errorExit "Could not download ruTorrent." downloadFile "$RUTORRENT_PLUGINS_NAME" "$RUTORRENT_PLUGINS_URL" "$RUTORRENT_PLUGINS_URL2" || errorExit "Could not download ruTorrent plugins." for name in "$RUTORRENT_CORE_NAME" "$RUTORRENT_PLUGINS_NAME"; do tar xzf "$name" || errorExit "Could not unpack $name" rm -f "$name" done cd .. fi cd $tmpName RUTORRENT_BASE_PATH="$WWW_ROOT/$RUTORRENT_DIRNAME" initPluginDirVar mv rutorrent/ "$RUTORRENT_BASE_PATH" mkdir -p "$RUTORRENT_BASE_PATH/plugins" for plugin in $RUTORRENT_PLUGINS; do if [ -d "plugins/$plugin/" ]; then echo "${CMSG}Installing ruTorrent plugin: $plugin$CEND..." mv plugins/$plugin/ "$RUTORRENT_BASE_PATH/plugins/" || errorExit "Could not install plugin &#39;$plugin&#39;." else echo "${CWARNING}Can&#39;t install missing plugin $plugin!$CEND" fi done cd .. rm -rf $tmpName cp "$RUTORRENT_BASE_PATH/favicon.ico" "$WWW_ROOT" i=1 touch "$WWW_PASSWORD_FILE" resetAuthPasswordFilePermissions detectHtpasswd for packedUser in $USERS; do extractPackedUser $packedUser getRutorrentUserConfDir getRutorrentUserShareDir getUserScgiSocketPath "$osUser" getRtorrentDirs "$osUser" # Create user&#39;s ruTorrent config.php rpcMount="$(getUserRpcMount $i)" mkdir -p "$userConfDir" rutConfigFile="$userConfDir/config.php" if [ "$SCGI_USE_UNIX_DOMAIN_SOCKET" = y ]; then cat &gt; "$rutConfigFile" &lt;&lt; EOF &lt;?php \$scgi_port = 0; \$scgi_host = "unix://$scgiSocketPath"; \$XMLRPCMountPoint = "$rpcMount"; ?&gt; EOF exitCode=$? else cat &gt; "$rutConfigFile" &lt;&lt; EOF &lt;?php \$scgi_port = $scgiPort; \$scgi_host = "$SCGI_HOST"; \$XMLRPCMountPoint = "$rpcMount"; ?&gt; EOF exitCode=$? fi [ $exitCode -eq 0 ] || errorExit "Could not write to file $rutConfigFile" # Create user&#39;s directory to prevent certain errors the first time ruTorrent is started mkdir -p "$userShareDir/settings" mkdir -p "$userShareDir/torrents" chmod 0777 "$userShareDir/settings" "$userShareDir/torrents" # Setup rtorrent mkdir -p "$RTORRENT_DOWNLOAD_DIR" mkdir -p "$RTORRENT_WATCH_DIR" mkdir -p "$RTORRENT_SESSION_DIR" rtorrentRc="$userDir/.rtorrent.rc" [ -f "$rtorrentRc" ] &amp;&amp; mv -f "$rtorrentRc" "$rtorrentRc-backup" cat &gt; "$rtorrentRc" &lt;&lt; EOF $(if [ "$SCGI_USE_UNIX_DOMAIN_SOCKET" = y ]; then cat &lt;&lt; EOF2 execute = {sh,-c,rm -f $scgiSocketPath} scgi_local = $scgiSocketPath execute = {sh,-c,chmod 0666 $scgiSocketPath} EOF2 else echo "scgi_port = $SCGI_HOST:$scgiPort" fi) encoding_list = UTF-8 system.umask.set = $DEFAULT_UMASK port_range = $rtorrentPort-$rtorrentPort port_random = no check_hash = no directory = $RTORRENT_DOWNLOAD_DIR session = $RTORRENT_SESSION_DIR encryption = allow_incoming, try_outgoing, enable_retry schedule = watch_directory,1,1,"load_start=$RTORRENT_WATCH_DIR/*.torrent" #schedule = untied_directory,5,5,"stop_untied=$RTORRENT_WATCH_DIR/*.torrent" trackers.enable = 1 #min_peers = 40 #max_peers = 100 #min_peers_seed = 10 #max_peers_seed = 50 #max_uploads = 15 #download_rate = 0 #upload_rate = 0 use_udp_trackers = yes dht = auto dht_port = 6881 peer_exchange = yes #hash_read_ahead = 10 #hash_interval = 100 #hash_max_tries = 10 EOF PHP_BIN_PATH=$(which php 2&gt; /dev/null) COMMENT= [ -x "$PHP_BIN_PATH" ] || COMMENT="#" PHP_BIN_PATH=/path/to/php cat &gt;&gt; "$rtorrentRc" &lt;&lt; EOF ${COMMENT}execute = {sh,-c,$PHP_BIN_PATH $RUTORRENT_BASE_PATH/php/initplugins.php $webUser &amp;} EOF # Add user to web server&#39;s password file sed_i "g/^$webUser:/d" "$WWW_PASSWORD_FILE" $htpasswd -b "$WWW_PASSWORD_FILE" "$webUser" "$webPass" || errorExit "Could not add user to password file" resetAuthPasswordFilePermissions resetOwner "$osUser" "$rtorrentRc" "$userDir" "$RTORRENT_DOWNLOAD_DIR" "$RTORRENT_WATCH_DIR" "$RTORRENT_SESSION_DIR" # Required so some ruTorrent plugins work, eg. _getdir chmod 0755 "$userDir" # Protect some dirs and files, giving only the user and the web server # access. We need to do this since we set perms to 0755 above, or if # the perms already were 0755 to begin with. if [ -n "$WWW_GROUP" ]; then chmod 0600 "$rtorrentRc" for dir in $RTORRENT_REL_DOWNLOAD_DIR $RTORRENT_REL_WATCH_DIR $RTORRENT_REL_SESSION_DIR; do chown $osUser:$WWW_GROUP "$userDir/$dir" chmod 0770 "$userDir/$dir" done fi i=$(expr $i + 1) done [ "$CREATE_ONE_PASSWORD_FILE_PER_USER" = y ] &amp;&amp; createOnePasswordFilePerUser fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then [ -z "$RUTORRENT_BASE_PATH" ] &amp;&amp; errorExit "Invalid ruTorrent base path." [ "$REINSTALL_RUTORRENT_PLUGIN" = y ] &amp;&amp; rm -rf "$AUTODL_IRSSI_PLUGIN_DIR" mkdir -p "$RUTORRENT_BASE_PATH/plugins" cd "$RUTORRENT_BASE_PATH/plugins" if [ -d "$AUTODL_IRSSI_PLUGIN_DIR" ]; then echo "${CMSG}The autodl-irssi ruTorrent plugin dir already exists. Updating it...$CEND" cd "$AUTODL_IRSSI_PLUGIN_DIR" if ! svn up $SVN_OPTS &gt; /dev/null; then errorExit "Could not update the autodl-irssi ruTorrent plugin. Run the script as root." fi else echo "${CMSG}Downloading the autodl-irssi ruTorrent plugin...$CEND" if ! git clone "$GIT_PATH_RUTORRENT_PLUGIN" autodl-irssi &gt; /dev/null; then errorExit "Could not check out the autodl-irssi ruTorrent plugin" fi fi fi if [ "$INSTALL_AUTODL_IRSSI" = y ]; then if [ "$RUTORRENT_PASSWORD_PROTECTED" = y ]; then for packedUser in $USERS; do extractPackedUser $packedUser installUser "$RUTORRENT_BASE_PATH/conf/users/$webUser/plugins/autodl-irssi" "$osUser" "$webUser" "$autodlPort" "$autodlPassword" done else for packedUser in $USERS; do extractPackedUser $packedUser installUser "$AUTODL_IRSSI_PLUGIN_DIR" "$osUser" "$webUser" "$autodlPort" "$autodlPassword" [ "$USE_RUTORRENT_PLUGIN" = y ] &amp;&amp; break done fi fi if [ "$INSTALL_RUTORRENT" = y ]; then verifyWebServerVars resetWebServerPermissions resetRutorrentUserPermissions # Restart it just in case we enabled/installed PHP modules. osHandler_$os restart_$INSTALL_WEB_SERVER fi if [ "$INSTALL_VSFTPD" = y ]; then echo "${CMSG}Installing vsftpd...$CEND" osHandler_$os installVsftpd fi if [ "$INSTALL_WEBMIN" = y ]; then cd rm -rf webmin-*/ webmin*.tar.gz if ! downloadFile webmin.tar.gz "$WEBMIN_URL"; then errorExit "Could not download Webmin." fi tar xzf webmin.tar.gz rm -f webmin.tar.gz cd webmin-*/ || errorExit "Could not CD to webmin dir" osHandler_$os preWebminInstall [ -x "setup.sh" ] || errorExit "Missing Webmin setup.sh file or not executable." cat &lt;&lt; EOF $CMSG Starting Webmin installer. Use another port than 10000, enable SSL, start webmin at boot, and use a strong admin password.$CEND $CWARNING When it asks you if it should use SSL and whether it should start at boot, type y.$CEND EOF ./setup.sh /usr/local/webmin osHandler_$os postWebminInstall cd rm -rf webmin-*/ fi if [ "$INSTALL_RUTORRENT" = y ]; then # Some plugins will fail unless they can write to the /tmp directory # We MUST do this AFTER installing Webmin since it will reset the perms! chmod 1777 /tmp fi if [ "$INSTALL_STARTUP_SCRIPT" = y ]; then for packedUser in $USERS; do extractPackedUser $packedUser echo "${CMSG}Installing service for user $osUser.$CEND" osHandler_$os installAutodlService $osUser done fi echo "" echo "${CGREEN}================================= DONE =================================$CEND" [ "$INSTALLED_RTORRENT" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Built and installed rtorrent with XML-RPC support$CEND" [ -n "$INSTALL_WEB_SERVER" ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed and configured web server ($INSTALL_WEB_SERVER)$CEND" [ "$INSTALL_VSFTPD" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed and configured FTP server (vsftpd)$CEND" [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed ruTorrent$CEND" [ "$USE_RUTORRENT_PLUGIN" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed/updated the autodl-irssi ruTorrent plugin$CEND" [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed autodl-irssi$CEND" [ "$INSTALL_STARTUP_SCRIPT" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed and started Irssi and rtorrent service$CEND" [ "$INSTALL_WEBMIN" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed Webmin$CEND" if [ "$INSTALL_RUTORRENT" = y ]; then getIpAddress cat &lt;&lt; EOF ${CMSG}ruTorrent URLs.$CEND ${CWARNING}Verify that the IP address below is correct!$CEND ${CMAGENTA}http://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND ${CMAGENTA}https://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND EOF fi if [ "$INSTALL_RUTORRENT" = y ]; then cat &lt;&lt; EOF ${CMSG}rtorrent directories$CEND: EOF for packedUser in $USERS; do extractPackedUser $packedUser getRtorrentDirs "$osUser" cat &lt;&lt; EOF ${CMSG}User $CGREEN$osUser$CEND: ${CGREEN}Downloads$CEND : $CMAGENTA$RTORRENT_DOWNLOAD_DIR$CEND ${CGREEN}Watch dir$CEND : $CMAGENTA$RTORRENT_WATCH_DIR$CEND ${CGREEN}Session dir$CEND : $CMAGENTA$RTORRENT_SESSION_DIR$CEND ${CGREEN}rtorrent port$CEND: $CMAGENTA$rtorrentPort$CEND EOF done fi if [ -n "$INSTALL_WEB_SERVER" ]; then cat &lt;&lt; EOF ${CMSG}Web server info$CEND: ${CGREEN}Web server root$CEND: ${CMAGENTA}$WWW_ROOT$CEND ${CGREEN}ruTorrent dir$CEND : ${CMAGENTA}$RUTORRENT_BASE_PATH$CEND EOF fi if [ "$INSTALL_VSFTPD" = y ]; then getIpAddress cat &lt;&lt; EOF $CMSG To log in to the FTP server, use your $(uname -s) login name and password. I guessed the IP address below. Make sure it&#39;s correct.$CEND ${CGREEN}FTP IP address$CEND: ${CMAGENTA}$OUR_IP_ADDRESS$CEND ${CGREEN}FTP port$CEND: ${CMAGENTA}$FTP_PORT$CEND ${CGREEN}FTP server type$CEND: $CMAGENTA$FTP_SERVER_TYPE$CEND EOF fi if [ "$INSTALL_WEBMIN" = y ]; then getIpAddress WEBMIN_PORT= WEBMIN_SSL= WEBMIN_NAME= WEBMIN_CONFIG=/etc/webmin/miniserv.conf WEBMIN_USERS=/etc/webmin/miniserv.users if [ -f $WEBMIN_CONFIG ]; then WEBMIN_PORT=$(grep &#39;^port=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^port=\([0-9]*\).*/\1/&#39;) WEBMIN_SSL=$(grep &#39;^ssl=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^ssl=\([0-9]*\).*/\1/&#39;) WEBMIN_NAME=$(head -n1 $WEBMIN_USERS | cut -d: -f1) fi WEBMIN_PORT=${WEBMIN_PORT:-UNKNOWN} WEBMIN_NAME=${WEBMIN_NAME:-UNKNOWN} cat &lt;&lt; EOF $CMSG Webmin was installed. Port is $WEBMIN_PORT and the user is $WEBMIN_NAME. ${CRED}Verify the IP address below.$CEND EOF if [ -z "$WEBMIN_SSL" ]; then echo " ${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" echo "${CMSG}or:$CEND" echo " ${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" elif [ "$WEBMIN_SSL" = 0 ]; then echo " ${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" else echo " ${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" fi fi if [ -n "$INSTALL_WEB_SERVER" ] || [ "$INSTALL_VSFTPD" = y ] || \ [ "$INSTALL_RUTORRENT" = y ] || [ "$USE_RUTORRENT_PLUGIN" = y ]; then if [ "$SELINUX_ENABLED" = y ]; then cat &lt;&lt; EOF $CWARNING SELinux is enabled. It could cause some problems with the web server, vsftpd or ruTorrent. EOF fi fi if [ "$CREATED_CERT_FILE" = y ]; then cat &lt;&lt; EOF $CWARNING A self-signed certificate was created. Your browser or FTP client will most likely warn you about a non-trusted certificate.$CEND EOF fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if isProgramInstalled php; then detectMissingPhpModules if [ -n "$MISSING_PHP_MODULES" ]; then cat &lt;&lt; EOF $CWARNING The following PHP modules seem to be missing. It&#39;s possible that the autodl-irssi ruTorrent plugin won&#39;t work. Missing PHP modules: $MISSING_PHP_MODULES$CEND EOF fi else cat &lt;&lt; EOF $CWARNING Could not find the php executable. Make sure the following PHP modules are enabled or the autodl-irssi ruTorrent plugin won&#39;t work: $REQUIRED_PHP_MODULES$CEND EOF fi fi'
    />
    <meta
      property="og:description"
      content='#!/bin/sh # ***** BEGIN LICENSE BLOCK ***** # Version: MPL 1.1 # # The contents of this file are subject to the Mozilla Public License Version # 1.1 (the "License"); you may not use this file except in compliance with # the License. You may obtain a copy of the License at # http://www.mozilla.org/MPL/ # # Software distributed under the License is distributed on an "AS IS" basis, # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License # for the specific language governing rights and limitations under the # License. # # The Original Code is IRC Auto Downloader # # The Initial Developer of the Original Code is # David Nilsson. # Portions created by the Initial Developer are Copyright (C) 2010, 2011 # the Initial Developer. All Rights Reserved. # # Contributor(s): # # ***** END LICENSE BLOCK ***** AUTODL_IRSSI_ZIP_URL="http://update.autodl-community.com/autodl-irssi-community.zip" GIT_PATH_RUTORRENT_PLUGIN="https://github.com/autodl-community/autodl-rutorrent.git" WEBMIN_URL="http://www.webmin.com/download/webmin-current.tar.gz" RUTORRENT_TRUNK_DIR="https://rutorrent.googlecode.com/svn/trunk" # The official tarballs are tried if subversion fails. RUTORRENT_VERSION="3.6" RUTORRENT_CORE_NAME="rutorrent-$RUTORRENT_VERSION.tar.gz" RUTORRENT_CORE_URL="http://dl.bintray.com/novik65/generic/$RUTORRENT_CORE_NAME" #RUTORRENT_CORE_URL="http://rutorrent.googlecode.com/files/$RUTORRENT_CORE_NAME" RUTORRENT_PLUGINS_NAME="plugins-$RUTORRENT_VERSION.tar.gz" #RUTORRENT_PLUGINS_URL="http://rutorrent.googlecode.com/files/$RUTORRENT_PLUGINS_NAME" RUTORRENT_PLUGINS_URL="http://dl.bintray.com/novik65/generic/$RUTORRENT_PLUGINS_NAME" #RUTORRENT_CORE_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_CORE_NAME/download" #RUTORRENT_PLUGINS_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_PLUGINS_NAME/download" RUTORRENT_PLUGINS= # These are the ruTorrent plugins that will get installed. To remove one, either # remove the whole line or comment it (prepend a &#39;#&#39; to the start of the line). # If the line starts with &#39;#&#39;, the plugin is not installed. RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS _getdir" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS _task" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS autotools" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS chunks" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS cookies" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS cpuload" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS create" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS data" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS datadir" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS diskspace" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS edit" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS erasedata" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS extsearch" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS feeds" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS geoip" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS httprpc" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS ipad" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS loginmgr" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS logoff" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS mediainfo" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS ratio" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS retrackers" #RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS rpc" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS rss" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS rssurlrewrite" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS scheduler" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS seedingtime" #RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS show_peers_like_wtorrent" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS source" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS theme" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS throttle" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS tracklabels" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS trafic" RUTORRENT_PLUGINS="$RUTORRENT_PLUGINS unpack" # For building rtorrent LIBCURL_NAME="curl-7.36.0" LIBCURL_URL="http://curl.haxx.se/download/$LIBCURL_NAME.tar.gz" SIGCPP20_NAME="libsigc++-2.3.1" SIGCPP20_URL="http://ftp.gnome.org/pub/GNOME/sources/libsigc++/2.3/$SIGCPP20_NAME.tar.gz" XMLRPC_SVN_DIR="https://svn.code.sf.net/p/xmlrpc-c/code/stable" LIBTORRENT_VERSION="0.13.4" LIBTORRENT_NAME="libtorrent-$LIBTORRENT_VERSION" LIBTORRENT_URL="http://libtorrent.rakshasa.no/downloads/$LIBTORRENT_NAME.tar.gz" LIBTORRENT_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$LIBTORRENT_NAME.tar.gz/download" RTORRENT_VERSION="0.9.4" RTORRENT_NAME="rtorrent-$RTORRENT_VERSION" RTORRENT_URL="http://libtorrent.rakshasa.no/downloads/$RTORRENT_NAME.tar.gz" RTORRENT_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RTORRENT_NAME.tar.gz/download" HTPASSWD_PY_SCRIPT_URL="http://trac.edgewall.org/export/10433/trunk/contrib/htpasswd.py" HTPASSWD_PY_SCRIPT_URL2="http://sourceforge.net/projects/autodl-irssi/files/inst-files/htpasswd.py/download" NGINX_NAME="nginx-1.7.0" NGINX_URL="http://nginx.org/download/$NGINX_NAME.tar.gz" LIGHTTPD_NAME="lighttpd-1.4.35" LIGHTTPD_URL="http://download.lighttpd.net/lighttpd/releases-1.4.x/$LIGHTTPD_NAME.tar.gz" MOD_SCGI_VERSION="1.14" MOD_SCGI_URL="http://python.ca/scgi/releases/scgi-$MOD_SCGI_VERSION.tar.gz" UNRAR_VERSION="4.0.7" UNRAR_URL="http://www.rarlab.com/rar/unrarsrc-$UNRAR_VERSION.tar.gz" # Dirs relative to user&#39;s home directory RTORRENT_REL_DOWNLOAD_DIR="downloads" RTORRENT_REL_WATCH_DIR="rtorrent/watch" RTORRENT_REL_SESSION_DIR="rtorrent/session" REQUIRED_PERL_MODULES="Time::HiRes XML::LibXML Archive::Zip Net::SSLeay HTML::Parser Digest::SHA1 JSON" REQUIRED_PHP_MODULES="json xml sockets" # If set to y, add &#39;load perl&#39; to .irssi/startup IRSSI_LOAD_PERL=n IGNORE_IRSSI=n # Start port. When we need a new port number, this port is incremented by one. CURRENT_PORT=23875 DEFAULT_PORT_FTP=21 DEFAULT_PORT_FTPES=990 DEFAULT_UMASK=022 RPC_PREFIX=RPC LSB_DEFAULT_START="2 3 4 5" LSB_DEFAULT_STOP="0 1 6" # Setting these to anything other than 80 and 443 may not work with Apache (since the # code assumed it would always be 80 and 443). HTTP_PORT=80 HTTPS_PORT=443 SCGI_HOST="127.0.0.1" INTERACTIVE=n USE_RUTORRENT_PLUGIN=n REINSTALL_RUTORRENT_PLUGIN=n INSTALL_AUTODL_IRSSI=n RUTORRENT_PASSWORD_PROTECTED=n USERS= RUTORRENT_BASE_PATH= INSTALL_STARTUP_SCRIPT=n BUILD_RTORRENT=n INSTALL_WEB_SERVER= INSTALL_RUTORRENT=n INSTALL_VSFTPD=n FTP_PORT= USE_ENCRYPTED_FTP=n INSTALL_WEBMIN=n USER_TIMEZONE= RUTORRENT_SITE_REALM="My ruTorrent web site" AUTODL_STARTUP_DESC="Start autodl-irssi and rtorrent" PHPCGI_STARTUP_DESC="Start php-cgi" NGINX_STARTUP_DESC="Start nginx" LIGHTTPD_STARTUP_DESC="Start lighttpd" PATH="$PATH:/usr/local/bin" # Find an echo that supports -e echo=echo for cmd in echo /bin/echo; do $cmd &gt;/dev/null 2&gt;&amp;1 || continue if ! $cmd -e "" | grep -qE &#39;^-e&#39;; then echo=$cmd break fi done CSI=$($echo -e "\033[") CEND="${CSI}0m" CDGREEN="${CSI}32m" CRED="${CSI}1;31m" CGREEN="${CSI}1;32m" CYELLOW="${CSI}1;33m" CBLUE="${CSI}1;34m" CMAGENTA="${CSI}1;35m" CCYAN="${CSI}1;36m" CQUESTION="$CMAGENTA" CWARNING="$CRED" CMSG="$CCYAN" errorExit() { cat &lt;&lt; EOF $CWARNING ***ERROR*** $* ***ERROR*** $CEND Help channel: ${CGREEN}#autodl-community@irc.p2p-network.net$CEND EOF exit 1 } exitHelp() { cat &lt;&lt; EOF autodl-irssi and ruTorrent plugin installer sh $0 [options] Options: --rtorrent Will build and install rtorrent, libtorrent and xmlrpc-c from source code. --rtorrent-noexec-patch Patch rtorrent to disallow remote users from executing code. --apache Install Apache web server. --nginx Install nginx web server. --lighttpd Install lighttpd web server. --rutorrent Install ruTorrent. Requires a web server, eg. --apache. --vsftpd Install vsftpd. --ftpes Use encrypted FTP (FTPES). --ftp-port &lt;port&gt; FTP server port. --webmin Install Webmin. -p --rutorrent-plugin Use or install the autodl-irssi ruTorrent plugin. If it&#39;s already installed, it will be updated (svn up), unless --reinstall-plugin option is used in which case it will be re-installed. -i --reinstall-plugin Re-install the autodl-irssi ruTorrent plugin if it&#39;s already installed. -a --install-autodl Install autodl-irssi. -u user:autodlPass:webUser:webPass --user user:autodlPass:webUser:webPass The $(uname -s) user, autodl-irssi password, ruTorrent user, ruTorrent password. You can use more than one -u option. If autodlPassword is not set, a random password will be used. -w --password-protected Use this option if ruTorrent is password protected. It&#39;s required if you want to use more than one ruTorrent user. Not needed if you install ruTorrent. -r PATH --rutorrent-base-path PATH Path to ruTorrent, eg. /var/www/rutorrent. Not needed if you install ruTorrent. -s --install-startup-script Install a startup script (service) which will start Irssi and rtorrent when the computer boots. -h --help Show this help text Examples (as root user): sh $0 --rtorrent --apache --rutorrent --vsftpd --ftpes --webmin -p -a -s -u user1::user1:pass1 -u user2::user2:pass2 Installs rtorrent, Apache, ruTorrent, vsftpd (encrypted), Webmin the autodl-irssi plugin, autodl-irssi, installs a service (starting Irssi and rtorrent) for both users. sh $0 -p -a -u user::user:pass -r /var/www/rutorrent -s Installs autodl-irssi + ruTorrent plugin for user &#39;user&#39;. ruTorrent has not been password protected. Also installs the startup script. sh $0 -p -a -u user1::user1:pass1 -u user2::user2:pass2 -w -r /var/www/rutorrent -s Installs autodl-irssi + ruTorrent plugin for users &#39;user1&#39; and &#39;user2&#39;. ruTorrent has been password protected. Also installs the startup script. sh $0 --rtorrent -a -u user1 -u user2 -u user3 -u user4 -s Installs rtorrent, autodl-irssi and the startup script. Help fchannel: #autodl-community@irc.p2p-network.net EOF exit 1 } parseCommandLine() { while [ $# -gt 0 ]; do local arg="$1" shift if [ "$arg" = "-p" ] || [ "$arg" = "--rutorrent-plugin" ]; then USE_RUTORRENT_PLUGIN=y elif [ "$arg" = "-i" ] || [ "$arg" = "--reinstall-plugin" ]; then REINSTALL_RUTORRENT_PLUGIN=y elif [ "$arg" = "-a" ] || [ "$arg" = "--install-autodl" ]; then INSTALL_AUTODL_IRSSI=y elif [ "$arg" = "-u" ] || [ "$arg" = "--user" ]; then USERS="$USERS $1" shift elif [ "$arg" = "-w" ] || [ "$arg" = "--password-protected" ]; then RUTORRENT_PASSWORD_PROTECTED=y elif [ "$arg" = "-r" ] || [ "$arg" = "--rutorrent-base-path" ]; then RUTORRENT_BASE_PATH="$1" shift elif [ "$arg" = "-s" ] || [ "$arg" = "--install-startup-script" ]; then INSTALL_STARTUP_SCRIPT=y elif [ "$arg" = "--rtorrent" ]; then BUILD_RTORRENT=y elif [ "$arg" = "--apache" ]; then INSTALL_WEB_SERVER=apache elif [ "$arg" = "--nginx" ]; then INSTALL_WEB_SERVER=nginx elif [ "$arg" = "--lighttpd" ]; then INSTALL_WEB_SERVER=lighttpd elif [ "$arg" = "--rutorrent" ]; then INSTALL_RUTORRENT=y elif [ "$arg" = "--vsftpd" ]; then INSTALL_VSFTPD=y elif [ "$arg" = "--ftpes" ]; then USE_ENCRYPTED_FTP=y elif [ "$arg" = "--ftp-port" ]; then FTP_PORT="$1" shift elif [ "$arg" = "--webmin" ]; then INSTALL_WEBMIN=y else exitHelp fi done } # Sets os and os_long to the OS type and OS name respectively detectOs() { local DISTRIB_ID= local DISTRIB_DESCRIPTION= if [ -f /etc/lsb-release ]; then . /etc/lsb-release fi if [ -f /etc/fedora-release ]; then os=fedora os_long="$(cat /etc/fedora-release)" # Must be before a whole bunch of other OS tests elif [ "$DISTRIB_ID" = "Ubuntu" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" elif [ "$DISTRIB_ID" = "LinuxMint" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" # Must be before Debian elif [ "$DISTRIB_ID" = "Peppermint" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" elif [ "$DISTRIB_ID" = "MEPIS" ]; then os=debian os_long="$DISTRIB_DESCRIPTION" elif [ -f /etc/clearos-release ]; then os=fedora os_long="$(cat /etc/clearos-release)" elif [ -f /etc/debian_version ]; then os=debian local prefix= if ! uname -s | grep -q GNU; then prefix="GNU/" fi os_long="Debian $prefix$(uname -s) $(cat /etc/debian_version)" elif [ -f /etc/redhat-release ]; then os=fedora os_long="$(cat /etc/redhat-release)" else echo -e "\e[1;31mYour OS is not detected as an OS supported by this script. This script only supports \e[5;32mDebian and Fedora\e[0m \e[1;31mbased OSes.\e[0m" exit 1 fi os_long="${os_long:-$(uname -s)}" } # In-place editing like sed -i but more portable... sed_i() { local cmd="$1" local file="$2" isProgramInstalled ed || errorExit "ed is not installed!" local addr="," echo "$cmd" | grep -qE &#39;^/&#39; &amp;&amp; addr= ed -s "$file" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF $addr$cmd w q EOF } getFirst() { echo $1 } # Returns true if $1 is one of $2..$n arrayIsPresent() { local val="$1" shift for v in "$@"; do [ "$v" = "$val" ] &amp;&amp; return 0 done return 1 } canGeneratePasswords() { [ -c /dev/urandom ] } generatePassword() { newPassword=$(cat /dev/urandom | tr -dc _A-Z-a-z-0-9 | head -c17) } isProgramInstalled() { which "$1" &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } isPerlModuleInstalled() { perl -M$1 -e &#39;&#39; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } # Add $1 or $2 if it exists, to PACKAGES if program $1 isn&#39;t present addProgram() { isProgramInstalled $1 || PACKAGES="$PACKAGES ${2:-$1}" } # Add $2 to PACKAGES if perl module $1 isn&#39;t present addPerlModule() { isPerlModuleInstalled $1 || PACKAGES="$PACKAGES $2" } installPackages() { [ -z "$INSTALL" ] &amp;&amp; return [ -z "$PACKAGES" ] &amp;&amp; return $INSTALL $PACKAGES PACKAGES= } installPerlModule() { isPerlModuleInstalled $1 || $INSTALL $2 } installProgram() { isProgramInstalled $1 || $INSTALL ${2:-$1} } installBuildTools() { [ "$BUILD_TOOLS_INSTALLED" = y ] &amp;&amp; return PACKAGES="$BUILD_TOOLS" installPackages BUILD_TOOLS_INSTALLED=y } # Detects missing Perl modules and stores them in MISSING_PERL_MODULES detectMissingPerlModules() { OLD_PERL_MODULES= MISSING_PERL_MODULES= for module in $REQUIRED_PERL_MODULES; do isPerlModuleInstalled $module || MISSING_PERL_MODULES="$MISSING_PERL_MODULES $module" done # Make sure the JSON module is new if isPerlModuleInstalled JSON &amp;&amp; ! perl -MJSON -e &#39;&amp;decode_json("{}")&#39; &gt; /dev/null 2&gt;&amp;1; then echo "${CWARNING}Old JSON module is installed. Need to install from CPAN.$CEND" MISSING_PERL_MODULES="$MISSING_PERL_MODULES JSON" OLD_PERL_MODULES="$OLD_PERL_MODULES JSON" fi if echo "$MISSING_PERL_MODULES" | grep -wq JSON; then MISSING_PERL_MODULES="JSON::XS $MISSING_PERL_MODULES" fi if echo "$MISSING_PERL_MODULES" | grep -q &#39;XML::LibXML&#39;; then # Sometimes the cpan script doesn&#39;t install the required dependencies MISSING_PERL_MODULES="XML::NamespaceSupport XML::SAX $MISSING_PERL_MODULES" fi } # Detect where cpan is installed and place the path in the CPAN variable. # PCLinuxOS/Mandriva append the version number... detectCpanBin() { for file in $(which cpan 2&gt; /dev/null) $(ls /usr/bin/cpan-* 2&gt; /dev/null); do if [ -x "$file" ]; then CPAN="$file" return fi done isPerlModuleInstalled CPAN &amp;&amp; return errorExit "Could not find the cpan script or the CPAN Perl module. Can&#39;t install missing Perl modules." } isValidTzName() { echo "$1" | LC_ALL=C grep -qE &#39;^[A-Z][^/ ]*(/[A-Z][^/ ]*)?$&#39; &amp;&amp; return 0 return 1 } detectTimeZone() { [ -n "$USER_TIMEZONE" ] &amp;&amp; return local hash= local hasher= local files= local zoneinfoPath=/usr/share/zoneinfo [ -d "$zoneinfoPath" ] || return if hasher=md5sum; isProgramInstalled $hasher || hasher=sha1sum; isProgramInstalled $hasher; then hash=$($hasher /etc/localtime | awk &#39;{print $1}&#39;) files="$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E "^$hash\\&gt;" | awk &#39;{print $2}&#39;)" elif hasher=md5; isProgramInstalled $hasher || hasher=sha1; isProgramInstalled $hasher; then hash=$($hasher /etc/localtime | sed -e &#39;s/^.* = \([a-zA-Z0-9]*\)$/\1/&#39;) files="$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E "$hash\$" | sed -e &#39;s/^[^ ]* (\([^)]*\)).*/\1/&#39;)" else return fi # Detect all possible timezone names local timezones= for path in $files; do local tz="${path#$zoneinfoPath/}" while true; do isValidTzName "$tz" &amp;&amp; break local newTz="${tz#*/}" [ "$newTz" = "$tz" ] &amp;&amp; tz= &amp;&amp; break tz="$newTz" done isValidTzName "$tz" &amp;&amp; timezones="$timezones $tz" done # Now find the ones PHP likes... local okRegions="(Africa|America|Antarctica|Arctic|Asia|Atlantic|Australia|Europe|Indian|Pacific)" for tz in $timezones; do echo "$tz" | grep -qE "^$okRegions/" &amp;&amp; USER_TIMEZONE="$tz" &amp;&amp; return done # Return the first one we found for tz in $timezones; do USER_TIMEZONE="$tz" return done } getNumCpus() { [ -n "$NUMCPUS" ] &amp;&amp; return [ -f /proc/cpuinfo ] &amp;&amp; NUMCPUS=$(cat /proc/cpuinfo | grep &#39;^processor&#39; | wc -l) &amp;&amp; return isProgramInstalled sysctl &amp;&amp; sysctl -n hw.ncpu | grep -qE &#39;^[1-9][0-9]*$&#39; &amp;&amp; NUMCPUS=$(sysctl -n hw.ncpu) &amp;&amp; return NUMCPUS=1 } # Appends $value to $varName in $file, creating the var if it doesn&#39;t exist. The # value is not appended if it already exists. appendFileStringVar() { local file="$1" local varName="$2" local value="$3" [ -f "$file" ] || errorExit "File &#39;$file&#39; does not exist" local varLine=$(grep -E "^$varName=" "$file" | tail -n1) if [ -z "$varLine" ]; then echo "$varName=\"$value\"" &gt;&gt; "$file" else echo "$varLine" | grep -qE "[=&#39;\" ]$value(\"|&#39;| |$)" &amp;&amp; return local q= echo "$varLine" | grep -qE "^$varName=&#39;" &amp;&amp; q="&#39;" echo "$varLine" | grep -qE "^$varName=\"" &amp;&amp; q=&#39;"&#39; sed_i "s#^\\($varName=\\)$q\\(.*\\)$q#\\1\"\\2 $value\"#" "$file" fi } # Set a variable in a script file to a new value. The variable is created if it does not exist setScriptVariable() { local file="$1" local name=$2 local value="$3" [ -f "$file" ] || errorExit "File does not exist: $file" local newLine="$name=\"$value\"" if grep -qE "^$name=" $file; then sed_i "s!^$name=.*\$!$newLine!" "$file" else echo "$newLine" &gt;&gt; "$file" fi } userExists() { id -rg "$1" &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } setSvnOpts() { SVN_OPTS= isProgramInstalled svn || return # svn sometimes gives an error message &#39;broken pipe&#39;. Ignore it. if svn help co 2&gt;/dev/null | grep -q &#39;non-interactive&#39; &amp;&amp; svn help co 2&gt;/dev/null | grep -q &#39;trust-server-cert&#39;; then SVN_OPTS="--non-interactive --trust-server-cert" fi } downloadFile() { local filename="$1" shift for url in "$@"; do for i in 1 2 3 4 5; do wget --no-check-certificate -O "$filename" "$url" &amp;&amp; return 0 done done return 1 } buildMakeProgram() { local url="$1" local name="$2" local builddir="$3" local srcdir="$4" local makefile="${5:-Makefile}" buildStart echo "${CMSG}Downloading $name source code...$CEND" cd "$BUILD_DIR" local filename="${url##*/}" downloadFile "$filename" "$url" || errorExit "Could not download $name source code." tar xzf "$filename" srcdir="${srcdir:-${filename%.tar.gz}}" cd "$srcdir/$builddir" local make=${MAKE:-make} echo "${CMSG}Building $name...$CEND" $make -f $makefile all || errorExit "Could not build $name." $make -f $makefile install || errorExit "Could not install $name." echo "${CMSG}$name is now installed$CEND" buildEnd } buildProgram() { local prog="$1" echo "${CMSG}Building $prog...$CEND" ./configure --prefix=$PREFIX $2 || errorExit "Could not configure $prog. Try again, or try logging out and in and try again." getNumCpus local make=${MAKE:-make} local makeopts="-j$NUMCPUS" $make $makeopts || $make || errorExit "Could not build $prog" $make install || errorExit "Could not install $prog" local ldsoconf=/etc/ld.so.conf touch "$ldsoconf" grep -qE "^$PREFIX/lib$" $ldsoconf || echo "$PREFIX/lib" &gt;&gt; $ldsoconf ldconfig || errorExit "ldconfig failed" echo "${CMSG}$prog is now installed.$CEND" } downloadAndBuild() { local prog="$1" local urls="$2" local name="$3" local configOptions="$4" local patchUrl="$5" cd "$BUILD_DIR" echo "${CMSG}Downloading $prog source code...$CEND" downloadFile "$name.tar.gz" $urls || errorExit "Could not download $prog source code." tar xzf $name.tar.gz if echo "$patchUrl" | grep &#39;^[a-z]*://&#39;; then echo "${CMSG}Patching $prog...$CEND" PACKAGES="patch" installPackages isProgramInstalled patch || errorExit "patch is not installed!" downloadFile the.patch "$patchUrl" || errorExit "Could not download the patch file." patch -p1 -d $name &lt; the.patch || errorExit "Could not patch $prog." elif [ -n "$patchUrl" ]; then echo "${CMSG}Patching $prog...$CEND" cd $name eval $patchUrl cd .. fi cd $name buildProgram "$prog" "$configOptions" } checkoutAndBuild() { local prog="$1" local url="$2" local configOptions="$3" cd "$BUILD_DIR" echo "${CMSG}Downloading $prog source code...$CEND" svn export $SVN_OPTS "$url" "$prog" || errorExit "Could not download $prog source code." cd "$prog" buildProgram "$prog" "$configOptions" } buildStart() { PREFIX=/usr/local OLD_PATH="$PATH" PATH="$PATH:$PREFIX/bin" PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig export PKG_CONFIG_PATH BUILD_DIR="$(echo ~)/build-tmp" rm -rf "$BUILD_DIR" mkdir "$BUILD_DIR" || errorExit "Could not create build directory." } buildEnd() { cd rm -rf "$BUILD_DIR" [ -n "$OLD_PATH" ] &amp;&amp; PATH="$OLD_PATH" unset OLD_PATH unset PKG_CONFIG_PATH } buildRtorrent() { installBuildTools osHandler_$os installRtorrentBuildTools isProgramInstalled pkg-config || errorExit "pkg-config is not installed." # Minimum version is 7.15.4 but I had problems with 7.15.5 on CentOS. Set # it to 7.18.0 (the version Ubuntu Server 8.04 is using). if ! pkg-config --atleast-version=7.18.0 libcurl; then downloadAndBuild "libcurl" "$LIBCURL_URL" "$LIBCURL_NAME" "" # Prevent &#39;Unknown keyword &#39;URL&#39; in ....&#39; error sed_i &#39;s/^URL:/#URL:/&#39; $PREFIX/lib/pkgconfig/libcurl.pc fi if ! pkg-config --exists sigc++-2.0; then downloadAndBuild "sigc++-2.0" "$SIGCPP20_URL" "$SIGCPP20_NAME" "" fi checkoutAndBuild "xmlrpc-c" "$XMLRPC_SVN_DIR" "--disable-cplusplus" downloadAndBuild "libtorrent" "$LIBTORRENT_URL $LIBTORRENT_URL2" "$LIBTORRENT_NAME" "" patchLibtorrent downloadAndBuild "rtorrent" "$RTORRENT_URL $RTORRENT_URL2" "$RTORRENT_NAME" "--with-xmlrpc-c" "" } patchLibtorrent() { # For gcc 4.6.0 ed -s "src/torrent/data/block_transfer.h" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF /#define LIBTORRENT_BLOCK_TRANSFER_H a #include &lt;stddef.h&gt; . w q EOF ed -s "src/data/memory_chunk.cc" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF /#include "config.h" a #include &lt;stddef.h&gt; . w q EOF } installRtorrent() { buildStart buildRtorrent buildEnd } installUnrar() { isProgramInstalled unrar &amp;&amp; return installBuildTools buildMakeProgram "$UNRAR_URL" "unrar" "" "unrar" "makefile.unix" } installModScgi() { local modScgiFile="$1" local modulesPath="$2" [ -f "$modScgiFile" ] &amp;&amp; errorExit "mod_scgi file already exists." [ -d "$modulesPath" ] || errorExit "Apache modules path &#39;$modulesPath&#39; does not exist." buildMakeProgram "$MOD_SCGI_URL" "mod_scgi" "apache2" echo "LoadModule scgi_module $modulesPath/mod_scgi.so" &gt; $modScgiFile } isPortUsed() { local port="$1" netstat -an | grep tcp | grep -w LISTEN | grep -qE "[.:]$port[ ]" &amp;&amp; return 0 return 1 } isValidIpAddress() { # It&#39;s not 100% accurate ... ;) echo $1 | grep -qE &#39;^[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?$&#39; } getIpAddress() { isValidIpAddress "$OUR_IP_ADDRESS" &amp;&amp; return echo "${CMSG}Detecting your IP address...$CEND" isValidIpAddress "$OUR_IP_ADDRESS" || OUR_IP_ADDRESS=$(wget --no-check-certificate http://www.whatismyip.com/automation/n09230945.asp -O - -o /dev/null) isValidIpAddress "$OUR_IP_ADDRESS" || OUR_IP_ADDRESS=$(ifconfig -a | grep "inet addr" | head -n1 | awk -F: &#39;{print $2}&#39; | awk &#39;{print $1}&#39;) isValidIpAddress "$OUR_IP_ADDRESS" || OUR_IP_ADDRESS="1.2.3.4" } getNewPortNumber() { while true; do newPortNumber=$CURRENT_PORT CURRENT_PORT=$(expr $CURRENT_PORT + 1) isValidPortNumber $newPortNumber || errorExit "Invalid port number. Change CURRENT_PORT." isPortUsed $newPortNumber || break echo "${CWARNING}Port $newPortNumber is in use, trying next port...$CEND" done } # Returns true if it&#39;s a valid ruTorrent base path isValidRutorrentBasePath() { [ -n "$1" ] &amp;&amp; [ -d "$1/conf" ] } isValidPassword() { echo "$1" | grep -qE "^ " &amp;&amp; return 1 echo "$1" | grep -qE " \$" &amp;&amp; return 1 echo "$1" | grep -qE &#39;^$&#39; &amp;&amp; return 1 echo "$1" | grep -q &#39;:&#39; &amp;&amp; return 1 echo "&#39;$1&#39;" | grep -q &#39; &#39; &amp;&amp; return 1 return 0 } isValidPortNumber() { echo "$1" | grep -qiE &#39;^[0-9]+$&#39; || return 1 echo "$1" | grep -qiE &#39;[0-9][0-9][0-9][0-9][0-9][0-9]&#39; &amp;&amp; return 1 [ $1 -ge 1024 ] &amp;&amp; [ $1 -le 65535 ] } isValidWebUser() { [ -z "$1" ] &amp;&amp; return 1 echo "$1" | LC_ALL=C grep -qE &#39;[A-Z:]&#39; &amp;&amp; return 1 return 0 } initUsers() { local users= for packedUser in $USERS; do extractPackedUser $packedUser if [ -z "$autodlPort" ]; then getNewPortNumber autodlPort=$newPortNumber fi if [ -z "$scgiPort" ]; then getNewPortNumber scgiPort=$newPortNumber fi if [ -z "$rtorrentPort" ]; then getNewPortNumber rtorrentPort=$newPortNumber fi if canGeneratePasswords; then if [ -z "$autodlPassword" ]; then generatePassword autodlPassword="$newPassword" fi fi users="$users $osUser:$autodlPassword:$webUser:$webPass:$autodlPort:$scgiPort:$rtorrentPort" done USERS="$users" } extractPackedUser() { local packedUser="$1" osUser="$(echo $packedUser | cut -d: -f1)" autodlPassword="$(echo $packedUser | cut -d: -f2)" webUser="$(echo $packedUser | cut -d: -f3)" webPass="$(echo $packedUser | cut -d: -f4)" autodlPort="$(echo $packedUser | cut -d: -f5)" scgiPort="$(echo $packedUser | cut -d: -f6)" rtorrentPort="$(echo $packedUser | cut -d: -f7)" } getUserGroup() { local user="$1" userExists "$user" || errorExit "The user &#39;$user&#39; does not exist." group=$(grep -w $(id -rg $user) /etc/group | cut -d: -f1) [ -z "$group" ] &amp;&amp; group="$user" } getUserDir() { local user="$1" [ -z "$user" ] &amp;&amp; errorExit "Invalid user (blank)." userDir="$(eval echo ~$user)" [ -d "$userDir" ] || errorExit "User $user&#39;s home directory does not exist." } resetOwner() { local user="$1" shift if [ "$ISROOT" = y ]; then getUserGroup "$user" chown -R $user:$group "$@" fi } # Updates MISSING_PHP_MODULES with all missing required PHP modules detectMissingPhpModules() { MISSING_PHP_MODULES= local php=${WWW_PHP_CGI:-php} for module in $REQUIRED_PHP_MODULES; do $php -m 2&gt; /dev/null | grep -wq $module || MISSING_PHP_MODULES="$MISSING_PHP_MODULES $module" done } installMissingPhpPackages() { PACKAGES= for module in $MISSING_PHP_MODULES; do PACKAGES="$PACKAGES php-$module" done installPackages } installMissingPhp5Packages() { PACKAGES= for module in $MISSING_PHP_MODULES; do PACKAGES="$PACKAGES php5-$module" done installPackages } enablePhpIniModules() { local phpIni="$1" shift for module in "$@"; do grep -qE "^extension=$module.so" "$phpIni" &amp;&amp; continue sed_i "s/^; *\\(extension=$module.so.*\\)/\\1/" "$phpIni" grep -qE "^extension=$module.so" "$phpIni" &amp;&amp; continue echo "extension=$module.so" &gt;&gt; "$phpIni" done } installMissingPhpModules() { detectMissingPhpModules [ -z "$MISSING_PHP_MODULES" ] &amp;&amp; return osHandler_$os installPhpModules detectMissingPhpModules [ -z "$MISSING_PHP_MODULES" ] &amp;&amp; return cat &lt;&lt; EOF $CWARNING The following PHP modules appear to be missing: $MISSING_PHP_MODULES If the autodl-irssi ruTorrent plugin isn&#39;t working, you now know why. Install them using your package manager or enable them in your php.ini file, and restart your web server.$CEND EOF } addLogrotateConfig() { local serviceName="$1" local logFiles="$2" local postrotateScript="$3" local logrotate_d=/etc/logrotate.d [ -d "$logrotate_d" ] || errorExit "Missing logrotate dir: $logrotate_d" cat &gt; "$logrotate_d/$serviceName" &lt;&lt; EOF $logFiles { missingok daily rotate 14 notifempty compress delaycompress sharedscripts postrotate $postrotateScript endscript } EOF [ $? -eq 0 ] || errorExit "Could not write logrotate file $logrotate_d/$serviceName" } detectPhpCgi() { WWW_PHP_CGI=${WWW_PHP_CGI:-$(which php-cgi | head -n1)} [ -x "$WWW_PHP_CGI" ] || errorExit "Could not find php-cgi" "$WWW_PHP_CGI" -v | grep -q &#39;cgi-fcgi&#39; || errorExit "$WWW_PHP_CGI does not support FastCGI" } # $i is the i&#39;th user number getUserRpcMount() { local i=$1 verifyWebServerVars # Make sure /RPC10 accesses aren&#39;t going to /RPC1 by padding with zeros. This is # easier than making sure every web server handles it correctly. Eg., lighttpd&#39;s # scgi.server table is read in order, so if you add /RPC1 before /RPC10, then # /RPC10 accesses will go to /RPC1. A fix would of course be to place /RPC10 # before /RPC1 but it&#39;s easy to forget. Now we use /RPC00001 .. /RPC99999 echo "/$RPC_PREFIX$(printf &#39;%05d&#39; $i)" } createSelfSignedCertFile() { local pemfile="$1" if [ ! -f "$OTHER_PEM_FILE" ]; then echo "${CMSG}Creating the self-signed certificate.$CEND" rm -f "$pemfile" openssl req -new -newkey rsa:1024 -days 1000 -nodes -x509 -keyout "$pemfile" -out "$pemfile" -batch \ || errorExit "Failed to create self-signed certificate." OTHER_PEM_FILE="$pemfile" CREATED_CERT_FILE=y else rm -f "$pemfile" cp "$OTHER_PEM_FILE" "$pemfile" || errorExit "Failed to copy self-signed certificate." fi chmod 0600 "$pemfile" } detectHtpasswd() { [ -z "$htpasswd" ] &amp;&amp; isProgramInstalled htpasswd &amp;&amp; htpasswd=htpasswd [ -z "$htpasswd" ] &amp;&amp; isProgramInstalled htpasswd2 &amp;&amp; htpasswd=htpasswd2 if [ -z "$htpasswd" ]; then installProgram python if isProgramInstalled python; then cd downloadFile "htpasswd.py" "$HTPASSWD_PY_SCRIPT_URL" "$HTPASSWD_PY_SCRIPT_URL2" \ &amp;&amp; htpasswd="python $(pwd)/htpasswd.py" fi fi [ -z "$htpasswd" ] &amp;&amp; errorExit "Could not find htpasswd" } verifyWebServerVars() { [ -z "$WWW_PEMFILE" ] &amp;&amp; errorExit "You have not initialized WWW_PEMFILE" [ -z "$WWW_PASSWORD_FILE" ] &amp;&amp; errorExit "You have not initialized WWW_PASSWORD_FILE" [ -z "$WWW_ROOT" ] &amp;&amp; errorExit "You have not initialized WWW_ROOT" [ -z "$WWW_USER" ] &amp;&amp; errorExit "You have not initialized WWW_USER" [ -z "$WWW_GROUP" ] &amp;&amp; errorExit "You have not initialized WWW_GROUP" } initializeWwwRootVar() { WWW_ROOT=${WWW_ROOT:-/var/rutorrent} } createWebServerUserGroup() { verifyWebServerVars if ! grep -qE "^$WWW_GROUP:" /etc/group; then groupadd -r $WWW_GROUP 2&gt;/dev/null || groupadd $WWW_GROUP || errorExit "Could not create web server group." fi if ! grep -qE "^$WWW_USER:" /etc/passwd; then local useradd="useradd -d $WWW_ROOT -g $WWW_GROUP -s /bin/sh" $useradd -M -r $WWW_USER 2&gt;/dev/null || $useradd $WWW_USER || errorExit "Could not create web server user." fi } resetAuthPasswordFilePermissions() { [ -n "$WWW_USER" ] || errorExit "WWW_USER not initialized" [ -n "$WWW_GROUP" ] || errorExit "WWW_GROUP not initialized" chmod 0400 "$WWW_PASSWORD_FILE"* chown $WWW_USER:$WWW_GROUP "$WWW_PASSWORD_FILE"* } createAuthPasswordFile() { verifyWebServerVars : &gt; "$WWW_PASSWORD_FILE" resetAuthPasswordFilePermissions } # Some web servers (eg. nginx) can&#39;t allow just ONE user access to a certain # location. To fix that, create one password file per user. createOnePasswordFilePerUser() { for packedUser in $USERS; do extractPackedUser $packedUser grep "^$webUser:" "$WWW_PASSWORD_FILE" &gt; "${WWW_PASSWORD_FILE}_$webUser" done resetAuthPasswordFilePermissions } updatePhpTimezone() { if [ ! -f "$WWW_PHP_INI" ]; then echo "${CWARNING}Could not find php.ini file: $WWW_PHP_INI$CEND" return fi [ -z "$USER_TIMEZONE" ] &amp;&amp; return local zws="[ ]*" local newLine="date.timezone = $USER_TIMEZONE" if grep -qE "^${zws}date\\.timezone[ =]" "$WWW_PHP_INI"; then return elif grep -qE "^${zws}[;#]${zws}date\\.timezone[ =]" "$WWW_PHP_INI"; then sed_i "s!^${zws}[;#]${zws}date\\.timezone[ =].*\$!$newLine!" "$WWW_PHP_INI" else cat &gt;&gt; "$WWW_PHP_INI" &lt;&lt; EOF [Date] $newLine EOF fi } doDetectTimeZone() { echo "${CMSG}Detecting timezone...$CEND" detectTimeZone if [ -n "$USER_TIMEZONE" ]; then echo "${CMSG}Timezone: $USER_TIMEZONE$CEND" updatePhpTimezone else echo "${CWARNING}Could not detect timezone!$CEND" fi } webServerCommonInitialization() { mkdir -p $WWW_ROOT doDetectTimeZone createSelfSignedCertFile "$WWW_PEMFILE" createAuthPasswordFile } resetWebServerPermissions() { verifyWebServerVars chown -R $WWW_USER:$WWW_GROUP $WWW_ROOT || errorExit "Could not set web server as owner of $WWW_ROOT" } createPhpcgiSocket() { PHPCGI_SOCKET_DIR=/etc/phpcgi PHPCGI_SOCKET_FILE="$PHPCGI_SOCKET_DIR/php-cgi.socket" mkdir -p "$PHPCGI_SOCKET_DIR" chown $WWW_USER:$WWW_GROUP "$PHPCGI_SOCKET_DIR" chmod 0770 "$PHPCGI_SOCKET_DIR" } verifyApacheServerVars() { verifyWebServerVars [ -z "$APACHE_SITE_FILE" ] &amp;&amp; errorExit "You have not initialized APACHE_SITE_FILE" } apacheCreateApxs2Symlink() { # The makefile uses apxs2, so make a symlink if ! isProgramInstalled apxs2; then local apxs=$(which apxs 2&gt;/dev/null) &amp;&amp; ln -s "$apxs" "${apxs}2" fi } initializeApacheVars() { local apacheUser="$1" local apacheGroup="$2" local apacheSitesDir="$3" [ -n "$apacheUser" ] || errorExit "Invalid apache user: $apacheUser" [ -n "$apacheGroup" ] || errorExit "Invalid apache group: $apacheGroup" [ -d "$apacheSitesDir" ] || errorExit "Invalid apache sites dir: $apacheSitesDir" [ -d "$APACHE_DIR" ] || errorExit "Invalid apache dir: $APACHE_DIR" APACHE_SITE_NAME=${APACHE_SITE_NAME:-rutorrent.conf} APACHE_SITE_FILE=$apacheSitesDir/$APACHE_SITE_NAME initializeWwwRootVar WWW_PASSWORD_FILE=$APACHE_DIR/rutorrent_passwd WWW_PEMFILE=$APACHE_DIR/rutorrent.pem WWW_USER="$apacheUser" WWW_GROUP="$apacheGroup" } apacheGetRpcLocationDirectives() { if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF &lt;Location "$rpcMount"&gt; AuthType Basic AuthName "$RUTORRENT_SITE_REALM" AuthUserFile "$WWW_PASSWORD_FILE" Require user $webUser &lt;/Location&gt; EOF i=$(expr $i + 1) done fi } apacheGetVirtualHost() { local port=$1 local ssl=$2 cat &lt;&lt; EOF &lt;VirtualHost *:$port&gt; $(if [ "$ssl" = y ]; then echo " SSLEngine On" echo " SSLCertificateFile $WWW_PEMFILE" fi) ServerAdmin admin@rutorrent ServerName localhost DocumentRoot $WWW_ROOT &lt;Directory /&gt; AllowOverride None Order deny,allow Deny from all &lt;/Directory&gt; &lt;Location /&gt; AuthType Basic AuthName "$RUTORRENT_SITE_REALM" AuthUserFile "$WWW_PASSWORD_FILE" Require valid-user Order allow,deny Allow from all &lt;/Location&gt; &lt;Location ~ "^/rutorrent/(conf|share)"&gt; Order deny,allow Deny from all &lt;/Location&gt; &lt;Location ~ "/\\\\.svn"&gt; Order deny,allow Deny from all &lt;/Location&gt; $(apacheGetRpcLocationDirectives) &lt;/VirtualHost&gt; EOF } apacheWriteSiteFile() { verifyApacheServerVars cat &gt; "$APACHE_SITE_FILE" &lt;&lt; EOF ServerName localhost $(apacheGetVirtualHost $HTTP_PORT n) $(apacheGetVirtualHost $HTTPS_PORT y) EOF if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount="$(getUserRpcMount $i)" echo "${lp}SCGIMount $rpcMount $SCGI_HOST:$scgiPort" &gt;&gt; "$APACHE_SITE_FILE" i=$(expr $i + 1) done fi } apacheCommonInitialization() { local buildTools="$1" local modulesDir="$2" webServerCommonInitialization apacheWriteSiteFile if [ -n "$APACHE_SCGI_FILE" ] &amp;&amp; [ ! -f "$APACHE_SCGI_FILE" ]; then installBuildTools PACKAGES="$buildTools" installPackages apacheCreateApxs2Symlink # Compiling mod_scgi will fail unless we remove this warning-as-error flag local configVarsFile="$APACHE_DIR/modules/build/config_vars.mk" [ -f "$configVarsFile" ] &amp;&amp; sed_i &#39;s/-Werror=format-security//g&#39; "$configVarsFile" installModScgi "$APACHE_SCGI_FILE" "$modulesDir" fi } installCommonWebServerStuff_mandriva() { # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="php-cli gzip curl openssl logrotate" installPackages PACKAGE="unrar" installPackages PACKAGES="php-geoip" installPackages } # Used by Mandriva, Unity Linux, and PCLinuxOS installApache_mandriva() { installCommonWebServerStuff_mandriva PACKAGES="apache-mpm-prefork apache-mod_ssl apache-mod_php" installPackages WWW_PHP_INI=/etc/php.ini APACHE_DIR=/etc/httpd local APACHE_CONF_D=$APACHE_DIR/conf.d local APACHE_SITES_DIR=$APACHE_DIR/conf/vhosts.d APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf initializeApacheVars apache apache "$APACHE_SITES_DIR" apacheCommonInitialization "libopenssl-devel apache-devel" $APACHE_DIR/modules for file in 00_default_vhosts.conf 01_default_ssl_vhost.conf; do [ -f "$APACHE_SITES_DIR/$file" ] &amp;&amp; mv -f "$APACHE_SITES_DIR/$file" "$APACHE_SITES_DIR/$file-bak" done resetWebServerPermissions chkconfig httpd on service httpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" } installCommonWebServerStuff_gentoo() { # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="dev-lang/php logrotate" addProgram gzip app-arch/gzip addProgram curl net-misc/curl addProgram openssl dev-libs/openssl addProgram unrar app-arch/unrar installPackages ACCEPT_LICENSE=MaxMind export ACCEPT_LICENSE PACKAGES="dev-php5/pecl-geoip" installPackages unset ACCEPT_LICENSE } installApache_gentoo() { installCommonWebServerStuff_gentoo PACKAGES="www-servers/apache app-admin/apache-tools" installPackages PACKAGES="www-apache/mod_scgi" installPackages WWW_PHP_INI=$(ls /etc/php/apache2-php5*/php.ini | tail -n1) [ -f "$WWW_PHP_INI" ] || errorExit "Could not find Apache php.ini file" APACHE_DIR=/etc/apache2 local APACHE_CONF=$APACHE_DIR/httpd.conf local APACHE_SITES_DIR=$APACHE_DIR/vhosts.d local SERVER_ROOT=$(grep -E ^ServerRoot $APACHE_CONF | head -n1 | sed -e &#39;s!^.*[ ][^/]*\(/[^"]*\).*!\1!&#39;) APACHE_SCGI_FILE="$APACHE_DIR/modules.d/scgi.conf" [ -d "$SERVER_ROOT" ] || errorExit "Apache server root dir does not exist: $SERVER_ROOT" initializeApacheVars apache apache "$APACHE_SITES_DIR" apacheCommonInitialization "" $SERVER_ROOT/modules for file in 00_default_ssl_vhost.conf 00_default_vhost.conf; do [ -f "$APACHE_SITES_DIR/$file" ] &amp;&amp; mv -f "$APACHE_SITES_DIR/$file" "$APACHE_SITES_DIR/$file-bak" done appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS "-D SCGI" appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS "-D PHP5" appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS "-D SSL" cat &gt;&gt; $APACHE_SITE_FILE &lt;&lt; EOF Listen $HTTP_PORT Listen $HTTPS_PORT EOF resetWebServerPermissions rc-update add apache2 default osHandler_$os restart_$INSTALL_WEB_SERVER } nginxGetRpcMounts() { if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser getUserScgiSocketPath "$osUser" local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF $lp location ~ ^$rpcMount\$ { $lp include scgi_params; $lp scgi_pass unix:$scgiSocketPath; $lp auth_basic "$RUTORRENT_SITE_REALM"; $lp auth_basic_user_file "${WWW_PASSWORD_FILE}_$webUser"; $lp } EOF i=$(expr $i + 1) done fi } nginxGetServerSection() { local port=$1 local ssl=$2 cat &lt;&lt; EOF server { listen $port; server_name localhost; auth_basic "$RUTORRENT_SITE_REALM"; auth_basic_user_file "$WWW_PASSWORD_FILE"; $(if [ "$ssl" = y ]; then cat &lt;&lt; EOF2 ssl on; ssl_certificate $WWW_PEMFILE; ssl_certificate_key $WWW_PEMFILE; EOF2 fi) location ~ ^/rutorrent/(?:share|conf) { deny all; } location ~ /\.ht { deny all; } location ~ /\.svn { deny all; } location / { root $WWW_ROOT; index index.php index.html index.htm; } location ~ \.php$ { root "$WWW_ROOT"; fastcgi_pass unix:$PHPCGI_SOCKET_FILE; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name; include fastcgi_params; } $(nginxGetRpcMounts) } EOF } nginxWriteConfFile() { getNumCpus cat &gt; $NGINX_CONF &lt;&lt; EOF worker_processes $NUMCPUS; user $WWW_USER $WWW_GROUP; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # I have to set min length to 0 and http version to 1.0 or it won&#39;t compress # the XML-RPC (SCGI) responses. Those responses can be quite large if you&#39;re # using many torrent files. gzip on; gzip_min_length 0; gzip_http_version 1.0; gzip_types text/plain text/xml application/xml application/json text/css application/x-javascript text/javascript application/javascript; $(nginxGetServerSection $HTTP_PORT n) $(nginxGetServerSection $HTTPS_PORT y) } EOF [ $? -eq 0 ] || errorExit "Could not write to file $NGINX_CONF" } buildNginx() { buildStart PREFIX=$NGINX_DIR NGINX_BIN=$PREFIX/sbin/nginx NGINX_CONF=$PREFIX/conf/nginx.conf NGINX_PID_FILE=$PREFIX/nginx.pid NGINX_ACCESS_LOG=$PREFIX/logs/access.log NGINX_ERROR_LOG=$PREFIX/logs/error.log local configureFlags="\ --prefix=$PREFIX \ --sbin-path=$NGINX_BIN \ --conf-path=$NGINX_CONF \ --pid-path=$NGINX_PID_FILE \ --lock-path=$PREFIX/logs/nginx.lock \ --error-log-path=$NGINX_ERROR_LOG \ --http-log-path=$NGINX_ACCESS_LOG \ --user=$WWW_USER \ --group=$WWW_GROUP \ --with-http_ssl_module" export CFLAGS="$NGINX_CFLAGS" downloadAndBuild "nginx" "$NGINX_URL" "$NGINX_NAME" "$configureFlags" patchNginx unset CFLAGS buildEnd } patchNginx() { # Get rid of the -Werror flag for gcc 4.6.0 sed_i "s!-Werror[a-zA-Z0-9=-]*!!" "auto/cc/gcc" } installNginx() { SCGI_USE_UNIX_DOMAIN_SOCKET=y CREATE_ONE_PASSWORD_FILE_PER_USER=y installBuildTools osHandler_$os preNginxInstall installUnrar NGINX_DIR=/usr/local/nginx initializeWwwRootVar WWW_PASSWORD_FILE=$NGINX_DIR/rutorrent_passwd WWW_PEMFILE=$NGINX_DIR/rutorrent.pem WWW_USER=${WWW_USER:-nginx} WWW_GROUP=${WWW_GROUP:-nginx} detectPhpCgi createWebServerUserGroup createPhpcgiSocket buildNginx webServerCommonInitialization nginxWriteConfFile addLogrotateConfig nginx \ "$NGINX_ACCESS_LOG $NGINX_ERROR_LOG" \ "[ -f \"$NGINX_PID_FILE\" ] &amp;&amp; kill -USR1 \$(cat \"$NGINX_PID_FILE\") &gt;/dev/null 2&gt;&amp;1; true" resetWebServerPermissions osHandler_$os installPhpCgiService osHandler_$os installNginxService } preNginxInstall_gentoo() { installCommonWebServerStuff_gentoo PACKAGES="libpcre openssl zlib php" installPackages WWW_PHP_INI=$(ls /etc/php/cgi-php5*/php.ini | tail -n1) [ -f "$WWW_PHP_INI" ] || errorExit "Could not find php-cgi php.ini file" } preLighttpdInstall_gentoo() { preNginxInstall_gentoo } lighttpdGetRpcRequire() { if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF "$rpcMount" =&gt; ( "method" =&gt; "basic", "realm" =&gt; "$RUTORRENT_SITE_REALM", "require" =&gt; "user=$webUser", ), EOF i=$(expr $i + 1) done fi } lighttpdGetScgiServerTable() { echo &#39;scgi.server = (&#39; if [ "$INSTALL_RUTORRENT" = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser getUserScgiSocketPath "$osUser" local rpcMount="$(getUserRpcMount $i)" cat &lt;&lt; EOF $lp "$rpcMount" =&gt; ( $lp ( $lp "socket" =&gt; "$scgiSocketPath", $lp "check-local" =&gt; "disable", $lp "disable-time" =&gt; 0, $lp ), $lp ), EOF i=$(expr $i + 1) done fi echo &#39;)&#39; } lighttpdWriteConfFile() { cat &gt; $LIGHTTPD_CONF &lt;&lt; EOF server.follow-symlink = "disable" server.max-connections = 512 server.max-fds = 1024 server.max-keep-alive-idle = 15 dir-listing.activate = "disable" server.pid-file = "$LIGHTTPD_PID_FILE" server.errorlog = "$LIGHTTPD_ERROR_LOG" accesslog.filename = "$LIGHTTPD_ACCESS_LOG" $(if [ $(uname -s) = Linux ]; then echo &#39;server.event-handler = "linux-sysepoll"&#39; echo &#39;server.network-backend = "linux-sendfile"&#39; fi) server.username = "$WWW_USER" server.groupname = "$WWW_GROUP" server.modules = ( # "mod_rewrite", # "mod_redirect", # "mod_alias", "mod_access", "mod_auth", # "mod_status", # "mod_simple_vhost", # "mod_evhost", # "mod_userdir", # "mod_secdownload", "mod_fastcgi", # "mod_proxy", # "mod_cgi", "mod_scgi", # "mod_ssi", # "mod_compress", # "mod_usertrack", # "mod_expire", # "mod_rrdtool", "mod_accesslog", ) fastcgi.server = ( ".php" =&gt; ( ( "socket" =&gt; "$PHPCGI_SOCKET_FILE", ), ), ) index-file.names = ( "index.php", "index.html", "index.htm" ) static-file.exclude-extensions = ( ".fcgi", ".php", ".rb", "~", ".inc" ) mimetype.assign = ( ".html" =&gt; "text/html", ".htm" =&gt; "text/html", ".txt" =&gt; "text/plain", ".csv" =&gt; "text/plain", ".ini" =&gt; "text/plain", ".jpg" =&gt; "image/jpeg", ".jpeg" =&gt; "image/jpeg", ".gif" =&gt; "image/gif", ".png" =&gt; "image/png", ".bmp" =&gt; "image/bmp", ".css" =&gt; "text/css", ".js" =&gt; "application/javascript", ".ico" =&gt; "image/x-icon", ".json" =&gt; "application/json", ".torrent" =&gt; "application/x-bittorrent", ".pdf" =&gt; "application/pdf", ".bz2" =&gt; "application/x-bzip2", ".gz" =&gt; "application/x-gzip", ".tar.gz" =&gt; "application/x-tgz", ".tar" =&gt; "application/x-tar", ".tar.bz2" =&gt; "application/x-bzip-compressed-tar", ".tbz" =&gt; "application/x-bzip-compressed-tar", ".tgz" =&gt; "application/x-tgz", ".zip" =&gt; "application/zip", ".mp3" =&gt; "audio/mpeg", ".flac" =&gt; "audio/x-flac", ".m3u" =&gt; "audio/x-mpegurl", ".wma" =&gt; "audio/x-ms-wma", ".wax" =&gt; "audio/x-ms-wax", ".ogg" =&gt; "audio/ogg", ".wav" =&gt; "audio/x-wav", ".dtd" =&gt; "text/xml", ".xml" =&gt; "text/xml", ".mpeg" =&gt; "video/mpeg", ".mpg" =&gt; "video/mpeg", ".mp4" =&gt; "video/mp4", ".wmv" =&gt; "video/x-ms-wmv", ".avi" =&gt; "video/x-msvideo", ) server.document-root = "$WWW_ROOT" server.port = $HTTP_PORT \$SERVER["socket"] == ":$HTTPS_PORT" { ssl.engine = "enable" ssl.pemfile = "$WWW_PEMFILE" } url.access-deny = (".htaccess") \$HTTP["url"] =~ "^/rutorrent/(?:share|conf)" { url.access-deny = ("") } \$HTTP["url"] =~ "/\\.svn" { url.access-deny = ("") } auth.backend = "htpasswd" auth.backend.htpasswd.userfile = "$WWW_PASSWORD_FILE" auth.require = ( $(lighttpdGetRpcRequire) "/" =&gt; ( "method" =&gt; "basic", "realm" =&gt; "$RUTORRENT_SITE_REALM", "require" =&gt; "valid-user", ), ) $(lighttpdGetScgiServerTable) EOF [ $? -eq 0 ] || errorExit "Could not write to file $LIGHTTPD_CONF" } buildLighttpd() { buildStart PREFIX=$LIGHTTPD_DIR LIGHTTPD_BIN=$PREFIX/sbin/lighttpd LIGHTTPD_CONF=$PREFIX/lighttpd.conf # The log dir will be set to owner lighttpd since it&#39;s started as non-root. # Put the pid file there so it can write to it. LIGHTTPD_LOG_DIR=$PREFIX/logs LIGHTTPD_PID_FILE=$LIGHTTPD_LOG_DIR/lighttpd.pid LIGHTTPD_ERROR_LOG=$LIGHTTPD_LOG_DIR/error.log LIGHTTPD_ACCESS_LOG=$LIGHTTPD_LOG_DIR/access.log local configureFlags="\ --prefix=$PREFIX \ --with-openssl \ --with-pcre \ --with-zlib \ --without-bzip2" downloadAndBuild "lighttpd" "$LIGHTTPD_URL" "$LIGHTTPD_NAME" "$configureFlags" buildEnd } installLighttpd() { SCGI_USE_UNIX_DOMAIN_SOCKET=y installBuildTools osHandler_$os preLighttpdInstall installUnrar LIGHTTPD_DIR=/usr/local/lighttpd initializeWwwRootVar WWW_PASSWORD_FILE=$LIGHTTPD_DIR/rutorrent_passwd WWW_PEMFILE=$LIGHTTPD_DIR/rutorrent.pem WWW_USER=${WWW_USER:-lighttpd} WWW_GROUP=${WWW_GROUP:-lighttpd} detectPhpCgi createWebServerUserGroup createPhpcgiSocket buildLighttpd webServerCommonInitialization lighttpdWriteConfFile addLogrotateConfig lighttpd \ "$LIGHTTPD_ACCESS_LOG $LIGHTTPD_ERROR_LOG" \ "[ -f \"$LIGHTTPD_PID_FILE\" ] &amp;&amp; kill -HUP \$(cat \"$LIGHTTPD_PID_FILE\") &gt;/dev/null 2&gt;&amp;1; true" mkdir -p "$LIGHTTPD_LOG_DIR" chown -R $WWW_USER:$WWW_GROUP "$LIGHTTPD_LOG_DIR" resetWebServerPermissions osHandler_$os installPhpCgiService osHandler_$os installLighttpdService } # Add $name=$value to the file, or modify an existing line if present in the file setVsftpdValue() { local confFile="$1" local name="$2" local value="$3" local newLine="$name=$value" sed_i "s!^[ ]*$name[ =:].*\$!$newLine!" "$confFile" grep -qE "^$newLine$" "$confFile" || echo "$newLine" &gt;&gt; "$confFile" } # Same as setVsftpdValue but makes sure the option exists setVsftpdValue2() { local confFile="$1" local name="$2" local value="$3" [ -z "$VSFTPD_PATH" ] &amp;&amp; return grep -q "$name" "$VSFTPD_PATH" &amp;&amp; setVsftpdValue "$confFile" "$name" "$value" } updateVsftpdConf() { local confFile="$1" touch "$confFile" VSFTPD_PATH=$(which vsftpd 2&gt;/dev/null) setVsftpdValue "$confFile" anonymous_enable NO setVsftpdValue "$confFile" dirlist_enable YES setVsftpdValue "$confFile" download_enable YES setVsftpdValue "$confFile" guest_enable NO setVsftpdValue "$confFile" listen YES setVsftpdValue "$confFile" listen_ipv6 NO setVsftpdValue "$confFile" local_enable YES setVsftpdValue "$confFile" local_umask $DEFAULT_UMASK setVsftpdValue "$confFile" max_per_ip 0 setVsftpdValue "$confFile" pasv_enable YES setVsftpdValue "$confFile" port_enable YES setVsftpdValue "$confFile" pasv_promiscuous NO setVsftpdValue "$confFile" port_promiscuous NO setVsftpdValue "$confFile" pasv_min_port 0 setVsftpdValue "$confFile" pasv_max_port 0 setVsftpdValue "$confFile" write_enable YES if [ "$USE_ENCRYPTED_FTP" = y ]; then local pemfile=/etc/vsftpd.pem createSelfSignedCertFile "$pemfile" FTP_SERVER_TYPE="FTPES - Encrypted (FTP over explicit TLS/SSL)" FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTPES} setVsftpdValue "$confFile" listen_port $FTP_PORT setVsftpdValue "$confFile" ssl_enable YES setVsftpdValue "$confFile" allow_anon_ssl NO setVsftpdValue "$confFile" force_local_data_ssl YES setVsftpdValue "$confFile" force_local_logins_ssl YES setVsftpdValue "$confFile" ssl_sslv2 NO setVsftpdValue "$confFile" ssl_sslv3 NO setVsftpdValue "$confFile" ssl_tlsv1 YES setVsftpdValue "$confFile" rsa_cert_file "$pemfile" setVsftpdValue2 "$confFile" implicit_ssl NO setVsftpdValue2 "$confFile" require_cert NO setVsftpdValue2 "$confFile" require_ssl_reuse NO setVsftpdValue2 "$confFile" ssl_request_cert YES setVsftpdValue2 "$confFile" strict_ssl_read_eof NO setVsftpdValue2 "$confFile" strict_ssl_write_shutdown NO setVsftpdValue2 "$confFile" validate_cert NO else FTP_SERVER_TYPE="FTP - Non-encrypted" FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTP} setVsftpdValue "$confFile" listen_port $FTP_PORT setVsftpdValue "$confFile" ssl_enable NO fi # The private key is in rsa_cert_file sed_i &#39;g/rsa_private_key_file/d&#39; "$confFile" } installVsftpd_chkconfig() { local vsftpdConf="$1" installProgram vsftpd [ -f "$vsftpdConf" ] || errorExit "Invalid vsftpd.conf file: $vsftpdConf" updateVsftpdConf "$vsftpdConf" chkconfig vsftpd on if ! service vsftpd restart; then if [ "$SELINUX_ENABLED" = y ]; then errorExit "Could not restart vsftpd. SELinux could be the reason." else errorExit "Could not restart vsftpd" fi fi } installVsftpd_gentoo() { installProgram net-ftp/vsftpd local vsftpdConf=/etc/vsftpd/vsftpd.conf if ! [ -f $vsftpdConf ]; then touch $vsftpdConf [ -f $vsftpdConf.example ] &amp;&amp; cp $vsftpdConf.example $vsftpdConf fi updateVsftpdConf $vsftpdConf rc-update add vsftpd default /etc/init.d/vsftpd restart } installService_chkconfig1() { CHKCONFIG_SERVICE_NAME=$1 CHKCONFIG_SERVICE_FILE=/etc/init.d/$CHKCONFIG_SERVICE_NAME CHKCONFIG_LOCK_FILE=/var/lock/subsys/$CHKCONFIG_SERVICE_NAME } installService_chkconfig2() { chmod +x "$CHKCONFIG_SERVICE_FILE" || errorExit "Could not set +x bit, file $CHKCONFIG_SERVICE_FILE." chkconfig --add $CHKCONFIG_SERVICE_NAME || errorExit "Could not install service $CHKCONFIG_SERVICE_FILE. Run this script as root." service $CHKCONFIG_SERVICE_NAME restart } getChkconfigScriptContents() { local desc="$1" cat &lt;&lt; EOF # chkconfig: 2345 85 15 # description: $desc EOF } getLsbStartupScriptContents() { local startupName="$1" local desc="$2" cat &lt;&lt; EOF ### BEGIN INIT INFO # Provides: $startupName # Required-Start: \$local_fs \$network \$syslog # Required-Stop: \$local_fs \$syslog # Default-Start: $LSB_DEFAULT_START # Default-Stop: $LSB_DEFAULT_STOP # Short-Description: $desc # Description: $desc ### END INIT INFO EOF } # You must define v_{startIt,stopIt,restartIt,showStatus} and isStarted funcs getLsbStartupFooter() { cat &lt;&lt; EOF resetPath # Some include files may have reset it LOCKFILE=$1 updateLock() { [ -z "\$LOCKFILE" ] &amp;&amp; return if isStarted; then touch \$LOCKFILE else rm -f \$LOCKFILE fi } RETVAL=0 case \$1 in start) v_startIt ;; stop) v_stopIt ;; force-reload|restart) v_restartIt ;; try-restart) isStarted &amp;&amp; v_restartIt ;; status) v_showStatus ;; *) echo "Usage: \$0 {start|stop|restart|try-restart|force-reload|status}" RETVAL=1 ;; esac updateLock exit \$RETVAL EOF } getCommonStartupScriptContents_autodl() { local USER="$1" local STARTUPNAME="$2" cat &lt;&lt; EOF NAME=$STARTUPNAME USER=$USER SESSIONNAME=autodl resetPath() { PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\$PATH" } resetPath # Make sure the path is correct, and make sure we&#39;re in the home dir. USER_INIT="umask $DEFAULT_UMASK; cd; PATH=\\\$PATH:\$PATH" # Run user command, ignoring any messages sent to stdout (eg. &#39;No mail.&#39;) runUserCmd() { su - \$USER -c "\$USER_INIT; \$1" &gt;/dev/null &amp;&amp; return 0 return 1 } isStarted() { su - \$USER -c "\$USER_INIT; screen -ls | grep -qE \\"[ ][0-9]+\\\\.\$SESSIONNAME[ ]\\"" &gt;/dev/null &amp;&amp; return 0 return 1 } startIt() { isStarted &amp;&amp; return 0 local START_IRSSI=n local START_RTORRENT=n which irssi &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_IRSSI=y which rtorrent &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_RTORRENT=y case \$START_IRSSI\$START_RTORRENT in yy) runUserCmd "screen -S \$SESSIONNAME -d -t rtorrent -m rtorrent" runUserCmd "screen -d -r \$SESSIONNAME -X screen -t irssi irssi" ;; yn) runUserCmd "screen -S \$SESSIONNAME -d -t irssi -m irssi" ;; ny) runUserCmd "screen -S \$SESSIONNAME -d -t rtorrent -m rtorrent" ;; nn) ;; esac return 0 } stopIt() { isStarted || return 0 runUserCmd "screen -d -r \$SESSIONNAME -p irssi -X stuff \\"/quit /quit \\"" runUserCmd "screen -d -r \$SESSIONNAME -p rtorrent -X xon" for i in 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4; do isStarted || break sleep 1 done # If it&#39;s still not stopped, kill the whole screen session if isStarted; then echo -n "Couldn&#39;t stop it. Killing screen session..." runUserCmd "screen -d -r \$SESSIONNAME -p rtorrent -X xon" sleep 2 runUserCmd "screen -d -r \$SESSIONNAME -X quit" echo "Done." fi return 0 } v_restartIt() { v_stopIt v_startIt } v_showStatus() { if isStarted; then echo "\$NAME is running." else echo "\$NAME is stopped." fi } EOF } getChkconfigScriptContents_autodl() { getChkconfigScriptContents "$AUTODL_STARTUP_DESC" } # LSB style script, also supports chkconfig # $1 = user name # $2 = service name getLsbStartupHeader_autodl() { local USER="$1" local STARTUPNAME="$2" cat &lt;&lt; EOF $(getChkconfigScriptContents_autodl) $(getLsbStartupScriptContents "$STARTUPNAME" "$AUTODL_STARTUP_DESC") $(getCommonStartupScriptContents_autodl "$USER" "$STARTUPNAME") EOF } installService_mandriva() { local serviceName="$1" local headerCommand="$2" installService_chkconfig1 $serviceName cat &gt; "$CHKCONFIG_SERVICE_FILE" &lt;&lt; EOF #!/bin/bash $(eval $headerCommand) . /etc/rc.d/init.d/functions v_startIt() { gprintf "Starting %s:" "\$NAME" startIt &amp;&amp; success "startup" || failure "startup" echo } v_stopIt() { gprintf "Stopping %s:" "\$NAME" stopIt &amp;&amp; success "stop" || failure "stop" echo } $(getLsbStartupFooter "$CHKCONFIG_LOCK_FILE") EOF [ $? -eq 0 ] || errorExit "Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root." installService_chkconfig2 } installService_mandriva_autodl() { local user=$1 installService_mandriva autodl_$user "getLsbStartupHeader_autodl \"$user\" \"\$CHKCONFIG_SERVICE_NAME\"" } installService_mandriva_phpcgi() { installService_mandriva phpcgi getLsbStartupHeader_phpcgi } installService_mandriva_nginx() { installService_mandriva nginx getLsbStartupHeader_nginx } installService_mandriva_lighttpd() { installService_mandriva lighttpd getLsbStartupHeader_lighttpd } installService_gentoo() { local scriptName="$1" local desc="$2" local headerCommand="$3" local serviceFile="/etc/init.d/$scriptName" cat &gt; "$serviceFile" &lt;&lt; EOF #!/sbin/runscript name=$scriptName description="$desc" depend() { need localmount need net } $(eval $headerCommand) start() { ebegin "Starting \$name" startIt eend \$? } stop() { ebegin "Stopping \$name" stopIt eend \$? } status() { if isStarted; then einfo "status: started" return 0 else einfo "status: stopped" return 1 fi } EOF [ $? -eq 0 ] || errorExit "Could not write to file $serviceFile. Run this script as root." chmod +x "$serviceFile" rc-update add $scriptName default || errorExit "Could not add service $scriptName" $serviceFile restart } installService_gentoo_autodl() { local user="$1" installService_gentoo autodl_$user "$AUTODL_STARTUP_DESC" "getCommonStartupScriptContents_autodl \"$user\" \"\$scriptName\"" } installService_gentoo_phpcgi() { installService_gentoo phpcgi "$PHPCGI_STARTUP_DESC" "getCommonStartupScriptContents_phpcgi \"$WWW_USER\" \"$WWW_PHP_CGI\"" } installService_gentoo_nginx() { installService_gentoo nginx "$NGINX_STARTUP_DESC" "getCommonStartupScriptContents_nginx \"$NGINX_BIN\"" } installService_gentoo_lighttpd() { installService_gentoo lighttpd "$LIGHTTPD_STARTUP_DESC" "getCommonStartupScriptContents_lighttpd \"$LIGHTTPD_BIN\"" } installService_bsd_autodl() { local user="$1" local scriptName="$2" local file="$3" cat &gt; "$file" &lt;&lt; EOF #!/bin/sh # PROVIDE: autodl_$user # REQUIRE: FILESYSTEMS NETWORKING # KEYWORD: shutdown . /etc/rc.subr name=$scriptName desc="$AUTODL_STARTUP_DESC" start_cmd=v_startIt stop_cmd=v_stopIt restart_cmd=v_restartIt reload_cmd=v_restartIt status_cmd=v_showStatus extra_commands="status" v_startIt() { echo -n "Starting \$NAME" startIt &amp;&amp; echo "." || echo ". ERROR." } v_stopIt() { echo -n "Stopping \$NAME..." stopIt &amp;&amp; echo "done." || echo "ERROR." } $(getCommonStartupScriptContents_autodl "$user" "$scriptName") load_rc_config \$name run_rc_command "\$1" EOF [ $? -eq 0 ] || errorExit "Could not write to file $file. Run this script as root." chmod +x "$file" } getCommonStartupScriptContents_simpleService() { local USER="$1" local BINPATH="$2" local START_CMD="$3" local PID_FILE="$4" cat &lt;&lt; EOF USER=$USER BINPATH="$BINPATH" NAME=\${BINPATH##*/} PID_FILE="$PID_FILE" resetPath() { PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\$PATH" } resetPath getPids() { if [ -n "\$PID_FILE" ]; then pids= [ -f "\$PID_FILE" ] || return local the_pids="\$(cat "\$PID_FILE" 2&gt;/dev/null)" for pid in \$the_pids; do PS_FORMAT= LINES= COLUMNS= ps ax | grep -qE "^[ ]*\$pid[ ]" &amp;&amp; pids="\$pids \$pid" done [ -z "\$pids" ] &amp;&amp; rm -f "\$PID_FILE" else # ps uses the COLUMNS variable... Make sure it&#39;s off so we get the full path. pids=\$(PS_FORMAT= LINES= COLUMNS= ps aux | grep -v grep | grep \$BINPATH | awk &#39;{print \$2}&#39;) fi } isStarted() { getPids [ -n "\$pids" ] &amp;&amp; return 0 return 1 } startIt() { isStarted &amp;&amp; return 0 if [ \$USER = root ]; then $START_CMD else su - \$USER "-c $START_CMD" fi [ -n "\$PID_FILE" ] &amp;&amp; sleep 2 # Allow it some time to create the pid file if ! isStarted; then for i in 1 2 3 4 5; do sleep 1 isStarted &amp;&amp; break done isStarted || return 1 fi return 0 } stopIt() { isStarted || return 0 kill \$pids 2&gt;/dev/null for i in 0 1 2 3 4 5 6 7 8 9; do isStarted || break sleep 1 done isStarted &amp;&amp; kill -KILL \$pids 2&gt;/dev/null return 0 } v_startIt() { startIt } v_stopIt() { stopIt } v_restartIt() { v_stopIt v_startIt } v_showStatus() { if isStarted; then echo "\$NAME is running." else echo "\$NAME is stopped." fi } EOF } getCommonStartupScriptContents_phpcgi() { [ -n "$PHPCGI_SOCKET_FILE" ] || errorExit "PHPCGI_SOCKET_FILE is not initialized" getCommonStartupScriptContents_simpleService "$1" "$2" \ "PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 \$BINPATH -q -b \"$PHPCGI_SOCKET_FILE\" &amp;" } getLsbStartupHeader_phpcgi() { getChkconfigScriptContents "$PHPCGI_STARTUP_DESC" getLsbStartupScriptContents phpcgi "$PHPCGI_STARTUP_DESC" getCommonStartupScriptContents_phpcgi "$WWW_USER" "$WWW_PHP_CGI" } getCommonStartupScriptContents_nginx() { getCommonStartupScriptContents_simpleService "root" "$1" "\$BINPATH" "$NGINX_PID_FILE" } getLsbStartupHeader_nginx() { getChkconfigScriptContents "$NGINX_STARTUP_DESC" getLsbStartupScriptContents nginx "$NGINX_STARTUP_DESC" getCommonStartupScriptContents_nginx "$NGINX_BIN" } getCommonStartupScriptContents_lighttpd() { getCommonStartupScriptContents_simpleService "root" "$1" "\$BINPATH -f $LIGHTTPD_CONF 2&gt;/dev/null" "$LIGHTTPD_PID_FILE" } getLsbStartupHeader_lighttpd() { getChkconfigScriptContents "$LIGHTTPD_STARTUP_DESC" getLsbStartupScriptContents lighttpd "$LIGHTTPD_STARTUP_DESC" getCommonStartupScriptContents_lighttpd "$LIGHTTPD_BIN" } addLsbHeaderToStartupScript() { local scriptPath="$1" local provides="${2:-$scriptPath}" local desc="${3:-$provides}" [ -x "$scriptPath" ] || return grep -qE &#39;^### BEGIN INIT INFO&#39; "$scriptPath" &amp;&amp; return ed -s "$scriptPath" &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF 1a $(getLsbStartupScriptContents "$provides" "$desc") . w q EOF } installMissingPerlModules() { detectMissingPerlModules [ -z "$MISSING_PERL_MODULES" ] &amp;&amp; return cat &lt;&lt; EOF $CWARNING The following Perl modules are still missing: $MISSING_PERL_MODULES I&#39;ll try to use the cpan script to install them.$CEND EOF # Some Perl modules will fail to build unless Test::More is installed MISSING_PERL_MODULES="Test::More $MISSING_PERL_MODULES" echo "${CMSG}Installing cpan and required build tools...$CEND" installBuildTools osHandler_$os installCpanTools detectCpanBin if [ -n "$CPAN" ]; then $CPAN $MISSING_PERL_MODULES else local mods= for mod in $MISSING_PERL_MODULES; do [ -n "$mods" ] &amp;&amp; mods="$mods," mods="$mods \"$mod\"" done perl -MCPAN -e "CPAN::Shell-&gt;install($mods)" fi detectMissingPerlModules [ -z "$MISSING_PERL_MODULES" ] &amp;&amp; return errorExit "CPAN somehow failed to install the missing Perl modules. Missing: $MISSING_PERL_MODULES" } osHandler_debian() { case $1 in init) INSTALL="apt-get -y install" FEATURES="service rtorrent apache nginx lighttpd vsftpd webmin" BUILD_TOOLS="build-essential make file pkg-config libtool m4" ;; init2) apt-get update installProgram ed # Make sure Debian 6 doesn&#39;t fail when adding new services. We need ed for this # so run it after installing ed... addLsbHeaderToStartupScript /etc/init.d/webmin "webmin" "webmin" ;; installTools) PACKAGES= addProgram irssi addProgram mediainfo addProgram git-core addProgram svn subversion addProgram wget addProgram unzip addProgram screen installPackages # Make sure subversion won&#39;t complain about invalid certs $INSTALL ca-certificates ;; installAutodlTools) PACKAGES= addProgram perl addPerlModule Archive::Zip libarchive-zip-perl addPerlModule HTML::Parser libhtml-parser-perl addPerlModule Digest::SHA1 libdigest-sha-perl installPackages installPerlModule Net::SSLeay libnet-ssleay-perl installPerlModule XML::LibXML libxml-libxml-perl installPerlModule JSON::XS libjson-xs-perl installPerlModule JSON libjson-perl ;; installCpanTools) # Need to remove the old JSON or cpan may fail to build the modules if echo "$OLD_PERL_MODULES" | grep -qE &#39;(^| )JSON( |$)&#39;; then apt-get -y remove libjson-perl fi PACKAGES= if echo "$MISSING_PERL_MODULES" | grep -q &#39;XML::LibXML&#39;; then PACKAGES="$PACKAGES libxml2 libxml2-dev zlib1g zlib1g-dev" fi if echo "$MISSING_PERL_MODULES" | grep -q &#39;Net::SSLeay&#39;; then # There&#39;s no libssl package PACKAGES="$PACKAGES openssl libssl-dev zlib1g zlib1g-dev" fi installPackages ;; installRtorrentBuildTools) PACKAGES="libsigc++-2.0-dev libssl-dev libncurses-dev" if apt-cache search libcurl4-openssl-dev 2&gt; /dev/null | grep -q &#39;libcurl4-openssl-dev&#39;; then PACKAGES="$PACKAGES libcurl4-openssl-dev" else PACKAGES="$PACKAGES libcurl3-openssl-dev" fi installPackages ;; installPhpModules) installMissingPhp5Packages ;; _installService) local serviceName="$2" local headerCommand="$3" local serviceFile=/etc/init.d/$serviceName local lockFile= cat &gt; "$serviceFile" &lt;&lt; EOF #!/bin/sh $(eval $headerCommand) . /lib/lsb/init-functions v_startIt() { log_begin_msg "Starting \$NAME..." startIt log_end_msg \$? } v_stopIt() { log_begin_msg "Stopping \$NAME..." stopIt log_end_msg \$? } $(getLsbStartupFooter "$lockFile") EOF [ $? -eq 0 ] || errorExit "Could not write to file $serviceFile. Run this script as root." chmod +x "$serviceFile" || errorExit "Could not set +x bit, file $serviceFile." update-rc.d $serviceName defaults || errorExit "Could not install service $serviceFile. Run this script as root." invoke-rc.d $serviceName restart ;; installAutodlService) local user=$2 osHandler_$os _installService autodl_$user "getLsbStartupHeader_autodl \"$user\" \"\$serviceName\"" ;; _installCommonWebServerStuff) # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="php5-cli gzip curl openssl logrotate" installPackages # Ubuntu 8 doesn&#39;t have php5-geoip PACKAGES="php5-geoip" installPackages PACKAGES="unrar" installPackages ;; installApache) osHandler_$os _installCommonWebServerStuff PACKAGES="apache2-mpm-prefork libapache2-mod-php5 php5 " installPackages PACKAGES="libapache2-mod-scgi"; installPackages WWW_PHP_INI=/etc/php5/apache2/php.ini APACHE_DIR=/etc/apache2 APACHE_SITE_NAME=rutorrent.conf APACHE_SCGI_FILE=$APACHE_DIR/mods-available/scgi.load initializeApacheVars www-data www-data "$APACHE_DIR/sites-available" apacheCommonInitialization "apache2-prefork-dev" /usr/lib/apache2/modules a2enmod ssl || errorExit "Could not enable mod_ssl" a2enmod scgi || errorExit "Could not enable mod_scgi" # Ubuntu Server 6 doesn&#39;t come with this module a2enmod auth_basic a2dissite default a2dissite default-ssl a2ensite $APACHE_SITE_NAME || errorExit "Could not enable site" if ! grep -qE "^[ ]*Listen.*[: ]$HTTPS_PORT\\&gt;" "$APACHE_DIR/ports.conf"; then echo "Listen $HTTPS_PORT" &gt;&gt; "$APACHE_DIR/ports.conf" fi resetWebServerPermissions invoke-rc.d apache2 restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; restart_apache) invoke-rc.d apache2 restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; installVsftpd) installProgram vsftpd updateVsftpdConf /etc/vsftpd.conf invoke-rc.d vsftpd restart || errorExit "Could not restart vsftpd" ;; preNginxInstall) WWW_PHP_INI=/etc/php5/cgi/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="libpcre3-dev libssl-dev zlib1g-dev php5-cgi" installPackages # Make sure it builds on Debian GNU/kFreeBSD 6.0. if [ "$(uname -s)" != Linux ]; then NGINX_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64" fi ;; installPhpCgiService) osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi ;; installNginxService) osHandler_$os _installService nginx getLsbStartupHeader_nginx ;; restart_nginx) invoke-rc.d phpcgi restart || errorExit "Could not start php-cgi" invoke-rc.d nginx restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; preLighttpdInstall) WWW_PHP_INI=/etc/php5/cgi/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="libpcre3-dev libssl-dev zlib1g-dev php5-cgi" installPackages ;; installLighttpdService) osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd ;; restart_lighttpd) invoke-rc.d phpcgi restart || errorExit "Could not start php-cgi" invoke-rc.d lighttpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; postWebminInstall) addLsbHeaderToStartupScript /etc/init.d/webmin "webmin" "webmin" ;; *) ;; esac } osHandler_fedora() { case $1 in init) INSTALL="yum -y install" FEATURES="service rtorrent apache nginx lighttpd vsftpd webmin" BUILD_TOOLS="gcc gcc-c++ make kernel-headers pkgconfig file libtool m4" ;; init2) installProgram which installProgram ed ;; installTools) PACKAGES= addProgram svn subversion addProgram wget addProgram unzip addProgram screen addProgram git installPackages ;; installAutodlTools) if grep -q "release 4[. ]" /etc/redhat-release; then IRSSI_LOAD_PERL=y fi PACKAGES= addProgram perl addProgram irssi addPerlModule Time::HiRes perl-Time-HiRes addPerlModule Archive::Zip perl-Archive-Zip addPerlModule Net::SSLeay perl-Net-SSLeay addPerlModule HTML::Parser perl-HTML-Parser addPerlModule XML::LibXML perl-XML-LibXML addPerlModule Digest::SHA1 perl-Digest-SHA1 addPerlModule JSON::XS perl-JSON-XS addPerlModule JSON perl-JSON installPackages ;; installCpanTools) # Need to remove the old JSON or cpan may fail to build the modules if echo "$OLD_PERL_MODULES" | grep -qE &#39;(^| )JSON( |$)&#39;; then yum -y remove perl-JSON fi # CentOS doesn&#39;t have &#39;perl-CPAN&#39;. It&#39;s in the &#39;perl&#39; package though. PACKAGES="perl-CPAN" if echo "$MISSING_PERL_MODULES" | grep -q &#39;XML::LibXML&#39;; then PACKAGES="$PACKAGES libxml2 libxml2-devel zlib zlib-devel" fi if echo "$MISSING_PERL_MODULES" | grep -q &#39;Net::SSLeay&#39;; then PACKAGES="$PACKAGES openssl openssl-devel zlib zlib-devel" fi installPackages ;; installRtorrentBuildTools) # CentOS 5: curl-devel, no libsigc++20 # Fedora 14: libcurl-devel PACKAGES="libsigc++20-devel ncurses-devel openssl-devel libcurl-devel curl-devel" installPackages ;; installPhpModules) ;; _installService) local serviceName="$2" local headerCommand="$3" installService_chkconfig1 $serviceName cat &gt; "$CHKCONFIG_SERVICE_FILE" &lt;&lt; EOF #!/bin/bash $(eval $headerCommand) . /etc/rc.d/init.d/functions v_startIt() { echo -n "Starting \$NAME: " startIt &amp;&amp; success || failure echo } v_stopIt() { echo -n "Stopping \$NAME: " stopIt &amp;&amp; success || failure echo } $(getLsbStartupFooter "$CHKCONFIG_LOCK_FILE") EOF [ $? -eq 0 ] || errorExit "Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root." installService_chkconfig2 ;; installAutodlService) local user=$2 osHandler_$os _installService autodl_$user "getLsbStartupHeader_autodl \"$user\" \"\$CHKCONFIG_SERVICE_NAME\"" ;; _installCommonWebServerStuff) PACKAGE="php-cli gzip curl openssl unrar logrotate" installPackages # CentOS 4: will get an error about a php v4 dependency, so can&#39;t put it in above PACKAGE var PACKAGES="php-pecl-geoip" installPackages ;; installApache) osHandler_$os _installCommonWebServerStuff # Also add some extra tools for ruTorrent and some of its plugins PACKAGES="httpd httpd-tools mod_ssl mod_scgi php" installPackages WWW_PHP_INI=/etc/php.ini APACHE_DIR=/etc/httpd local APACHE_CONF_D=$APACHE_DIR/conf.d APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf initializeApacheVars apache apache "$APACHE_CONF_D" apacheCommonInitialization "httpd-devel" $APACHE_DIR/modules [ -f "$APACHE_CONF_D/welcome.conf" ] &amp;&amp; mv -f "$APACHE_CONF_D/welcome.conf" "$APACHE_CONF_D/welcome.conf-bak" # Remove an Apache warning by commenting out the default SSL VirtualHost sed_i &#39;/^&lt;VirtualHost _default_:443&gt;/,/^&lt;\/VirtualHost&gt;/s/^/#/&#39; $APACHE_CONF_D/ssl.conf resetWebServerPermissions chkconfig httpd on service httpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; restart_apache) service httpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; installVsftpd) installVsftpd_chkconfig /etc/vsftpd/vsftpd.conf ;; preNginxInstall) WWW_PHP_INI=/etc/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="pcre-devel openssl-devel zlib-devel php-cgi" installPackages ;; installPhpCgiService) osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi ;; installNginxService) osHandler_$os _installService nginx getLsbStartupHeader_nginx ;; restart_nginx) service phpcgi restart || errorExit "Could not start php-cgi" service nginx restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; preLighttpdInstall) WWW_PHP_INI=/etc/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES="pcre-devel openssl-devel zlib-devel php-cgi" installPackages ;; installLighttpdService) osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd ;; restart_lighttpd) service phpcgi restart || errorExit "Could not start php-cgi" service lighttpd restart || errorExit "Could not start $INSTALL_WEB_SERVER" ;; *) ;; esac } isWebServerRpcModule() { ! arrayIsPresent rpc $RUTORRENT_PLUGINS &amp;&amp; ! arrayIsPresent httprpc $RUTORRENT_PLUGINS &amp;&amp; return 0 return 1 } canInstallService() { return $(arrayIsPresent service $FEATURES) } canInstallRtorrent() { return $(arrayIsPresent rtorrent $FEATURES) } canInstallApache() { return $(arrayIsPresent apache $FEATURES) } canInstallNginx() { return $(arrayIsPresent nginx $FEATURES) } canInstallLighttpd() { return $(arrayIsPresent lighttpd $FEATURES) } canInstallVsftpd() { return $(arrayIsPresent vsftpd $FEATURES) } canInstallWebmin() { return $(arrayIsPresent webmin $FEATURES) } getRequiredPrograms() { REQUIRED_PROGRAMS="which svn wget unzip ed sed grep tar expr ps awk kill printf" if [ "$INSTALL_AUTODL_IRSSI" = y ]; then REQUIRED_PROGRAMS="$REQUIRED_PROGRAMS perl" # NetBSD and DragonFly BSD don&#39;t compile Irssi with Perl support by default [ "$IGNORE_IRSSI" != y ] &amp;&amp; REQUIRED_PROGRAMS="$REQUIRED_PROGRAMS irssi" fi } verifyInstalledPrograms() { getRequiredPrograms local MISSING_PROGRAMS= for prog in $REQUIRED_PROGRAMS; do local name=$prog [ "$prog" = svn ] &amp;&amp; name=subversion isProgramInstalled "$prog" || MISSING_PROGRAMS="$MISSING_PROGRAMS $name" done [ -n "$MISSING_PROGRAMS" ] &amp;&amp; errorExit "Can&#39;t continue. The following programs are not installed: $MISSING_PROGRAMS" } initPluginDirVar() { AUTODL_IRSSI_PLUGIN_DIR="$RUTORRENT_BASE_PATH/plugins/autodl-irssi" } getRtorrentDirs() { local user="$1" getUserDir "$user" RTORRENT_DOWNLOAD_DIR="$userDir/$RTORRENT_REL_DOWNLOAD_DIR" RTORRENT_WATCH_DIR="$userDir/$RTORRENT_REL_WATCH_DIR" RTORRENT_SESSION_DIR="$userDir/$RTORRENT_REL_SESSION_DIR" } getUserScgiSocketPath() { local user="$1" getRtorrentDirs "$user" scgiSocketPath="$RTORRENT_SESSION_DIR/rpc.socket" } waitenter() { local msg="${1-Press ENTER to continue...}" echo -n "$CCYAN$msg$CEND" read dummy } askQuestion() { local question="$1" local default="$2" if [ -z "$default" ]; then echo -n "$CQUESTION$question$CEND " read answer else echo -n "$CQUESTION$question$CEND [$CGREEN$default$CEND] " read answer fi if [ -z "$answer" ]; then answer="$default" fi } # Asks the user a question, and sets answer to y or n depending on the user&#39;s answer askYesNo() { local question="$1" local default="$2" while true; do askQuestion "$question" "$default" if echo "$answer" | grep -qiE &#39;^y(es)?$&#39;; then answer=y return 1 elif echo "$answer" | grep -qiE &#39;^no?$&#39;; then answer=n return 0 fi done } askOsUser() { local stopIfEmpty=${1:-n} local user= while true; do askQuestion "Enter name of user:" "" user="$answer" [ -z "$user" ] &amp;&amp; [ "$stopIfEmpty" = y ] &amp;&amp; break userExists "$user" &amp;&amp; break echo "${CWARNING}User $user does not exist.$CEND" askYesNo "Do you want to create user $user?" "No" [ "$answer" = n ] &amp;&amp; continue echo "${CMSG}Creating user $user.$CEND" if ! useradd -m -s /bin/sh "$user"; then echo "${CWARNING}Could not create user $user.$CEND" continue fi echo "${CMSG}Enter the user&#39;s password:$CEND" if ! passwd "$user"; then echo "${CWARNING}Failed to set password.$CEND" continue fi userExists "$user" &amp;&amp; break done answer="$user" } # Adds another user to USERS addUser() { local osUser="$1" local webUser="$2" local autodlPassword= local webpass= if [ "$INSTALL_RUTORRENT" = y ] || [ "$USE_RUTORRENT_PLUGIN" = y ]; then if ! canGeneratePasswords; then cat &lt;&lt; EOF $CQUESTION The password makes sure only you can change your autodl-irssi settings. This is NOT your login password. Use any password, but each user should use a unique password. The password is used by the PHP code to access autodl-irssi settings. You don&#39;t need to remember this password. It can&#39;t contain any spaces or a colon &#39;:&#39;.$CEND EOF while true; do askQuestion "Enter the autodl-irssi password (this is not your login password):" "" autodlPassword="$answer" isValidPassword "$autodlPassword" &amp;&amp; break echo "${CWARNING}Invalid password. Try again.$CEND" done fi if [ "$RUTORRENT_PASSWORD_PROTECTED" = y ]; then while true; do askQuestion "Enter your ruTorrent password:" "" webpass="$answer" isValidPassword "$webpass" &amp;&amp; break echo "${CWARNING}Invalid password. Try again.$CEND" done fi USERS="$USERS $osUser:$autodlPassword:$webUser:$webpass" else USERS="$USERS $osUser" fi } installUser() { local userPluginDir="$1" local osUser="$2" local webUser="${3:-$osUser}" local port="$4" local autodlPassword="$5" getUserGroup "$osUser" getUserDir "$osUser" cat &lt;&lt; EOF ========================= ${CGREEN}Installing autodl-irssi$CEND ========================= Use the ruTorrent plugin: $CGREEN$USE_RUTORRENT_PLUGIN$CEND OS user: $CGREEN$osUser$CEND EOF if [ "$USE_RUTORRENT_PLUGIN" = y ]; then [ "$RUTORRENT_PASSWORD_PROTECTED" = y ] &amp;&amp; echo "ruTorrent user: $CGREEN$webUser$CEND" echo "port: $CGREEN$port$CEND" echo "password: $CGREEN$autodlPassword$CEND" fi cat &lt;&lt; EOF group: $CGREEN$group$CEND home: $CGREEN$userDir$CEND EOF if [ "$USE_RUTORRENT_PLUGIN" = y ]; then isValidPortNumber "$port" || errorExit "Invalid port number: $port" isValidPassword "$autodlPassword" || errorExit "Invalid password: $autodlPassword" isValidWebUser "$webUser" || errorExit "Invalid web user: $webUser" fi mkdir -p "$userDir/.irssi/scripts/autorun" cd "$userDir/.irssi/scripts" || errorExit "Could not CD into user dir. Run the script as root." echo "${CMSG}Downloading autodl-irssi.zip...$CEND" if ! downloadFile autodl-irssi.zip "$AUTODL_IRSSI_ZIP_URL"; then errorExit "Could not download autodl-irssi zip file" fi echo "${CMSG}Unpacking autodl-irssi...$CEND" unzip -o autodl-irssi.zip &gt; /dev/null || errorExit "Could not unpack autodl-irssi zip file" rm -f autodl-irssi.zip cp autodl-irssi.pl autorun/ || errorExit "Could not copy autodl-irssi.pl to Irssi autorun dir." mkdir -p "$userDir/.autodl" touch "$userDir/.autodl/autodl.cfg" if ! [ -s "$userDir/.autodl/autodl.cfg" ]; then [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; cat &gt; "$userDir/.autodl/autodl.cfg" &lt;&lt; EOF [options] upload-type = rtorrent EOF fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if [ ! -d "$AUTODL_IRSSI_PLUGIN_DIR" ]; then errorExit "The autodl-irssi ruTorrent plugin has not been installed. Install it." fi cat &gt; "$userDir/.autodl/autodl2.cfg" &lt;&lt; EOF [options] gui-server-port = $port gui-server-password = $autodlPassword EOF rm -f "$AUTODL_IRSSI_PLUGIN_DIR/conf.php" mkdir -p "$userPluginDir" cat &gt; "$userPluginDir/conf.php" &lt;&lt; EOF &lt;?php \$autodlPort = $port; \$autodlPassword = "$autodlPassword"; ?&gt; EOF [ $? -eq 0 ] || errorExit "Could not write to $userPluginDir/conf.php. Run this script as root." # Only set perms to 0400 if the code knows the owner (web server owner) and will reset it [ "$ISROOT" = y ] &amp;&amp; [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; chmod 0400 "$userPluginDir/conf.php" else # Don&#39;t use the autodl-irssi ruTorrent plugin : &gt; "$userDir/.autodl/autodl2.cfg" fi # The Perl module isn&#39;t loaded by default if [ "$IRSSI_LOAD_PERL" = y ]; then if [ ! -f "$userDir/.irssi/startup" ] || ! grep -q &#39;load perl&#39; "$userDir/.irssi/startup"; then echo "load perl" &gt;&gt; "$userDir/.irssi/startup" fi fi # Make sure we redownload the tracker files since the ones in the zip file are possibly # old versions. local autodlStateFile="$userDir/.autodl/AutodlState.xml" [ -f "$autodlStateFile" ] &amp;&amp; sed_i &#39;g/&lt;trackers-version&gt;/d&#39; "$autodlStateFile" resetOwner "$osUser" "$userDir/.autodl" "$userDir/.irssi" chmod 0700 "$userDir/.autodl" "$userDir/.irssi" } getRutorrentUserConfDir() { userConfDir="$RUTORRENT_BASE_PATH/conf/users/$webUser" } getRutorrentUserShareDir() { userShareDir="$RUTORRENT_BASE_PATH/share/users/$webUser" } resetRutorrentUserPermissions() { for packedUser in $USERS; do extractPackedUser $packedUser getRutorrentUserConfDir getRutorrentUserShareDir # Make sure only the web server and the user itself can access its share/conf dirs chown $osUser:$WWW_GROUP "$userShareDir" "$userConfDir" chmod 0770 "$userShareDir" "$userConfDir" done } ############################################################################ # # This is where we start # ############################################################################ SELINUX_ENABLED=n isProgramInstalled selinuxenabled &amp;&amp; selinuxenabled &amp;&amp; SELINUX_ENABLED=y echo "SELinux enabled: $SELINUX_ENABLED" ISROOT=n [ $(id -u) -eq 0 ] &amp;&amp; ISROOT=y echo "Is root user: $ISROOT" if [ $# -gt 0 ]; then parseCommandLine "$@" INTERACTIVE=n else INTERACTIVE=y fi detectOs cat &lt;&lt; EOF Detected OS: $CGREEN$os_long$CEND Type: $CGREEN$os$CEND Type sh $0 --help for all command line options. EOF osHandler_$os init if [ "$INTERACTIVE" = y ]; then if [ "$ISROOT" = n ]; then cat &lt;&lt; EOF $CRED You&#39;re not the root user! This install script may fail if you&#39;re not the root user. To start it as the root user do one of the following: Ubuntu and Ubuntu clones: ${CGREEN}sudo sh $0$CRED Any other OS: ${CGREEN}su sh $0$CRED $CEND EOF waitenter "Press Ctrl+C to exit or ENTER to continue..." fi cat &lt;&lt; EOF $CMSG Press ENTER to use the default answer in [brackets].$CEND EOF webServers= canInstallLighttpd &amp;&amp; webServers="$webServers lighttpd" canInstallNginx &amp;&amp; webServers="$webServers nginx" canInstallApache &amp;&amp; webServers="$webServers apache" if [ -n "$webServers" ]; then cat &lt;&lt; EOF $CQUESTION If you want to install ruTorrent you must install a web server, eg. Apache. If you&#39;ve already installed another web server, you must first uninstall it or disable it. List of supported web servers:$CEND EOF canInstallLighttpd &amp;&amp; echo " ${CGREEN}lighttpd$CEND ${CQUESTION}lighttpd web server (lightweight)$CEND" canInstallNginx &amp;&amp; echo " ${CGREEN}nginx$CEND ${CQUESTION}nginx web server (lightweight)$CEND" canInstallApache &amp;&amp; echo " ${CGREEN}apache$CEND ${CQUESTION}Apache web server$CEND" echo " ${CGREEN}none$CEND ${CQUESTION}Don&#39;t install a web server$CEND" while true; do INSTALL_WEB_SERVER= echo "${CQUESTION}Select one of:$CGREEN$webServers none$CEND" askQuestion "Enter name of web server" "$(getFirst $webServers)" [ "$answer" = none ] &amp;&amp; break INSTALL_WEB_SERVER="$answer" arrayIsPresent $INSTALL_WEB_SERVER $webServers &amp;&amp; break done if [ -n "$INSTALL_WEB_SERVER" ]; then askYesNo "Do you want to install ruTorrent?" "Yes" INSTALL_RUTORRENT="$answer" else INSTALL_RUTORRENT=n fi fi if canInstallRtorrent; then cat &lt;&lt; EOF $CQUESTION ruTorrent requires a working rtorrent built with XML-RPC support.$CEND EOF askYesNo "Do you want to build rtorrent?" "Yes" BUILD_RTORRENT="$answer" fi askYesNo "Do you want to install the autodl-irssi ruTorrent plugin?" "Yes" USE_RUTORRENT_PLUGIN="$answer" if [ "$INSTALL_RUTORRENT" = y ]; then REINSTALL_RUTORRENT_PLUGIN=n RUTORRENT_PASSWORD_PROTECTED=y elif [ "$USE_RUTORRENT_PLUGIN" = y ]; then echo "" while true; do echo "${CQUESTION}The ruTorrent www base path is where you installed ruTorrent.$CEND" askQuestion "What is the ruTorrent www base path, eg. /var/www/rutorrent:" "" RUTORRENT_BASE_PATH="$answer" isValidRutorrentBasePath "$RUTORRENT_BASE_PATH" &amp;&amp; break echo "$CWARNING$RUTORRENT_BASE_PATH is not the ruTorrent base path.$CEND" done initPluginDirVar if [ -d "$AUTODL_IRSSI_PLUGIN_DIR" ]; then echo "" askYesNo "The autodl-irssi ruTorrent plugin seems to be installed. Do you want to re-install it?" "No" REINSTALL_RUTORRENT_PLUGIN="$answer" else REINSTALL_RUTORRENT_PLUGIN=n fi cat &lt;&lt; EOF $CQUESTION To use more than one ruTorrent user, you must password protect ruTorrent.$CEND EOF askYesNo "Is ruTorrent password protected?" "No" RUTORRENT_PASSWORD_PROTECTED="$answer" else RUTORRENT_PASSWORD_PROTECTED=n fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then INSTALL_AUTODL_IRSSI=y else askYesNo "Do you want to install autodl-irssi?" "Yes" INSTALL_AUTODL_IRSSI="$answer" fi if canInstallService &amp;&amp; ([ "$INSTALL_AUTODL_IRSSI" = y ] || [ "$INSTALL_RUTORRENT" = y ]); then cat &lt;&lt; EOF $CQUESTION If you want to automatically start Irssi and rtorrent when the computer boots, install the startup script.$CEND EOF askYesNo "Do you want to install the startup script?" "Yes" INSTALL_STARTUP_SCRIPT="$answer" fi askUser=n if [ "$USE_RUTORRENT_PLUGIN" = y ] || [ "$INSTALL_AUTODL_IRSSI" = y ] || \ [ "$INSTALL_STARTUP_SCRIPT" = y ] || [ "$INSTALL_RUTORRENT" = y ]; then askUser=y fi if [ "$askUser" = y ]; then if [ "$RUTORRENT_PASSWORD_PROTECTED" = n ]; then cat &lt;&lt; EOF $CQUESTION This is the user running rtorrent and/or Irssi.$CEND ${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND EOF askOsUser addUser "$answer" "" else while true; do cat &lt;&lt; EOF $CQUESTION ===================== USER ===================== This is the user running rtorrent and/or Irssi. ${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND ${CCYAN}Press ENTER to stop adding users.$CEND EOF askOsUser y osUser="$answer" [ -z "$osUser" ] &amp;&amp; break while true; do cat &lt;&lt; EOF $CQUESTION The ruTorrent user is the name you use to log in to ruTorrent.$CEND EOF askQuestion "Enter ruTorrent user:" "$osUser" webUser="$answer" isValidWebUser "$webUser" &amp;&amp; break echo "${CWARNING}Invalid web user name &#39;$webUser&#39;. Use only lower case letters." done addUser "$osUser" "$webUser" done fi fi if canInstallVsftpd; then cat &lt;&lt; EOF $CQUESTION vsftpd is a very secure FTP daemon.$CEND EOF askYesNo "Do you want to install vsftpd?" "Yes" INSTALL_VSFTPD="$answer" if [ "$INSTALL_VSFTPD" = y ]; then askYesNo "Do you want to use encrypted FTP (FTPES)" "Yes" USE_ENCRYPTED_FTP="$answer" port=$DEFAULT_PORT_FTP [ "$USE_ENCRYPTED_FTP" = y ] &amp;&amp; port=$DEFAULT_PORT_FTPES askQuestion "Enter FTP port number" "$port" FTP_PORT="$answer" fi fi if canInstallWebmin; then cat &lt;&lt; EOF $CQUESTION Webmin is a web-based administration tool for your OS.$CEND EOF askYesNo "Do you want to install Webmin?" "Yes" INSTALL_WEBMIN="$answer" fi fi cmdline="sh $0" [ "$USE_RUTORRENT_PLUGIN" = y ] &amp;&amp; cmdline="$cmdline -p" [ "$REINSTALL_RUTORRENT_PLUGIN" = y ] &amp;&amp; cmdline="$cmdline -i" [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; cmdline="$cmdline -a" for user in $USERS; do cmdline="$cmdline -u $user"; done [ "$RUTORRENT_PASSWORD_PROTECTED" = y ] &amp;&amp; cmdline="$cmdline -w" [ -n "$RUTORRENT_BASE_PATH" ] &amp;&amp; cmdline="$cmdline -r &#39;$RUTORRENT_BASE_PATH&#39;" [ "$INSTALL_STARTUP_SCRIPT" = y ] &amp;&amp; cmdline="$cmdline -s" if [ -z "$INSTALL_WEB_SERVER" ]; then : elif [ "$INSTALL_WEB_SERVER" = apache ]; then cmdline="$cmdline --apache" elif [ "$INSTALL_WEB_SERVER" = nginx ]; then cmdline="$cmdline --nginx" elif [ "$INSTALL_WEB_SERVER" = lighttpd ]; then cmdline="$cmdline --lighttpd" else errorExit "Invalid web server: $INSTALL_WEB_SERVER" fi [ "$BUILD_RTORRENT" = y ] &amp;&amp; cmdline="$cmdline --rtorrent" [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; cmdline="$cmdline --rutorrent" [ "$INSTALL_VSFTPD" = y ] &amp;&amp; cmdline="$cmdline --vsftpd" [ -n "$FTP_PORT" ] &amp;&amp; cmdline="$cmdline --ftp-port $FTP_PORT" [ "$USE_ENCRYPTED_FTP" = y ] &amp;&amp; cmdline="$cmdline --ftpes" [ "$INSTALL_WEBMIN" = y ] &amp;&amp; cmdline="$cmdline --webmin" cat &lt;&lt; EOF You can execute this command as the root user (Ubuntu: use ${CRED}sudo$CEND): $CGREEN$cmdline$CEND Use the autodl-irssi ruTorrent plugin: $USE_RUTORRENT_PLUGIN Re-install the autodl-irssi ruTorrent plugin: $REINSTALL_RUTORRENT_PLUGIN Install autodl-irssi: $INSTALL_AUTODL_IRSSI Users: $USERS ruTorrent is password protected: $RUTORRENT_PASSWORD_PROTECTED ruTorrent base path: $RUTORRENT_BASE_PATH Install startup script: $INSTALL_STARTUP_SCRIPT Install web server: $INSTALL_WEB_SERVER Build rtorrent: $BUILD_RTORRENT Install ruTorrent: $INSTALL_RUTORRENT Install vsftpd: $INSTALL_VSFTPD FTP port: $FTP_PORT Use FTPES: $USE_ENCRYPTED_FTP Install Webmin: $INSTALL_WEBMIN EOF if [ -n "$INSTALL_WEB_SERVER" ]; then for port in $HTTP_PORT $HTTPS_PORT; do isPortUsed $port || continue cat &lt;&lt; EOF $CWARNING Port $port is in use. If it&#39;s not used by $INSTALL_WEB_SERVER, you may need to disable or uninstall that other web server before continuing.$CEND EOF done fi if [ "$INTERACTIVE" = y ]; then echo "" waitenter "Press Ctrl+C to cancel or ENTER to install." fi osHandler_$os init2 initUsers initPluginDirVar [ -n "$INSTALL_WEB_SERVER" ] || [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; RUTORRENT_PASSWORD_PROTECTED=y [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; [ -z "$INSTALL_WEB_SERVER" ] &amp;&amp; errorExit "You must install a web server if you want to install ruTorrent, eg. use --apache --rutorrent" [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; REINSTALL_RUTORRENT_PLUGIN=n [ "$BUILD_RTORRENT" = y ] &amp;&amp; ! canInstallRtorrent &amp;&amp; errorExit "Can&#39;t build rtorrent." [ "$INSTALL_STARTUP_SCRIPT" = y ] &amp;&amp; ! canInstallService &amp;&amp; errorExit "Can&#39;t install startup script." [ "$INSTALL_VSFTPD" = y ] &amp;&amp; ! canInstallVsftpd &amp;&amp; errorExit "Can&#39;t install vsftpd." [ "$INSTALL_WEBMIN" = y ] &amp;&amp; ! canInstallWebmin &amp;&amp; errorExit "Can&#39;t install webmin." if [ -z "$INSTALL_WEB_SERVER" ]; then : elif [ "$INSTALL_WEB_SERVER" = apache ]; then canInstallApache || errorExit "Can&#39;t install Apache." elif [ "$INSTALL_WEB_SERVER" = nginx ]; then canInstallNginx || errorExit "Can&#39;t install nginx." elif [ "$INSTALL_WEB_SERVER" = lighttpd ]; then canInstallLighttpd || errorExit "Can&#39;t install lighttpd." else errorExit "Invalid web server: $INSTALL_WEB_SERVER" fi [ -n "$FTP_PORT" ] &amp;&amp; [ "$FTP_PORT" -lt 1 -o "$FTP_PORT" -gt 65535 ] &amp;&amp; errorExit "Invalid FTP port: $FTP_PORT" if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if [ -z "$INSTALL_WEB_SERVER" ] &amp;&amp; ! isValidRutorrentBasePath "$RUTORRENT_BASE_PATH"; then errorExit "$RUTORRENT_BASE_PATH is not a valid ruTorrent base path." fi fi if [ "$INSTALL_AUTODL_IRSSI" = y ]; then cat &lt;&lt; EOF ${CMSG}Installing required tools and Perl modules... Some Perl modules may not be present, but will be installed from CPAN.$CEND EOF else echo "${CMSG}Installing required tools...$CEND" fi osHandler_$os installTools setSvnOpts [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; osHandler_$os installAutodlTools verifyInstalledPrograms [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; installMissingPerlModules cat &lt;&lt; EOF $CMSG All required programs and Perl modules are now installed. Ignore any errors you saw.$CEND EOF INSTALLED_RTORRENT=n if [ "$BUILD_RTORRENT" = y ]; then cat &lt;&lt; EOF $CMSG Building rtorrent and dependencies...$CEND EOF installRtorrent INSTALLED_RTORRENT=y fi if [ -z "$INSTALL_WEB_SERVER" ]; then : elif [ "$INSTALL_WEB_SERVER" = apache ]; then echo "" echo "${CMSG}Installing Apache$CEND" osHandler_$os installApache installUnrar elif [ "$INSTALL_WEB_SERVER" = nginx ]; then echo "" echo "${CMSG}Installing nginx$CEND" installNginx elif [ "$INSTALL_WEB_SERVER" = lighttpd ]; then echo "" echo "${CMSG}Installing lighttpd$CEND" installLighttpd else errorExit "Invalid web server: $INSTALL_WEB_SERVER" fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if isProgramInstalled php; then installMissingPhpModules else cat &lt;&lt; EOF $CWARNING Could not find the php executable. PHP is not installed or the PHP CLI version is not installed. The autodl-irssi ruTorrent plugin requires the following PHP modules: $CGREEN$REQUIRED_PHP_MODULES$CWARNING They&#39;re normally installed and enabled by default. If not you will need to install them (if needed) and then enable each one in php.ini, eg. extension=MODULE.so and then restart your web server.$CEND EOF fi fi if [ "$INSTALL_RUTORRENT" = y ]; then isProgramInstalled php || errorExit "php is not installed!" verifyWebServerVars echo "" echo "${CMSG}Installing ruTorrent$CEND" [ -d "$WWW_ROOT" ] || errorExit "Invalid web root: &#39;$WWW_ROOT&#39; (does not exist)" RUTORRENT_DIRNAME=rutorrent [ -f "$WWW_ROOT/index.html" ] || cat &gt; "$WWW_ROOT/index.html" &lt;&lt; EOF &lt;html&gt;&lt;head&gt;&lt;title&gt;Root page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="$RUTORRENT_DIRNAME/"&gt;ruTorrent&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; EOF cd "$WWW_ROOT" rm -rf "$RUTORRENT_DIRNAME" tmpName=rutorrent-tmp rm -rf $tmpName if ! svn co $SVN_OPTS "$RUTORRENT_TRUNK_DIR" $tmpName &gt;/dev/null; then # Subversion failed. Try the official tar balls mkdir -p $tmpName cd $tmpName downloadFile "$RUTORRENT_CORE_NAME" "$RUTORRENT_CORE_URL" "$RUTORRENT_CORE_URL2" || errorExit "Could not download ruTorrent." downloadFile "$RUTORRENT_PLUGINS_NAME" "$RUTORRENT_PLUGINS_URL" "$RUTORRENT_PLUGINS_URL2" || errorExit "Could not download ruTorrent plugins." for name in "$RUTORRENT_CORE_NAME" "$RUTORRENT_PLUGINS_NAME"; do tar xzf "$name" || errorExit "Could not unpack $name" rm -f "$name" done cd .. fi cd $tmpName RUTORRENT_BASE_PATH="$WWW_ROOT/$RUTORRENT_DIRNAME" initPluginDirVar mv rutorrent/ "$RUTORRENT_BASE_PATH" mkdir -p "$RUTORRENT_BASE_PATH/plugins" for plugin in $RUTORRENT_PLUGINS; do if [ -d "plugins/$plugin/" ]; then echo "${CMSG}Installing ruTorrent plugin: $plugin$CEND..." mv plugins/$plugin/ "$RUTORRENT_BASE_PATH/plugins/" || errorExit "Could not install plugin &#39;$plugin&#39;." else echo "${CWARNING}Can&#39;t install missing plugin $plugin!$CEND" fi done cd .. rm -rf $tmpName cp "$RUTORRENT_BASE_PATH/favicon.ico" "$WWW_ROOT" i=1 touch "$WWW_PASSWORD_FILE" resetAuthPasswordFilePermissions detectHtpasswd for packedUser in $USERS; do extractPackedUser $packedUser getRutorrentUserConfDir getRutorrentUserShareDir getUserScgiSocketPath "$osUser" getRtorrentDirs "$osUser" # Create user&#39;s ruTorrent config.php rpcMount="$(getUserRpcMount $i)" mkdir -p "$userConfDir" rutConfigFile="$userConfDir/config.php" if [ "$SCGI_USE_UNIX_DOMAIN_SOCKET" = y ]; then cat &gt; "$rutConfigFile" &lt;&lt; EOF &lt;?php \$scgi_port = 0; \$scgi_host = "unix://$scgiSocketPath"; \$XMLRPCMountPoint = "$rpcMount"; ?&gt; EOF exitCode=$? else cat &gt; "$rutConfigFile" &lt;&lt; EOF &lt;?php \$scgi_port = $scgiPort; \$scgi_host = "$SCGI_HOST"; \$XMLRPCMountPoint = "$rpcMount"; ?&gt; EOF exitCode=$? fi [ $exitCode -eq 0 ] || errorExit "Could not write to file $rutConfigFile" # Create user&#39;s directory to prevent certain errors the first time ruTorrent is started mkdir -p "$userShareDir/settings" mkdir -p "$userShareDir/torrents" chmod 0777 "$userShareDir/settings" "$userShareDir/torrents" # Setup rtorrent mkdir -p "$RTORRENT_DOWNLOAD_DIR" mkdir -p "$RTORRENT_WATCH_DIR" mkdir -p "$RTORRENT_SESSION_DIR" rtorrentRc="$userDir/.rtorrent.rc" [ -f "$rtorrentRc" ] &amp;&amp; mv -f "$rtorrentRc" "$rtorrentRc-backup" cat &gt; "$rtorrentRc" &lt;&lt; EOF $(if [ "$SCGI_USE_UNIX_DOMAIN_SOCKET" = y ]; then cat &lt;&lt; EOF2 execute = {sh,-c,rm -f $scgiSocketPath} scgi_local = $scgiSocketPath execute = {sh,-c,chmod 0666 $scgiSocketPath} EOF2 else echo "scgi_port = $SCGI_HOST:$scgiPort" fi) encoding_list = UTF-8 system.umask.set = $DEFAULT_UMASK port_range = $rtorrentPort-$rtorrentPort port_random = no check_hash = no directory = $RTORRENT_DOWNLOAD_DIR session = $RTORRENT_SESSION_DIR encryption = allow_incoming, try_outgoing, enable_retry schedule = watch_directory,1,1,"load_start=$RTORRENT_WATCH_DIR/*.torrent" #schedule = untied_directory,5,5,"stop_untied=$RTORRENT_WATCH_DIR/*.torrent" trackers.enable = 1 #min_peers = 40 #max_peers = 100 #min_peers_seed = 10 #max_peers_seed = 50 #max_uploads = 15 #download_rate = 0 #upload_rate = 0 use_udp_trackers = yes dht = auto dht_port = 6881 peer_exchange = yes #hash_read_ahead = 10 #hash_interval = 100 #hash_max_tries = 10 EOF PHP_BIN_PATH=$(which php 2&gt; /dev/null) COMMENT= [ -x "$PHP_BIN_PATH" ] || COMMENT="#" PHP_BIN_PATH=/path/to/php cat &gt;&gt; "$rtorrentRc" &lt;&lt; EOF ${COMMENT}execute = {sh,-c,$PHP_BIN_PATH $RUTORRENT_BASE_PATH/php/initplugins.php $webUser &amp;} EOF # Add user to web server&#39;s password file sed_i "g/^$webUser:/d" "$WWW_PASSWORD_FILE" $htpasswd -b "$WWW_PASSWORD_FILE" "$webUser" "$webPass" || errorExit "Could not add user to password file" resetAuthPasswordFilePermissions resetOwner "$osUser" "$rtorrentRc" "$userDir" "$RTORRENT_DOWNLOAD_DIR" "$RTORRENT_WATCH_DIR" "$RTORRENT_SESSION_DIR" # Required so some ruTorrent plugins work, eg. _getdir chmod 0755 "$userDir" # Protect some dirs and files, giving only the user and the web server # access. We need to do this since we set perms to 0755 above, or if # the perms already were 0755 to begin with. if [ -n "$WWW_GROUP" ]; then chmod 0600 "$rtorrentRc" for dir in $RTORRENT_REL_DOWNLOAD_DIR $RTORRENT_REL_WATCH_DIR $RTORRENT_REL_SESSION_DIR; do chown $osUser:$WWW_GROUP "$userDir/$dir" chmod 0770 "$userDir/$dir" done fi i=$(expr $i + 1) done [ "$CREATE_ONE_PASSWORD_FILE_PER_USER" = y ] &amp;&amp; createOnePasswordFilePerUser fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then [ -z "$RUTORRENT_BASE_PATH" ] &amp;&amp; errorExit "Invalid ruTorrent base path." [ "$REINSTALL_RUTORRENT_PLUGIN" = y ] &amp;&amp; rm -rf "$AUTODL_IRSSI_PLUGIN_DIR" mkdir -p "$RUTORRENT_BASE_PATH/plugins" cd "$RUTORRENT_BASE_PATH/plugins" if [ -d "$AUTODL_IRSSI_PLUGIN_DIR" ]; then echo "${CMSG}The autodl-irssi ruTorrent plugin dir already exists. Updating it...$CEND" cd "$AUTODL_IRSSI_PLUGIN_DIR" if ! svn up $SVN_OPTS &gt; /dev/null; then errorExit "Could not update the autodl-irssi ruTorrent plugin. Run the script as root." fi else echo "${CMSG}Downloading the autodl-irssi ruTorrent plugin...$CEND" if ! git clone "$GIT_PATH_RUTORRENT_PLUGIN" autodl-irssi &gt; /dev/null; then errorExit "Could not check out the autodl-irssi ruTorrent plugin" fi fi fi if [ "$INSTALL_AUTODL_IRSSI" = y ]; then if [ "$RUTORRENT_PASSWORD_PROTECTED" = y ]; then for packedUser in $USERS; do extractPackedUser $packedUser installUser "$RUTORRENT_BASE_PATH/conf/users/$webUser/plugins/autodl-irssi" "$osUser" "$webUser" "$autodlPort" "$autodlPassword" done else for packedUser in $USERS; do extractPackedUser $packedUser installUser "$AUTODL_IRSSI_PLUGIN_DIR" "$osUser" "$webUser" "$autodlPort" "$autodlPassword" [ "$USE_RUTORRENT_PLUGIN" = y ] &amp;&amp; break done fi fi if [ "$INSTALL_RUTORRENT" = y ]; then verifyWebServerVars resetWebServerPermissions resetRutorrentUserPermissions # Restart it just in case we enabled/installed PHP modules. osHandler_$os restart_$INSTALL_WEB_SERVER fi if [ "$INSTALL_VSFTPD" = y ]; then echo "${CMSG}Installing vsftpd...$CEND" osHandler_$os installVsftpd fi if [ "$INSTALL_WEBMIN" = y ]; then cd rm -rf webmin-*/ webmin*.tar.gz if ! downloadFile webmin.tar.gz "$WEBMIN_URL"; then errorExit "Could not download Webmin." fi tar xzf webmin.tar.gz rm -f webmin.tar.gz cd webmin-*/ || errorExit "Could not CD to webmin dir" osHandler_$os preWebminInstall [ -x "setup.sh" ] || errorExit "Missing Webmin setup.sh file or not executable." cat &lt;&lt; EOF $CMSG Starting Webmin installer. Use another port than 10000, enable SSL, start webmin at boot, and use a strong admin password.$CEND $CWARNING When it asks you if it should use SSL and whether it should start at boot, type y.$CEND EOF ./setup.sh /usr/local/webmin osHandler_$os postWebminInstall cd rm -rf webmin-*/ fi if [ "$INSTALL_RUTORRENT" = y ]; then # Some plugins will fail unless they can write to the /tmp directory # We MUST do this AFTER installing Webmin since it will reset the perms! chmod 1777 /tmp fi if [ "$INSTALL_STARTUP_SCRIPT" = y ]; then for packedUser in $USERS; do extractPackedUser $packedUser echo "${CMSG}Installing service for user $osUser.$CEND" osHandler_$os installAutodlService $osUser done fi echo "" echo "${CGREEN}================================= DONE =================================$CEND" [ "$INSTALLED_RTORRENT" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Built and installed rtorrent with XML-RPC support$CEND" [ -n "$INSTALL_WEB_SERVER" ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed and configured web server ($INSTALL_WEB_SERVER)$CEND" [ "$INSTALL_VSFTPD" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed and configured FTP server (vsftpd)$CEND" [ "$INSTALL_RUTORRENT" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed ruTorrent$CEND" [ "$USE_RUTORRENT_PLUGIN" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed/updated the autodl-irssi ruTorrent plugin$CEND" [ "$INSTALL_AUTODL_IRSSI" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed autodl-irssi$CEND" [ "$INSTALL_STARTUP_SCRIPT" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed and started Irssi and rtorrent service$CEND" [ "$INSTALL_WEBMIN" = y ] &amp;&amp; echo "${CDGREEN}[+]$CEND ${CGREEN}Installed Webmin$CEND" if [ "$INSTALL_RUTORRENT" = y ]; then getIpAddress cat &lt;&lt; EOF ${CMSG}ruTorrent URLs.$CEND ${CWARNING}Verify that the IP address below is correct!$CEND ${CMAGENTA}http://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND ${CMAGENTA}https://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND EOF fi if [ "$INSTALL_RUTORRENT" = y ]; then cat &lt;&lt; EOF ${CMSG}rtorrent directories$CEND: EOF for packedUser in $USERS; do extractPackedUser $packedUser getRtorrentDirs "$osUser" cat &lt;&lt; EOF ${CMSG}User $CGREEN$osUser$CEND: ${CGREEN}Downloads$CEND : $CMAGENTA$RTORRENT_DOWNLOAD_DIR$CEND ${CGREEN}Watch dir$CEND : $CMAGENTA$RTORRENT_WATCH_DIR$CEND ${CGREEN}Session dir$CEND : $CMAGENTA$RTORRENT_SESSION_DIR$CEND ${CGREEN}rtorrent port$CEND: $CMAGENTA$rtorrentPort$CEND EOF done fi if [ -n "$INSTALL_WEB_SERVER" ]; then cat &lt;&lt; EOF ${CMSG}Web server info$CEND: ${CGREEN}Web server root$CEND: ${CMAGENTA}$WWW_ROOT$CEND ${CGREEN}ruTorrent dir$CEND : ${CMAGENTA}$RUTORRENT_BASE_PATH$CEND EOF fi if [ "$INSTALL_VSFTPD" = y ]; then getIpAddress cat &lt;&lt; EOF $CMSG To log in to the FTP server, use your $(uname -s) login name and password. I guessed the IP address below. Make sure it&#39;s correct.$CEND ${CGREEN}FTP IP address$CEND: ${CMAGENTA}$OUR_IP_ADDRESS$CEND ${CGREEN}FTP port$CEND: ${CMAGENTA}$FTP_PORT$CEND ${CGREEN}FTP server type$CEND: $CMAGENTA$FTP_SERVER_TYPE$CEND EOF fi if [ "$INSTALL_WEBMIN" = y ]; then getIpAddress WEBMIN_PORT= WEBMIN_SSL= WEBMIN_NAME= WEBMIN_CONFIG=/etc/webmin/miniserv.conf WEBMIN_USERS=/etc/webmin/miniserv.users if [ -f $WEBMIN_CONFIG ]; then WEBMIN_PORT=$(grep &#39;^port=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^port=\([0-9]*\).*/\1/&#39;) WEBMIN_SSL=$(grep &#39;^ssl=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^ssl=\([0-9]*\).*/\1/&#39;) WEBMIN_NAME=$(head -n1 $WEBMIN_USERS | cut -d: -f1) fi WEBMIN_PORT=${WEBMIN_PORT:-UNKNOWN} WEBMIN_NAME=${WEBMIN_NAME:-UNKNOWN} cat &lt;&lt; EOF $CMSG Webmin was installed. Port is $WEBMIN_PORT and the user is $WEBMIN_NAME. ${CRED}Verify the IP address below.$CEND EOF if [ -z "$WEBMIN_SSL" ]; then echo " ${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" echo "${CMSG}or:$CEND" echo " ${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" elif [ "$WEBMIN_SSL" = 0 ]; then echo " ${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" else echo " ${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND" fi fi if [ -n "$INSTALL_WEB_SERVER" ] || [ "$INSTALL_VSFTPD" = y ] || \ [ "$INSTALL_RUTORRENT" = y ] || [ "$USE_RUTORRENT_PLUGIN" = y ]; then if [ "$SELINUX_ENABLED" = y ]; then cat &lt;&lt; EOF $CWARNING SELinux is enabled. It could cause some problems with the web server, vsftpd or ruTorrent. EOF fi fi if [ "$CREATED_CERT_FILE" = y ]; then cat &lt;&lt; EOF $CWARNING A self-signed certificate was created. Your browser or FTP client will most likely warn you about a non-trusted certificate.$CEND EOF fi if [ "$USE_RUTORRENT_PLUGIN" = y ]; then if isProgramInstalled php; then detectMissingPhpModules if [ -n "$MISSING_PHP_MODULES" ]; then cat &lt;&lt; EOF $CWARNING The following PHP modules seem to be missing. It&#39;s possible that the autodl-irssi ruTorrent plugin won&#39;t work. Missing PHP modules: $MISSING_PHP_MODULES$CEND EOF fi else cat &lt;&lt; EOF $CWARNING Could not find the php executable. Make sure the following PHP modules are enabled or the autodl-irssi ruTorrent plugin won&#39;t work: $REQUIRED_PHP_MODULES$CEND EOF fi fi'
    />
    <link
      rel="canonical"
      href="https://parttimelegend.github.io/gistbook/gist/d71482792011133f46bb"
    />
    <meta
      property="og:url"
      content="https://parttimelegend.github.io/gistbook/gist/d71482792011133f46bb"
    />
    <meta property="og:site_name" content="Gistbook" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2015-08-29T14:09:29+00:00"
    />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Seedbox Config" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": { "@type": "Person", "name": "Tomáš Krupka" },
        "dateModified": "2015-08-29T14:09:29+00:00",
        "datePublished": "2015-08-29T14:09:29+00:00",
        "description": "#!/bin/sh # ***** BEGIN LICENSE BLOCK ***** # Version: MPL 1.1 # # The contents of this file are subject to the Mozilla Public License Version # 1.1 (the &quot;License&quot;); you may not use this file except in compliance with # the License. You may obtain a copy of the License at # http://www.mozilla.org/MPL/ # # Software distributed under the License is distributed on an &quot;AS IS&quot; basis, # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License # for the specific language governing rights and limitations under the # License. # # The Original Code is IRC Auto Downloader # # The Initial Developer of the Original Code is # David Nilsson. # Portions created by the Initial Developer are Copyright (C) 2010, 2011 # the Initial Developer. All Rights Reserved. # # Contributor(s): # # ***** END LICENSE BLOCK ***** AUTODL_IRSSI_ZIP_URL=&quot;http://update.autodl-community.com/autodl-irssi-community.zip&quot; GIT_PATH_RUTORRENT_PLUGIN=&quot;https://github.com/autodl-community/autodl-rutorrent.git&quot; WEBMIN_URL=&quot;http://www.webmin.com/download/webmin-current.tar.gz&quot; RUTORRENT_TRUNK_DIR=&quot;https://rutorrent.googlecode.com/svn/trunk&quot; # The official tarballs are tried if subversion fails. RUTORRENT_VERSION=&quot;3.6&quot; RUTORRENT_CORE_NAME=&quot;rutorrent-$RUTORRENT_VERSION.tar.gz&quot; RUTORRENT_CORE_URL=&quot;http://dl.bintray.com/novik65/generic/$RUTORRENT_CORE_NAME&quot; #RUTORRENT_CORE_URL=&quot;http://rutorrent.googlecode.com/files/$RUTORRENT_CORE_NAME&quot; RUTORRENT_PLUGINS_NAME=&quot;plugins-$RUTORRENT_VERSION.tar.gz&quot; #RUTORRENT_PLUGINS_URL=&quot;http://rutorrent.googlecode.com/files/$RUTORRENT_PLUGINS_NAME&quot; RUTORRENT_PLUGINS_URL=&quot;http://dl.bintray.com/novik65/generic/$RUTORRENT_PLUGINS_NAME&quot; #RUTORRENT_CORE_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_CORE_NAME/download&quot; #RUTORRENT_PLUGINS_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_PLUGINS_NAME/download&quot; RUTORRENT_PLUGINS= # These are the ruTorrent plugins that will get installed. To remove one, either # remove the whole line or comment it (prepend a &#39;#&#39; to the start of the line). # If the line starts with &#39;#&#39;, the plugin is not installed. RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS _getdir&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS _task&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS autotools&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS chunks&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS cookies&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS cpuload&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS create&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS data&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS datadir&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS diskspace&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS edit&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS erasedata&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS extsearch&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS feeds&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS geoip&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS httprpc&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS ipad&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS loginmgr&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS logoff&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS mediainfo&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS ratio&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS retrackers&quot; #RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS rpc&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS rss&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS rssurlrewrite&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS scheduler&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS seedingtime&quot; #RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS show_peers_like_wtorrent&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS source&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS theme&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS throttle&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS tracklabels&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS trafic&quot; RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS unpack&quot; # For building rtorrent LIBCURL_NAME=&quot;curl-7.36.0&quot; LIBCURL_URL=&quot;http://curl.haxx.se/download/$LIBCURL_NAME.tar.gz&quot; SIGCPP20_NAME=&quot;libsigc++-2.3.1&quot; SIGCPP20_URL=&quot;http://ftp.gnome.org/pub/GNOME/sources/libsigc++/2.3/$SIGCPP20_NAME.tar.gz&quot; XMLRPC_SVN_DIR=&quot;https://svn.code.sf.net/p/xmlrpc-c/code/stable&quot; LIBTORRENT_VERSION=&quot;0.13.4&quot; LIBTORRENT_NAME=&quot;libtorrent-$LIBTORRENT_VERSION&quot; LIBTORRENT_URL=&quot;http://libtorrent.rakshasa.no/downloads/$LIBTORRENT_NAME.tar.gz&quot; LIBTORRENT_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$LIBTORRENT_NAME.tar.gz/download&quot; RTORRENT_VERSION=&quot;0.9.4&quot; RTORRENT_NAME=&quot;rtorrent-$RTORRENT_VERSION&quot; RTORRENT_URL=&quot;http://libtorrent.rakshasa.no/downloads/$RTORRENT_NAME.tar.gz&quot; RTORRENT_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RTORRENT_NAME.tar.gz/download&quot; HTPASSWD_PY_SCRIPT_URL=&quot;http://trac.edgewall.org/export/10433/trunk/contrib/htpasswd.py&quot; HTPASSWD_PY_SCRIPT_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/htpasswd.py/download&quot; NGINX_NAME=&quot;nginx-1.7.0&quot; NGINX_URL=&quot;http://nginx.org/download/$NGINX_NAME.tar.gz&quot; LIGHTTPD_NAME=&quot;lighttpd-1.4.35&quot; LIGHTTPD_URL=&quot;http://download.lighttpd.net/lighttpd/releases-1.4.x/$LIGHTTPD_NAME.tar.gz&quot; MOD_SCGI_VERSION=&quot;1.14&quot; MOD_SCGI_URL=&quot;http://python.ca/scgi/releases/scgi-$MOD_SCGI_VERSION.tar.gz&quot; UNRAR_VERSION=&quot;4.0.7&quot; UNRAR_URL=&quot;http://www.rarlab.com/rar/unrarsrc-$UNRAR_VERSION.tar.gz&quot; # Dirs relative to user&#39;s home directory RTORRENT_REL_DOWNLOAD_DIR=&quot;downloads&quot; RTORRENT_REL_WATCH_DIR=&quot;rtorrent/watch&quot; RTORRENT_REL_SESSION_DIR=&quot;rtorrent/session&quot; REQUIRED_PERL_MODULES=&quot;Time::HiRes XML::LibXML Archive::Zip Net::SSLeay HTML::Parser Digest::SHA1 JSON&quot; REQUIRED_PHP_MODULES=&quot;json xml sockets&quot; # If set to y, add &#39;load perl&#39; to .irssi/startup IRSSI_LOAD_PERL=n IGNORE_IRSSI=n # Start port. When we need a new port number, this port is incremented by one. CURRENT_PORT=23875 DEFAULT_PORT_FTP=21 DEFAULT_PORT_FTPES=990 DEFAULT_UMASK=022 RPC_PREFIX=RPC LSB_DEFAULT_START=&quot;2 3 4 5&quot; LSB_DEFAULT_STOP=&quot;0 1 6&quot; # Setting these to anything other than 80 and 443 may not work with Apache (since the # code assumed it would always be 80 and 443). HTTP_PORT=80 HTTPS_PORT=443 SCGI_HOST=&quot;127.0.0.1&quot; INTERACTIVE=n USE_RUTORRENT_PLUGIN=n REINSTALL_RUTORRENT_PLUGIN=n INSTALL_AUTODL_IRSSI=n RUTORRENT_PASSWORD_PROTECTED=n USERS= RUTORRENT_BASE_PATH= INSTALL_STARTUP_SCRIPT=n BUILD_RTORRENT=n INSTALL_WEB_SERVER= INSTALL_RUTORRENT=n INSTALL_VSFTPD=n FTP_PORT= USE_ENCRYPTED_FTP=n INSTALL_WEBMIN=n USER_TIMEZONE= RUTORRENT_SITE_REALM=&quot;My ruTorrent web site&quot; AUTODL_STARTUP_DESC=&quot;Start autodl-irssi and rtorrent&quot; PHPCGI_STARTUP_DESC=&quot;Start php-cgi&quot; NGINX_STARTUP_DESC=&quot;Start nginx&quot; LIGHTTPD_STARTUP_DESC=&quot;Start lighttpd&quot; PATH=&quot;$PATH:/usr/local/bin&quot; # Find an echo that supports -e echo=echo for cmd in echo /bin/echo; do $cmd &gt;/dev/null 2&gt;&amp;1 || continue if ! $cmd -e &quot;&quot; | grep -qE &#39;^-e&#39;; then echo=$cmd break fi done CSI=$($echo -e &quot;\\033[&quot;) CEND=&quot;${CSI}0m&quot; CDGREEN=&quot;${CSI}32m&quot; CRED=&quot;${CSI}1;31m&quot; CGREEN=&quot;${CSI}1;32m&quot; CYELLOW=&quot;${CSI}1;33m&quot; CBLUE=&quot;${CSI}1;34m&quot; CMAGENTA=&quot;${CSI}1;35m&quot; CCYAN=&quot;${CSI}1;36m&quot; CQUESTION=&quot;$CMAGENTA&quot; CWARNING=&quot;$CRED&quot; CMSG=&quot;$CCYAN&quot; errorExit() { cat &lt;&lt; EOF $CWARNING ***ERROR*** $* ***ERROR*** $CEND Help channel: ${CGREEN}#autodl-community@irc.p2p-network.net$CEND EOF exit 1 } exitHelp() { cat &lt;&lt; EOF autodl-irssi and ruTorrent plugin installer sh $0 [options] Options: --rtorrent Will build and install rtorrent, libtorrent and xmlrpc-c from source code. --rtorrent-noexec-patch Patch rtorrent to disallow remote users from executing code. --apache Install Apache web server. --nginx Install nginx web server. --lighttpd Install lighttpd web server. --rutorrent Install ruTorrent. Requires a web server, eg. --apache. --vsftpd Install vsftpd. --ftpes Use encrypted FTP (FTPES). --ftp-port &lt;port&gt; FTP server port. --webmin Install Webmin. -p --rutorrent-plugin Use or install the autodl-irssi ruTorrent plugin. If it&#39;s already installed, it will be updated (svn up), unless --reinstall-plugin option is used in which case it will be re-installed. -i --reinstall-plugin Re-install the autodl-irssi ruTorrent plugin if it&#39;s already installed. -a --install-autodl Install autodl-irssi. -u user:autodlPass:webUser:webPass --user user:autodlPass:webUser:webPass The $(uname -s) user, autodl-irssi password, ruTorrent user, ruTorrent password. You can use more than one -u option. If autodlPassword is not set, a random password will be used. -w --password-protected Use this option if ruTorrent is password protected. It&#39;s required if you want to use more than one ruTorrent user. Not needed if you install ruTorrent. -r PATH --rutorrent-base-path PATH Path to ruTorrent, eg. /var/www/rutorrent. Not needed if you install ruTorrent. -s --install-startup-script Install a startup script (service) which will start Irssi and rtorrent when the computer boots. -h --help Show this help text Examples (as root user): sh $0 --rtorrent --apache --rutorrent --vsftpd --ftpes --webmin -p -a -s -u user1::user1:pass1 -u user2::user2:pass2 Installs rtorrent, Apache, ruTorrent, vsftpd (encrypted), Webmin the autodl-irssi plugin, autodl-irssi, installs a service (starting Irssi and rtorrent) for both users. sh $0 -p -a -u user::user:pass -r /var/www/rutorrent -s Installs autodl-irssi + ruTorrent plugin for user &#39;user&#39;. ruTorrent has not been password protected. Also installs the startup script. sh $0 -p -a -u user1::user1:pass1 -u user2::user2:pass2 -w -r /var/www/rutorrent -s Installs autodl-irssi + ruTorrent plugin for users &#39;user1&#39; and &#39;user2&#39;. ruTorrent has been password protected. Also installs the startup script. sh $0 --rtorrent -a -u user1 -u user2 -u user3 -u user4 -s Installs rtorrent, autodl-irssi and the startup script. Help fchannel: #autodl-community@irc.p2p-network.net EOF exit 1 } parseCommandLine() { while [ $# -gt 0 ]; do local arg=&quot;$1&quot; shift if [ &quot;$arg&quot; = &quot;-p&quot; ] || [ &quot;$arg&quot; = &quot;--rutorrent-plugin&quot; ]; then USE_RUTORRENT_PLUGIN=y elif [ &quot;$arg&quot; = &quot;-i&quot; ] || [ &quot;$arg&quot; = &quot;--reinstall-plugin&quot; ]; then REINSTALL_RUTORRENT_PLUGIN=y elif [ &quot;$arg&quot; = &quot;-a&quot; ] || [ &quot;$arg&quot; = &quot;--install-autodl&quot; ]; then INSTALL_AUTODL_IRSSI=y elif [ &quot;$arg&quot; = &quot;-u&quot; ] || [ &quot;$arg&quot; = &quot;--user&quot; ]; then USERS=&quot;$USERS $1&quot; shift elif [ &quot;$arg&quot; = &quot;-w&quot; ] || [ &quot;$arg&quot; = &quot;--password-protected&quot; ]; then RUTORRENT_PASSWORD_PROTECTED=y elif [ &quot;$arg&quot; = &quot;-r&quot; ] || [ &quot;$arg&quot; = &quot;--rutorrent-base-path&quot; ]; then RUTORRENT_BASE_PATH=&quot;$1&quot; shift elif [ &quot;$arg&quot; = &quot;-s&quot; ] || [ &quot;$arg&quot; = &quot;--install-startup-script&quot; ]; then INSTALL_STARTUP_SCRIPT=y elif [ &quot;$arg&quot; = &quot;--rtorrent&quot; ]; then BUILD_RTORRENT=y elif [ &quot;$arg&quot; = &quot;--apache&quot; ]; then INSTALL_WEB_SERVER=apache elif [ &quot;$arg&quot; = &quot;--nginx&quot; ]; then INSTALL_WEB_SERVER=nginx elif [ &quot;$arg&quot; = &quot;--lighttpd&quot; ]; then INSTALL_WEB_SERVER=lighttpd elif [ &quot;$arg&quot; = &quot;--rutorrent&quot; ]; then INSTALL_RUTORRENT=y elif [ &quot;$arg&quot; = &quot;--vsftpd&quot; ]; then INSTALL_VSFTPD=y elif [ &quot;$arg&quot; = &quot;--ftpes&quot; ]; then USE_ENCRYPTED_FTP=y elif [ &quot;$arg&quot; = &quot;--ftp-port&quot; ]; then FTP_PORT=&quot;$1&quot; shift elif [ &quot;$arg&quot; = &quot;--webmin&quot; ]; then INSTALL_WEBMIN=y else exitHelp fi done } # Sets os and os_long to the OS type and OS name respectively detectOs() { local DISTRIB_ID= local DISTRIB_DESCRIPTION= if [ -f /etc/lsb-release ]; then . /etc/lsb-release fi if [ -f /etc/fedora-release ]; then os=fedora os_long=&quot;$(cat /etc/fedora-release)&quot; # Must be before a whole bunch of other OS tests elif [ &quot;$DISTRIB_ID&quot; = &quot;Ubuntu&quot; ]; then os=debian os_long=&quot;$DISTRIB_DESCRIPTION&quot; elif [ &quot;$DISTRIB_ID&quot; = &quot;LinuxMint&quot; ]; then os=debian os_long=&quot;$DISTRIB_DESCRIPTION&quot; # Must be before Debian elif [ &quot;$DISTRIB_ID&quot; = &quot;Peppermint&quot; ]; then os=debian os_long=&quot;$DISTRIB_DESCRIPTION&quot; elif [ &quot;$DISTRIB_ID&quot; = &quot;MEPIS&quot; ]; then os=debian os_long=&quot;$DISTRIB_DESCRIPTION&quot; elif [ -f /etc/clearos-release ]; then os=fedora os_long=&quot;$(cat /etc/clearos-release)&quot; elif [ -f /etc/debian_version ]; then os=debian local prefix= if ! uname -s | grep -q GNU; then prefix=&quot;GNU/&quot; fi os_long=&quot;Debian $prefix$(uname -s) $(cat /etc/debian_version)&quot; elif [ -f /etc/redhat-release ]; then os=fedora os_long=&quot;$(cat /etc/redhat-release)&quot; else echo -e &quot;\\e[1;31mYour OS is not detected as an OS supported by this script. This script only supports \\e[5;32mDebian and Fedora\\e[0m \\e[1;31mbased OSes.\\e[0m&quot; exit 1 fi os_long=&quot;${os_long:-$(uname -s)}&quot; } # In-place editing like sed -i but more portable... sed_i() { local cmd=&quot;$1&quot; local file=&quot;$2&quot; isProgramInstalled ed || errorExit &quot;ed is not installed!&quot; local addr=&quot;,&quot; echo &quot;$cmd&quot; | grep -qE &#39;^/&#39; &amp;&amp; addr= ed -s &quot;$file&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF $addr$cmd w q EOF } getFirst() { echo $1 } # Returns true if $1 is one of $2..$n arrayIsPresent() { local val=&quot;$1&quot; shift for v in &quot;$@&quot;; do [ &quot;$v&quot; = &quot;$val&quot; ] &amp;&amp; return 0 done return 1 } canGeneratePasswords() { [ -c /dev/urandom ] } generatePassword() { newPassword=$(cat /dev/urandom | tr -dc _A-Z-a-z-0-9 | head -c17) } isProgramInstalled() { which &quot;$1&quot; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } isPerlModuleInstalled() { perl -M$1 -e &#39;&#39; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } # Add $1 or $2 if it exists, to PACKAGES if program $1 isn&#39;t present addProgram() { isProgramInstalled $1 || PACKAGES=&quot;$PACKAGES ${2:-$1}&quot; } # Add $2 to PACKAGES if perl module $1 isn&#39;t present addPerlModule() { isPerlModuleInstalled $1 || PACKAGES=&quot;$PACKAGES $2&quot; } installPackages() { [ -z &quot;$INSTALL&quot; ] &amp;&amp; return [ -z &quot;$PACKAGES&quot; ] &amp;&amp; return $INSTALL $PACKAGES PACKAGES= } installPerlModule() { isPerlModuleInstalled $1 || $INSTALL $2 } installProgram() { isProgramInstalled $1 || $INSTALL ${2:-$1} } installBuildTools() { [ &quot;$BUILD_TOOLS_INSTALLED&quot; = y ] &amp;&amp; return PACKAGES=&quot;$BUILD_TOOLS&quot; installPackages BUILD_TOOLS_INSTALLED=y } # Detects missing Perl modules and stores them in MISSING_PERL_MODULES detectMissingPerlModules() { OLD_PERL_MODULES= MISSING_PERL_MODULES= for module in $REQUIRED_PERL_MODULES; do isPerlModuleInstalled $module || MISSING_PERL_MODULES=&quot;$MISSING_PERL_MODULES $module&quot; done # Make sure the JSON module is new if isPerlModuleInstalled JSON &amp;&amp; ! perl -MJSON -e &#39;&amp;decode_json(&quot;{}&quot;)&#39; &gt; /dev/null 2&gt;&amp;1; then echo &quot;${CWARNING}Old JSON module is installed. Need to install from CPAN.$CEND&quot; MISSING_PERL_MODULES=&quot;$MISSING_PERL_MODULES JSON&quot; OLD_PERL_MODULES=&quot;$OLD_PERL_MODULES JSON&quot; fi if echo &quot;$MISSING_PERL_MODULES&quot; | grep -wq JSON; then MISSING_PERL_MODULES=&quot;JSON::XS $MISSING_PERL_MODULES&quot; fi if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;XML::LibXML&#39;; then # Sometimes the cpan script doesn&#39;t install the required dependencies MISSING_PERL_MODULES=&quot;XML::NamespaceSupport XML::SAX $MISSING_PERL_MODULES&quot; fi } # Detect where cpan is installed and place the path in the CPAN variable. # PCLinuxOS/Mandriva append the version number... detectCpanBin() { for file in $(which cpan 2&gt; /dev/null) $(ls /usr/bin/cpan-* 2&gt; /dev/null); do if [ -x &quot;$file&quot; ]; then CPAN=&quot;$file&quot; return fi done isPerlModuleInstalled CPAN &amp;&amp; return errorExit &quot;Could not find the cpan script or the CPAN Perl module. Can&#39;t install missing Perl modules.&quot; } isValidTzName() { echo &quot;$1&quot; | LC_ALL=C grep -qE &#39;^[A-Z][^/ ]*(/[A-Z][^/ ]*)?$&#39; &amp;&amp; return 0 return 1 } detectTimeZone() { [ -n &quot;$USER_TIMEZONE&quot; ] &amp;&amp; return local hash= local hasher= local files= local zoneinfoPath=/usr/share/zoneinfo [ -d &quot;$zoneinfoPath&quot; ] || return if hasher=md5sum; isProgramInstalled $hasher || hasher=sha1sum; isProgramInstalled $hasher; then hash=$($hasher /etc/localtime | awk &#39;{print $1}&#39;) files=&quot;$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E &quot;^$hash\\\\&gt;&quot; | awk &#39;{print $2}&#39;)&quot; elif hasher=md5; isProgramInstalled $hasher || hasher=sha1; isProgramInstalled $hasher; then hash=$($hasher /etc/localtime | sed -e &#39;s/^.* = \\([a-zA-Z0-9]*\\)$/\\1/&#39;) files=&quot;$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E &quot;$hash\\$&quot; | sed -e &#39;s/^[^ ]* (\\([^)]*\\)).*/\\1/&#39;)&quot; else return fi # Detect all possible timezone names local timezones= for path in $files; do local tz=&quot;${path#$zoneinfoPath/}&quot; while true; do isValidTzName &quot;$tz&quot; &amp;&amp; break local newTz=&quot;${tz#*/}&quot; [ &quot;$newTz&quot; = &quot;$tz&quot; ] &amp;&amp; tz= &amp;&amp; break tz=&quot;$newTz&quot; done isValidTzName &quot;$tz&quot; &amp;&amp; timezones=&quot;$timezones $tz&quot; done # Now find the ones PHP likes... local okRegions=&quot;(Africa|America|Antarctica|Arctic|Asia|Atlantic|Australia|Europe|Indian|Pacific)&quot; for tz in $timezones; do echo &quot;$tz&quot; | grep -qE &quot;^$okRegions/&quot; &amp;&amp; USER_TIMEZONE=&quot;$tz&quot; &amp;&amp; return done # Return the first one we found for tz in $timezones; do USER_TIMEZONE=&quot;$tz&quot; return done } getNumCpus() { [ -n &quot;$NUMCPUS&quot; ] &amp;&amp; return [ -f /proc/cpuinfo ] &amp;&amp; NUMCPUS=$(cat /proc/cpuinfo | grep &#39;^processor&#39; | wc -l) &amp;&amp; return isProgramInstalled sysctl &amp;&amp; sysctl -n hw.ncpu | grep -qE &#39;^[1-9][0-9]*$&#39; &amp;&amp; NUMCPUS=$(sysctl -n hw.ncpu) &amp;&amp; return NUMCPUS=1 } # Appends $value to $varName in $file, creating the var if it doesn&#39;t exist. The # value is not appended if it already exists. appendFileStringVar() { local file=&quot;$1&quot; local varName=&quot;$2&quot; local value=&quot;$3&quot; [ -f &quot;$file&quot; ] || errorExit &quot;File &#39;$file&#39; does not exist&quot; local varLine=$(grep -E &quot;^$varName=&quot; &quot;$file&quot; | tail -n1) if [ -z &quot;$varLine&quot; ]; then echo &quot;$varName=\\&quot;$value\\&quot;&quot; &gt;&gt; &quot;$file&quot; else echo &quot;$varLine&quot; | grep -qE &quot;[=&#39;\\&quot; ]$value(\\&quot;|&#39;| |$)&quot; &amp;&amp; return local q= echo &quot;$varLine&quot; | grep -qE &quot;^$varName=&#39;&quot; &amp;&amp; q=&quot;&#39;&quot; echo &quot;$varLine&quot; | grep -qE &quot;^$varName=\\&quot;&quot; &amp;&amp; q=&#39;&quot;&#39; sed_i &quot;s#^\\\\($varName=\\\\)$q\\\\(.*\\\\)$q#\\\\1\\&quot;\\\\2 $value\\&quot;#&quot; &quot;$file&quot; fi } # Set a variable in a script file to a new value. The variable is created if it does not exist setScriptVariable() { local file=&quot;$1&quot; local name=$2 local value=&quot;$3&quot; [ -f &quot;$file&quot; ] || errorExit &quot;File does not exist: $file&quot; local newLine=&quot;$name=\\&quot;$value\\&quot;&quot; if grep -qE &quot;^$name=&quot; $file; then sed_i &quot;s!^$name=.*\\$!$newLine!&quot; &quot;$file&quot; else echo &quot;$newLine&quot; &gt;&gt; &quot;$file&quot; fi } userExists() { id -rg &quot;$1&quot; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0 return 1 } setSvnOpts() { SVN_OPTS= isProgramInstalled svn || return # svn sometimes gives an error message &#39;broken pipe&#39;. Ignore it. if svn help co 2&gt;/dev/null | grep -q &#39;non-interactive&#39; &amp;&amp; svn help co 2&gt;/dev/null | grep -q &#39;trust-server-cert&#39;; then SVN_OPTS=&quot;--non-interactive --trust-server-cert&quot; fi } downloadFile() { local filename=&quot;$1&quot; shift for url in &quot;$@&quot;; do for i in 1 2 3 4 5; do wget --no-check-certificate -O &quot;$filename&quot; &quot;$url&quot; &amp;&amp; return 0 done done return 1 } buildMakeProgram() { local url=&quot;$1&quot; local name=&quot;$2&quot; local builddir=&quot;$3&quot; local srcdir=&quot;$4&quot; local makefile=&quot;${5:-Makefile}&quot; buildStart echo &quot;${CMSG}Downloading $name source code...$CEND&quot; cd &quot;$BUILD_DIR&quot; local filename=&quot;${url##*/}&quot; downloadFile &quot;$filename&quot; &quot;$url&quot; || errorExit &quot;Could not download $name source code.&quot; tar xzf &quot;$filename&quot; srcdir=&quot;${srcdir:-${filename%.tar.gz}}&quot; cd &quot;$srcdir/$builddir&quot; local make=${MAKE:-make} echo &quot;${CMSG}Building $name...$CEND&quot; $make -f $makefile all || errorExit &quot;Could not build $name.&quot; $make -f $makefile install || errorExit &quot;Could not install $name.&quot; echo &quot;${CMSG}$name is now installed$CEND&quot; buildEnd } buildProgram() { local prog=&quot;$1&quot; echo &quot;${CMSG}Building $prog...$CEND&quot; ./configure --prefix=$PREFIX $2 || errorExit &quot;Could not configure $prog. Try again, or try logging out and in and try again.&quot; getNumCpus local make=${MAKE:-make} local makeopts=&quot;-j$NUMCPUS&quot; $make $makeopts || $make || errorExit &quot;Could not build $prog&quot; $make install || errorExit &quot;Could not install $prog&quot; local ldsoconf=/etc/ld.so.conf touch &quot;$ldsoconf&quot; grep -qE &quot;^$PREFIX/lib$&quot; $ldsoconf || echo &quot;$PREFIX/lib&quot; &gt;&gt; $ldsoconf ldconfig || errorExit &quot;ldconfig failed&quot; echo &quot;${CMSG}$prog is now installed.$CEND&quot; } downloadAndBuild() { local prog=&quot;$1&quot; local urls=&quot;$2&quot; local name=&quot;$3&quot; local configOptions=&quot;$4&quot; local patchUrl=&quot;$5&quot; cd &quot;$BUILD_DIR&quot; echo &quot;${CMSG}Downloading $prog source code...$CEND&quot; downloadFile &quot;$name.tar.gz&quot; $urls || errorExit &quot;Could not download $prog source code.&quot; tar xzf $name.tar.gz if echo &quot;$patchUrl&quot; | grep &#39;^[a-z]*://&#39;; then echo &quot;${CMSG}Patching $prog...$CEND&quot; PACKAGES=&quot;patch&quot; installPackages isProgramInstalled patch || errorExit &quot;patch is not installed!&quot; downloadFile the.patch &quot;$patchUrl&quot; || errorExit &quot;Could not download the patch file.&quot; patch -p1 -d $name &lt; the.patch || errorExit &quot;Could not patch $prog.&quot; elif [ -n &quot;$patchUrl&quot; ]; then echo &quot;${CMSG}Patching $prog...$CEND&quot; cd $name eval $patchUrl cd .. fi cd $name buildProgram &quot;$prog&quot; &quot;$configOptions&quot; } checkoutAndBuild() { local prog=&quot;$1&quot; local url=&quot;$2&quot; local configOptions=&quot;$3&quot; cd &quot;$BUILD_DIR&quot; echo &quot;${CMSG}Downloading $prog source code...$CEND&quot; svn export $SVN_OPTS &quot;$url&quot; &quot;$prog&quot; || errorExit &quot;Could not download $prog source code.&quot; cd &quot;$prog&quot; buildProgram &quot;$prog&quot; &quot;$configOptions&quot; } buildStart() { PREFIX=/usr/local OLD_PATH=&quot;$PATH&quot; PATH=&quot;$PATH:$PREFIX/bin&quot; PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig export PKG_CONFIG_PATH BUILD_DIR=&quot;$(echo ~)/build-tmp&quot; rm -rf &quot;$BUILD_DIR&quot; mkdir &quot;$BUILD_DIR&quot; || errorExit &quot;Could not create build directory.&quot; } buildEnd() { cd rm -rf &quot;$BUILD_DIR&quot; [ -n &quot;$OLD_PATH&quot; ] &amp;&amp; PATH=&quot;$OLD_PATH&quot; unset OLD_PATH unset PKG_CONFIG_PATH } buildRtorrent() { installBuildTools osHandler_$os installRtorrentBuildTools isProgramInstalled pkg-config || errorExit &quot;pkg-config is not installed.&quot; # Minimum version is 7.15.4 but I had problems with 7.15.5 on CentOS. Set # it to 7.18.0 (the version Ubuntu Server 8.04 is using). if ! pkg-config --atleast-version=7.18.0 libcurl; then downloadAndBuild &quot;libcurl&quot; &quot;$LIBCURL_URL&quot; &quot;$LIBCURL_NAME&quot; &quot;&quot; # Prevent &#39;Unknown keyword &#39;URL&#39; in ....&#39; error sed_i &#39;s/^URL:/#URL:/&#39; $PREFIX/lib/pkgconfig/libcurl.pc fi if ! pkg-config --exists sigc++-2.0; then downloadAndBuild &quot;sigc++-2.0&quot; &quot;$SIGCPP20_URL&quot; &quot;$SIGCPP20_NAME&quot; &quot;&quot; fi checkoutAndBuild &quot;xmlrpc-c&quot; &quot;$XMLRPC_SVN_DIR&quot; &quot;--disable-cplusplus&quot; downloadAndBuild &quot;libtorrent&quot; &quot;$LIBTORRENT_URL $LIBTORRENT_URL2&quot; &quot;$LIBTORRENT_NAME&quot; &quot;&quot; patchLibtorrent downloadAndBuild &quot;rtorrent&quot; &quot;$RTORRENT_URL $RTORRENT_URL2&quot; &quot;$RTORRENT_NAME&quot; &quot;--with-xmlrpc-c&quot; &quot;&quot; } patchLibtorrent() { # For gcc 4.6.0 ed -s &quot;src/torrent/data/block_transfer.h&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF /#define LIBTORRENT_BLOCK_TRANSFER_H a #include &lt;stddef.h&gt; . w q EOF ed -s &quot;src/data/memory_chunk.cc&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF /#include &quot;config.h&quot; a #include &lt;stddef.h&gt; . w q EOF } installRtorrent() { buildStart buildRtorrent buildEnd } installUnrar() { isProgramInstalled unrar &amp;&amp; return installBuildTools buildMakeProgram &quot;$UNRAR_URL&quot; &quot;unrar&quot; &quot;&quot; &quot;unrar&quot; &quot;makefile.unix&quot; } installModScgi() { local modScgiFile=&quot;$1&quot; local modulesPath=&quot;$2&quot; [ -f &quot;$modScgiFile&quot; ] &amp;&amp; errorExit &quot;mod_scgi file already exists.&quot; [ -d &quot;$modulesPath&quot; ] || errorExit &quot;Apache modules path &#39;$modulesPath&#39; does not exist.&quot; buildMakeProgram &quot;$MOD_SCGI_URL&quot; &quot;mod_scgi&quot; &quot;apache2&quot; echo &quot;LoadModule scgi_module $modulesPath/mod_scgi.so&quot; &gt; $modScgiFile } isPortUsed() { local port=&quot;$1&quot; netstat -an | grep tcp | grep -w LISTEN | grep -qE &quot;[.:]$port[ ]&quot; &amp;&amp; return 0 return 1 } isValidIpAddress() { # It&#39;s not 100% accurate ... ;) echo $1 | grep -qE &#39;^[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?$&#39; } getIpAddress() { isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; &amp;&amp; return echo &quot;${CMSG}Detecting your IP address...$CEND&quot; isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; || OUR_IP_ADDRESS=$(wget --no-check-certificate http://www.whatismyip.com/automation/n09230945.asp -O - -o /dev/null) isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; || OUR_IP_ADDRESS=$(ifconfig -a | grep &quot;inet addr&quot; | head -n1 | awk -F: &#39;{print $2}&#39; | awk &#39;{print $1}&#39;) isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; || OUR_IP_ADDRESS=&quot;1.2.3.4&quot; } getNewPortNumber() { while true; do newPortNumber=$CURRENT_PORT CURRENT_PORT=$(expr $CURRENT_PORT + 1) isValidPortNumber $newPortNumber || errorExit &quot;Invalid port number. Change CURRENT_PORT.&quot; isPortUsed $newPortNumber || break echo &quot;${CWARNING}Port $newPortNumber is in use, trying next port...$CEND&quot; done } # Returns true if it&#39;s a valid ruTorrent base path isValidRutorrentBasePath() { [ -n &quot;$1&quot; ] &amp;&amp; [ -d &quot;$1/conf&quot; ] } isValidPassword() { echo &quot;$1&quot; | grep -qE &quot;^ &quot; &amp;&amp; return 1 echo &quot;$1&quot; | grep -qE &quot; \\$&quot; &amp;&amp; return 1 echo &quot;$1&quot; | grep -qE &#39;^$&#39; &amp;&amp; return 1 echo &quot;$1&quot; | grep -q &#39;:&#39; &amp;&amp; return 1 echo &quot;&#39;$1&#39;&quot; | grep -q &#39; &#39; &amp;&amp; return 1 return 0 } isValidPortNumber() { echo &quot;$1&quot; | grep -qiE &#39;^[0-9]+$&#39; || return 1 echo &quot;$1&quot; | grep -qiE &#39;[0-9][0-9][0-9][0-9][0-9][0-9]&#39; &amp;&amp; return 1 [ $1 -ge 1024 ] &amp;&amp; [ $1 -le 65535 ] } isValidWebUser() { [ -z &quot;$1&quot; ] &amp;&amp; return 1 echo &quot;$1&quot; | LC_ALL=C grep -qE &#39;[A-Z:]&#39; &amp;&amp; return 1 return 0 } initUsers() { local users= for packedUser in $USERS; do extractPackedUser $packedUser if [ -z &quot;$autodlPort&quot; ]; then getNewPortNumber autodlPort=$newPortNumber fi if [ -z &quot;$scgiPort&quot; ]; then getNewPortNumber scgiPort=$newPortNumber fi if [ -z &quot;$rtorrentPort&quot; ]; then getNewPortNumber rtorrentPort=$newPortNumber fi if canGeneratePasswords; then if [ -z &quot;$autodlPassword&quot; ]; then generatePassword autodlPassword=&quot;$newPassword&quot; fi fi users=&quot;$users $osUser:$autodlPassword:$webUser:$webPass:$autodlPort:$scgiPort:$rtorrentPort&quot; done USERS=&quot;$users&quot; } extractPackedUser() { local packedUser=&quot;$1&quot; osUser=&quot;$(echo $packedUser | cut -d: -f1)&quot; autodlPassword=&quot;$(echo $packedUser | cut -d: -f2)&quot; webUser=&quot;$(echo $packedUser | cut -d: -f3)&quot; webPass=&quot;$(echo $packedUser | cut -d: -f4)&quot; autodlPort=&quot;$(echo $packedUser | cut -d: -f5)&quot; scgiPort=&quot;$(echo $packedUser | cut -d: -f6)&quot; rtorrentPort=&quot;$(echo $packedUser | cut -d: -f7)&quot; } getUserGroup() { local user=&quot;$1&quot; userExists &quot;$user&quot; || errorExit &quot;The user &#39;$user&#39; does not exist.&quot; group=$(grep -w $(id -rg $user) /etc/group | cut -d: -f1) [ -z &quot;$group&quot; ] &amp;&amp; group=&quot;$user&quot; } getUserDir() { local user=&quot;$1&quot; [ -z &quot;$user&quot; ] &amp;&amp; errorExit &quot;Invalid user (blank).&quot; userDir=&quot;$(eval echo ~$user)&quot; [ -d &quot;$userDir&quot; ] || errorExit &quot;User $user&#39;s home directory does not exist.&quot; } resetOwner() { local user=&quot;$1&quot; shift if [ &quot;$ISROOT&quot; = y ]; then getUserGroup &quot;$user&quot; chown -R $user:$group &quot;$@&quot; fi } # Updates MISSING_PHP_MODULES with all missing required PHP modules detectMissingPhpModules() { MISSING_PHP_MODULES= local php=${WWW_PHP_CGI:-php} for module in $REQUIRED_PHP_MODULES; do $php -m 2&gt; /dev/null | grep -wq $module || MISSING_PHP_MODULES=&quot;$MISSING_PHP_MODULES $module&quot; done } installMissingPhpPackages() { PACKAGES= for module in $MISSING_PHP_MODULES; do PACKAGES=&quot;$PACKAGES php-$module&quot; done installPackages } installMissingPhp5Packages() { PACKAGES= for module in $MISSING_PHP_MODULES; do PACKAGES=&quot;$PACKAGES php5-$module&quot; done installPackages } enablePhpIniModules() { local phpIni=&quot;$1&quot; shift for module in &quot;$@&quot;; do grep -qE &quot;^extension=$module.so&quot; &quot;$phpIni&quot; &amp;&amp; continue sed_i &quot;s/^; *\\\\(extension=$module.so.*\\\\)/\\\\1/&quot; &quot;$phpIni&quot; grep -qE &quot;^extension=$module.so&quot; &quot;$phpIni&quot; &amp;&amp; continue echo &quot;extension=$module.so&quot; &gt;&gt; &quot;$phpIni&quot; done } installMissingPhpModules() { detectMissingPhpModules [ -z &quot;$MISSING_PHP_MODULES&quot; ] &amp;&amp; return osHandler_$os installPhpModules detectMissingPhpModules [ -z &quot;$MISSING_PHP_MODULES&quot; ] &amp;&amp; return cat &lt;&lt; EOF $CWARNING The following PHP modules appear to be missing: $MISSING_PHP_MODULES If the autodl-irssi ruTorrent plugin isn&#39;t working, you now know why. Install them using your package manager or enable them in your php.ini file, and restart your web server.$CEND EOF } addLogrotateConfig() { local serviceName=&quot;$1&quot; local logFiles=&quot;$2&quot; local postrotateScript=&quot;$3&quot; local logrotate_d=/etc/logrotate.d [ -d &quot;$logrotate_d&quot; ] || errorExit &quot;Missing logrotate dir: $logrotate_d&quot; cat &gt; &quot;$logrotate_d/$serviceName&quot; &lt;&lt; EOF $logFiles { missingok daily rotate 14 notifempty compress delaycompress sharedscripts postrotate $postrotateScript endscript } EOF [ $? -eq 0 ] || errorExit &quot;Could not write logrotate file $logrotate_d/$serviceName&quot; } detectPhpCgi() { WWW_PHP_CGI=${WWW_PHP_CGI:-$(which php-cgi | head -n1)} [ -x &quot;$WWW_PHP_CGI&quot; ] || errorExit &quot;Could not find php-cgi&quot; &quot;$WWW_PHP_CGI&quot; -v | grep -q &#39;cgi-fcgi&#39; || errorExit &quot;$WWW_PHP_CGI does not support FastCGI&quot; } # $i is the i&#39;th user number getUserRpcMount() { local i=$1 verifyWebServerVars # Make sure /RPC10 accesses aren&#39;t going to /RPC1 by padding with zeros. This is # easier than making sure every web server handles it correctly. Eg., lighttpd&#39;s # scgi.server table is read in order, so if you add /RPC1 before /RPC10, then # /RPC10 accesses will go to /RPC1. A fix would of course be to place /RPC10 # before /RPC1 but it&#39;s easy to forget. Now we use /RPC00001 .. /RPC99999 echo &quot;/$RPC_PREFIX$(printf &#39;%05d&#39; $i)&quot; } createSelfSignedCertFile() { local pemfile=&quot;$1&quot; if [ ! -f &quot;$OTHER_PEM_FILE&quot; ]; then echo &quot;${CMSG}Creating the self-signed certificate.$CEND&quot; rm -f &quot;$pemfile&quot; openssl req -new -newkey rsa:1024 -days 1000 -nodes -x509 -keyout &quot;$pemfile&quot; -out &quot;$pemfile&quot; -batch \\ || errorExit &quot;Failed to create self-signed certificate.&quot; OTHER_PEM_FILE=&quot;$pemfile&quot; CREATED_CERT_FILE=y else rm -f &quot;$pemfile&quot; cp &quot;$OTHER_PEM_FILE&quot; &quot;$pemfile&quot; || errorExit &quot;Failed to copy self-signed certificate.&quot; fi chmod 0600 &quot;$pemfile&quot; } detectHtpasswd() { [ -z &quot;$htpasswd&quot; ] &amp;&amp; isProgramInstalled htpasswd &amp;&amp; htpasswd=htpasswd [ -z &quot;$htpasswd&quot; ] &amp;&amp; isProgramInstalled htpasswd2 &amp;&amp; htpasswd=htpasswd2 if [ -z &quot;$htpasswd&quot; ]; then installProgram python if isProgramInstalled python; then cd downloadFile &quot;htpasswd.py&quot; &quot;$HTPASSWD_PY_SCRIPT_URL&quot; &quot;$HTPASSWD_PY_SCRIPT_URL2&quot; \\ &amp;&amp; htpasswd=&quot;python $(pwd)/htpasswd.py&quot; fi fi [ -z &quot;$htpasswd&quot; ] &amp;&amp; errorExit &quot;Could not find htpasswd&quot; } verifyWebServerVars() { [ -z &quot;$WWW_PEMFILE&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_PEMFILE&quot; [ -z &quot;$WWW_PASSWORD_FILE&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_PASSWORD_FILE&quot; [ -z &quot;$WWW_ROOT&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_ROOT&quot; [ -z &quot;$WWW_USER&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_USER&quot; [ -z &quot;$WWW_GROUP&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_GROUP&quot; } initializeWwwRootVar() { WWW_ROOT=${WWW_ROOT:-/var/rutorrent} } createWebServerUserGroup() { verifyWebServerVars if ! grep -qE &quot;^$WWW_GROUP:&quot; /etc/group; then groupadd -r $WWW_GROUP 2&gt;/dev/null || groupadd $WWW_GROUP || errorExit &quot;Could not create web server group.&quot; fi if ! grep -qE &quot;^$WWW_USER:&quot; /etc/passwd; then local useradd=&quot;useradd -d $WWW_ROOT -g $WWW_GROUP -s /bin/sh&quot; $useradd -M -r $WWW_USER 2&gt;/dev/null || $useradd $WWW_USER || errorExit &quot;Could not create web server user.&quot; fi } resetAuthPasswordFilePermissions() { [ -n &quot;$WWW_USER&quot; ] || errorExit &quot;WWW_USER not initialized&quot; [ -n &quot;$WWW_GROUP&quot; ] || errorExit &quot;WWW_GROUP not initialized&quot; chmod 0400 &quot;$WWW_PASSWORD_FILE&quot;* chown $WWW_USER:$WWW_GROUP &quot;$WWW_PASSWORD_FILE&quot;* } createAuthPasswordFile() { verifyWebServerVars : &gt; &quot;$WWW_PASSWORD_FILE&quot; resetAuthPasswordFilePermissions } # Some web servers (eg. nginx) can&#39;t allow just ONE user access to a certain # location. To fix that, create one password file per user. createOnePasswordFilePerUser() { for packedUser in $USERS; do extractPackedUser $packedUser grep &quot;^$webUser:&quot; &quot;$WWW_PASSWORD_FILE&quot; &gt; &quot;${WWW_PASSWORD_FILE}_$webUser&quot; done resetAuthPasswordFilePermissions } updatePhpTimezone() { if [ ! -f &quot;$WWW_PHP_INI&quot; ]; then echo &quot;${CWARNING}Could not find php.ini file: $WWW_PHP_INI$CEND&quot; return fi [ -z &quot;$USER_TIMEZONE&quot; ] &amp;&amp; return local zws=&quot;[ ]*&quot; local newLine=&quot;date.timezone = $USER_TIMEZONE&quot; if grep -qE &quot;^${zws}date\\\\.timezone[ =]&quot; &quot;$WWW_PHP_INI&quot;; then return elif grep -qE &quot;^${zws}[;#]${zws}date\\\\.timezone[ =]&quot; &quot;$WWW_PHP_INI&quot;; then sed_i &quot;s!^${zws}[;#]${zws}date\\\\.timezone[ =].*\\$!$newLine!&quot; &quot;$WWW_PHP_INI&quot; else cat &gt;&gt; &quot;$WWW_PHP_INI&quot; &lt;&lt; EOF [Date] $newLine EOF fi } doDetectTimeZone() { echo &quot;${CMSG}Detecting timezone...$CEND&quot; detectTimeZone if [ -n &quot;$USER_TIMEZONE&quot; ]; then echo &quot;${CMSG}Timezone: $USER_TIMEZONE$CEND&quot; updatePhpTimezone else echo &quot;${CWARNING}Could not detect timezone!$CEND&quot; fi } webServerCommonInitialization() { mkdir -p $WWW_ROOT doDetectTimeZone createSelfSignedCertFile &quot;$WWW_PEMFILE&quot; createAuthPasswordFile } resetWebServerPermissions() { verifyWebServerVars chown -R $WWW_USER:$WWW_GROUP $WWW_ROOT || errorExit &quot;Could not set web server as owner of $WWW_ROOT&quot; } createPhpcgiSocket() { PHPCGI_SOCKET_DIR=/etc/phpcgi PHPCGI_SOCKET_FILE=&quot;$PHPCGI_SOCKET_DIR/php-cgi.socket&quot; mkdir -p &quot;$PHPCGI_SOCKET_DIR&quot; chown $WWW_USER:$WWW_GROUP &quot;$PHPCGI_SOCKET_DIR&quot; chmod 0770 &quot;$PHPCGI_SOCKET_DIR&quot; } verifyApacheServerVars() { verifyWebServerVars [ -z &quot;$APACHE_SITE_FILE&quot; ] &amp;&amp; errorExit &quot;You have not initialized APACHE_SITE_FILE&quot; } apacheCreateApxs2Symlink() { # The makefile uses apxs2, so make a symlink if ! isProgramInstalled apxs2; then local apxs=$(which apxs 2&gt;/dev/null) &amp;&amp; ln -s &quot;$apxs&quot; &quot;${apxs}2&quot; fi } initializeApacheVars() { local apacheUser=&quot;$1&quot; local apacheGroup=&quot;$2&quot; local apacheSitesDir=&quot;$3&quot; [ -n &quot;$apacheUser&quot; ] || errorExit &quot;Invalid apache user: $apacheUser&quot; [ -n &quot;$apacheGroup&quot; ] || errorExit &quot;Invalid apache group: $apacheGroup&quot; [ -d &quot;$apacheSitesDir&quot; ] || errorExit &quot;Invalid apache sites dir: $apacheSitesDir&quot; [ -d &quot;$APACHE_DIR&quot; ] || errorExit &quot;Invalid apache dir: $APACHE_DIR&quot; APACHE_SITE_NAME=${APACHE_SITE_NAME:-rutorrent.conf} APACHE_SITE_FILE=$apacheSitesDir/$APACHE_SITE_NAME initializeWwwRootVar WWW_PASSWORD_FILE=$APACHE_DIR/rutorrent_passwd WWW_PEMFILE=$APACHE_DIR/rutorrent.pem WWW_USER=&quot;$apacheUser&quot; WWW_GROUP=&quot;$apacheGroup&quot; } apacheGetRpcLocationDirectives() { if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then local i=1 for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount=&quot;$(getUserRpcMount $i)&quot; cat &lt;&lt; EOF &lt;Location &quot;$rpcMount&quot;&gt; AuthType Basic AuthName &quot;$RUTORRENT_SITE_REALM&quot; AuthUserFile &quot;$WWW_PASSWORD_FILE&quot; Require user $webUser &lt;/Location&gt; EOF i=$(expr $i + 1) done fi } apacheGetVirtualHost() { local port=$1 local ssl=$2 cat &lt;&lt; EOF &lt;VirtualHost *:$port&gt; $(if [ &quot;$ssl&quot; = y ]; then echo &quot; SSLEngine On&quot; echo &quot; SSLCertificateFile $WWW_PEMFILE&quot; fi) ServerAdmin admin@rutorrent ServerName localhost DocumentRoot $WWW_ROOT &lt;Directory /&gt; AllowOverride None Order deny,allow Deny from all &lt;/Directory&gt; &lt;Location /&gt; AuthType Basic AuthName &quot;$RUTORRENT_SITE_REALM&quot; AuthUserFile &quot;$WWW_PASSWORD_FILE&quot; Require valid-user Order allow,deny Allow from all &lt;/Location&gt; &lt;Location ~ &quot;^/rutorrent/(conf|share)&quot;&gt; Order deny,allow Deny from all &lt;/Location&gt; &lt;Location ~ &quot;/\\\\\\\\.svn&quot;&gt; Order deny,allow Deny from all &lt;/Location&gt; $(apacheGetRpcLocationDirectives) &lt;/VirtualHost&gt; EOF } apacheWriteSiteFile() { verifyApacheServerVars cat &gt; &quot;$APACHE_SITE_FILE&quot; &lt;&lt; EOF ServerName localhost $(apacheGetVirtualHost $HTTP_PORT n) $(apacheGetVirtualHost $HTTPS_PORT y) EOF if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount=&quot;$(getUserRpcMount $i)&quot; echo &quot;${lp}SCGIMount $rpcMount $SCGI_HOST:$scgiPort&quot; &gt;&gt; &quot;$APACHE_SITE_FILE&quot; i=$(expr $i + 1) done fi } apacheCommonInitialization() { local buildTools=&quot;$1&quot; local modulesDir=&quot;$2&quot; webServerCommonInitialization apacheWriteSiteFile if [ -n &quot;$APACHE_SCGI_FILE&quot; ] &amp;&amp; [ ! -f &quot;$APACHE_SCGI_FILE&quot; ]; then installBuildTools PACKAGES=&quot;$buildTools&quot; installPackages apacheCreateApxs2Symlink # Compiling mod_scgi will fail unless we remove this warning-as-error flag local configVarsFile=&quot;$APACHE_DIR/modules/build/config_vars.mk&quot; [ -f &quot;$configVarsFile&quot; ] &amp;&amp; sed_i &#39;s/-Werror=format-security//g&#39; &quot;$configVarsFile&quot; installModScgi &quot;$APACHE_SCGI_FILE&quot; &quot;$modulesDir&quot; fi } installCommonWebServerStuff_mandriva() { # Also add some extra tools for ruTorrent and some of its plugins PACKAGES=&quot;php-cli gzip curl openssl logrotate&quot; installPackages PACKAGE=&quot;unrar&quot; installPackages PACKAGES=&quot;php-geoip&quot; installPackages } # Used by Mandriva, Unity Linux, and PCLinuxOS installApache_mandriva() { installCommonWebServerStuff_mandriva PACKAGES=&quot;apache-mpm-prefork apache-mod_ssl apache-mod_php&quot; installPackages WWW_PHP_INI=/etc/php.ini APACHE_DIR=/etc/httpd local APACHE_CONF_D=$APACHE_DIR/conf.d local APACHE_SITES_DIR=$APACHE_DIR/conf/vhosts.d APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf initializeApacheVars apache apache &quot;$APACHE_SITES_DIR&quot; apacheCommonInitialization &quot;libopenssl-devel apache-devel&quot; $APACHE_DIR/modules for file in 00_default_vhosts.conf 01_default_ssl_vhost.conf; do [ -f &quot;$APACHE_SITES_DIR/$file&quot; ] &amp;&amp; mv -f &quot;$APACHE_SITES_DIR/$file&quot; &quot;$APACHE_SITES_DIR/$file-bak&quot; done resetWebServerPermissions chkconfig httpd on service httpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; } installCommonWebServerStuff_gentoo() { # Also add some extra tools for ruTorrent and some of its plugins PACKAGES=&quot;dev-lang/php logrotate&quot; addProgram gzip app-arch/gzip addProgram curl net-misc/curl addProgram openssl dev-libs/openssl addProgram unrar app-arch/unrar installPackages ACCEPT_LICENSE=MaxMind export ACCEPT_LICENSE PACKAGES=&quot;dev-php5/pecl-geoip&quot; installPackages unset ACCEPT_LICENSE } installApache_gentoo() { installCommonWebServerStuff_gentoo PACKAGES=&quot;www-servers/apache app-admin/apache-tools&quot; installPackages PACKAGES=&quot;www-apache/mod_scgi&quot; installPackages WWW_PHP_INI=$(ls /etc/php/apache2-php5*/php.ini | tail -n1) [ -f &quot;$WWW_PHP_INI&quot; ] || errorExit &quot;Could not find Apache php.ini file&quot; APACHE_DIR=/etc/apache2 local APACHE_CONF=$APACHE_DIR/httpd.conf local APACHE_SITES_DIR=$APACHE_DIR/vhosts.d local SERVER_ROOT=$(grep -E ^ServerRoot $APACHE_CONF | head -n1 | sed -e &#39;s!^.*[ ][^/]*\\(/[^&quot;]*\\).*!\\1!&#39;) APACHE_SCGI_FILE=&quot;$APACHE_DIR/modules.d/scgi.conf&quot; [ -d &quot;$SERVER_ROOT&quot; ] || errorExit &quot;Apache server root dir does not exist: $SERVER_ROOT&quot; initializeApacheVars apache apache &quot;$APACHE_SITES_DIR&quot; apacheCommonInitialization &quot;&quot; $SERVER_ROOT/modules for file in 00_default_ssl_vhost.conf 00_default_vhost.conf; do [ -f &quot;$APACHE_SITES_DIR/$file&quot; ] &amp;&amp; mv -f &quot;$APACHE_SITES_DIR/$file&quot; &quot;$APACHE_SITES_DIR/$file-bak&quot; done appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS &quot;-D SCGI&quot; appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS &quot;-D PHP5&quot; appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS &quot;-D SSL&quot; cat &gt;&gt; $APACHE_SITE_FILE &lt;&lt; EOF Listen $HTTP_PORT Listen $HTTPS_PORT EOF resetWebServerPermissions rc-update add apache2 default osHandler_$os restart_$INSTALL_WEB_SERVER } nginxGetRpcMounts() { if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser getUserScgiSocketPath &quot;$osUser&quot; local rpcMount=&quot;$(getUserRpcMount $i)&quot; cat &lt;&lt; EOF $lp location ~ ^$rpcMount\\$ { $lp include scgi_params; $lp scgi_pass unix:$scgiSocketPath; $lp auth_basic &quot;$RUTORRENT_SITE_REALM&quot;; $lp auth_basic_user_file &quot;${WWW_PASSWORD_FILE}_$webUser&quot;; $lp } EOF i=$(expr $i + 1) done fi } nginxGetServerSection() { local port=$1 local ssl=$2 cat &lt;&lt; EOF server { listen $port; server_name localhost; auth_basic &quot;$RUTORRENT_SITE_REALM&quot;; auth_basic_user_file &quot;$WWW_PASSWORD_FILE&quot;; $(if [ &quot;$ssl&quot; = y ]; then cat &lt;&lt; EOF2 ssl on; ssl_certificate $WWW_PEMFILE; ssl_certificate_key $WWW_PEMFILE; EOF2 fi) location ~ ^/rutorrent/(?:share|conf) { deny all; } location ~ /\\.ht { deny all; } location ~ /\\.svn { deny all; } location / { root $WWW_ROOT; index index.php index.html index.htm; } location ~ \\.php$ { root &quot;$WWW_ROOT&quot;; fastcgi_pass unix:$PHPCGI_SOCKET_FILE; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME \\$document_root\\$fastcgi_script_name; include fastcgi_params; } $(nginxGetRpcMounts) } EOF } nginxWriteConfFile() { getNumCpus cat &gt; $NGINX_CONF &lt;&lt; EOF worker_processes $NUMCPUS; user $WWW_USER $WWW_GROUP; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # I have to set min length to 0 and http version to 1.0 or it won&#39;t compress # the XML-RPC (SCGI) responses. Those responses can be quite large if you&#39;re # using many torrent files. gzip on; gzip_min_length 0; gzip_http_version 1.0; gzip_types text/plain text/xml application/xml application/json text/css application/x-javascript text/javascript application/javascript; $(nginxGetServerSection $HTTP_PORT n) $(nginxGetServerSection $HTTPS_PORT y) } EOF [ $? -eq 0 ] || errorExit &quot;Could not write to file $NGINX_CONF&quot; } buildNginx() { buildStart PREFIX=$NGINX_DIR NGINX_BIN=$PREFIX/sbin/nginx NGINX_CONF=$PREFIX/conf/nginx.conf NGINX_PID_FILE=$PREFIX/nginx.pid NGINX_ACCESS_LOG=$PREFIX/logs/access.log NGINX_ERROR_LOG=$PREFIX/logs/error.log local configureFlags=&quot;\\ --prefix=$PREFIX \\ --sbin-path=$NGINX_BIN \\ --conf-path=$NGINX_CONF \\ --pid-path=$NGINX_PID_FILE \\ --lock-path=$PREFIX/logs/nginx.lock \\ --error-log-path=$NGINX_ERROR_LOG \\ --http-log-path=$NGINX_ACCESS_LOG \\ --user=$WWW_USER \\ --group=$WWW_GROUP \\ --with-http_ssl_module&quot; export CFLAGS=&quot;$NGINX_CFLAGS&quot; downloadAndBuild &quot;nginx&quot; &quot;$NGINX_URL&quot; &quot;$NGINX_NAME&quot; &quot;$configureFlags&quot; patchNginx unset CFLAGS buildEnd } patchNginx() { # Get rid of the -Werror flag for gcc 4.6.0 sed_i &quot;s!-Werror[a-zA-Z0-9=-]*!!&quot; &quot;auto/cc/gcc&quot; } installNginx() { SCGI_USE_UNIX_DOMAIN_SOCKET=y CREATE_ONE_PASSWORD_FILE_PER_USER=y installBuildTools osHandler_$os preNginxInstall installUnrar NGINX_DIR=/usr/local/nginx initializeWwwRootVar WWW_PASSWORD_FILE=$NGINX_DIR/rutorrent_passwd WWW_PEMFILE=$NGINX_DIR/rutorrent.pem WWW_USER=${WWW_USER:-nginx} WWW_GROUP=${WWW_GROUP:-nginx} detectPhpCgi createWebServerUserGroup createPhpcgiSocket buildNginx webServerCommonInitialization nginxWriteConfFile addLogrotateConfig nginx \\ &quot;$NGINX_ACCESS_LOG $NGINX_ERROR_LOG&quot; \\ &quot;[ -f \\&quot;$NGINX_PID_FILE\\&quot; ] &amp;&amp; kill -USR1 \\$(cat \\&quot;$NGINX_PID_FILE\\&quot;) &gt;/dev/null 2&gt;&amp;1; true&quot; resetWebServerPermissions osHandler_$os installPhpCgiService osHandler_$os installNginxService } preNginxInstall_gentoo() { installCommonWebServerStuff_gentoo PACKAGES=&quot;libpcre openssl zlib php&quot; installPackages WWW_PHP_INI=$(ls /etc/php/cgi-php5*/php.ini | tail -n1) [ -f &quot;$WWW_PHP_INI&quot; ] || errorExit &quot;Could not find php-cgi php.ini file&quot; } preLighttpdInstall_gentoo() { preNginxInstall_gentoo } lighttpdGetRpcRequire() { if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then local i=1 for packedUser in $USERS; do extractPackedUser $packedUser local rpcMount=&quot;$(getUserRpcMount $i)&quot; cat &lt;&lt; EOF &quot;$rpcMount&quot; =&gt; ( &quot;method&quot; =&gt; &quot;basic&quot;, &quot;realm&quot; =&gt; &quot;$RUTORRENT_SITE_REALM&quot;, &quot;require&quot; =&gt; &quot;user=$webUser&quot;, ), EOF i=$(expr $i + 1) done fi } lighttpdGetScgiServerTable() { echo &#39;scgi.server = (&#39; if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then local i=1 local lp=; isWebServerRpcModule || lp=&#39;#&#39; for packedUser in $USERS; do extractPackedUser $packedUser getUserScgiSocketPath &quot;$osUser&quot; local rpcMount=&quot;$(getUserRpcMount $i)&quot; cat &lt;&lt; EOF $lp &quot;$rpcMount&quot; =&gt; ( $lp ( $lp &quot;socket&quot; =&gt; &quot;$scgiSocketPath&quot;, $lp &quot;check-local&quot; =&gt; &quot;disable&quot;, $lp &quot;disable-time&quot; =&gt; 0, $lp ), $lp ), EOF i=$(expr $i + 1) done fi echo &#39;)&#39; } lighttpdWriteConfFile() { cat &gt; $LIGHTTPD_CONF &lt;&lt; EOF server.follow-symlink = &quot;disable&quot; server.max-connections = 512 server.max-fds = 1024 server.max-keep-alive-idle = 15 dir-listing.activate = &quot;disable&quot; server.pid-file = &quot;$LIGHTTPD_PID_FILE&quot; server.errorlog = &quot;$LIGHTTPD_ERROR_LOG&quot; accesslog.filename = &quot;$LIGHTTPD_ACCESS_LOG&quot; $(if [ $(uname -s) = Linux ]; then echo &#39;server.event-handler = &quot;linux-sysepoll&quot;&#39; echo &#39;server.network-backend = &quot;linux-sendfile&quot;&#39; fi) server.username = &quot;$WWW_USER&quot; server.groupname = &quot;$WWW_GROUP&quot; server.modules = ( # &quot;mod_rewrite&quot;, # &quot;mod_redirect&quot;, # &quot;mod_alias&quot;, &quot;mod_access&quot;, &quot;mod_auth&quot;, # &quot;mod_status&quot;, # &quot;mod_simple_vhost&quot;, # &quot;mod_evhost&quot;, # &quot;mod_userdir&quot;, # &quot;mod_secdownload&quot;, &quot;mod_fastcgi&quot;, # &quot;mod_proxy&quot;, # &quot;mod_cgi&quot;, &quot;mod_scgi&quot;, # &quot;mod_ssi&quot;, # &quot;mod_compress&quot;, # &quot;mod_usertrack&quot;, # &quot;mod_expire&quot;, # &quot;mod_rrdtool&quot;, &quot;mod_accesslog&quot;, ) fastcgi.server = ( &quot;.php&quot; =&gt; ( ( &quot;socket&quot; =&gt; &quot;$PHPCGI_SOCKET_FILE&quot;, ), ), ) index-file.names = ( &quot;index.php&quot;, &quot;index.html&quot;, &quot;index.htm&quot; ) static-file.exclude-extensions = ( &quot;.fcgi&quot;, &quot;.php&quot;, &quot;.rb&quot;, &quot;~&quot;, &quot;.inc&quot; ) mimetype.assign = ( &quot;.html&quot; =&gt; &quot;text/html&quot;, &quot;.htm&quot; =&gt; &quot;text/html&quot;, &quot;.txt&quot; =&gt; &quot;text/plain&quot;, &quot;.csv&quot; =&gt; &quot;text/plain&quot;, &quot;.ini&quot; =&gt; &quot;text/plain&quot;, &quot;.jpg&quot; =&gt; &quot;image/jpeg&quot;, &quot;.jpeg&quot; =&gt; &quot;image/jpeg&quot;, &quot;.gif&quot; =&gt; &quot;image/gif&quot;, &quot;.png&quot; =&gt; &quot;image/png&quot;, &quot;.bmp&quot; =&gt; &quot;image/bmp&quot;, &quot;.css&quot; =&gt; &quot;text/css&quot;, &quot;.js&quot; =&gt; &quot;application/javascript&quot;, &quot;.ico&quot; =&gt; &quot;image/x-icon&quot;, &quot;.json&quot; =&gt; &quot;application/json&quot;, &quot;.torrent&quot; =&gt; &quot;application/x-bittorrent&quot;, &quot;.pdf&quot; =&gt; &quot;application/pdf&quot;, &quot;.bz2&quot; =&gt; &quot;application/x-bzip2&quot;, &quot;.gz&quot; =&gt; &quot;application/x-gzip&quot;, &quot;.tar.gz&quot; =&gt; &quot;application/x-tgz&quot;, &quot;.tar&quot; =&gt; &quot;application/x-tar&quot;, &quot;.tar.bz2&quot; =&gt; &quot;application/x-bzip-compressed-tar&quot;, &quot;.tbz&quot; =&gt; &quot;application/x-bzip-compressed-tar&quot;, &quot;.tgz&quot; =&gt; &quot;application/x-tgz&quot;, &quot;.zip&quot; =&gt; &quot;application/zip&quot;, &quot;.mp3&quot; =&gt; &quot;audio/mpeg&quot;, &quot;.flac&quot; =&gt; &quot;audio/x-flac&quot;, &quot;.m3u&quot; =&gt; &quot;audio/x-mpegurl&quot;, &quot;.wma&quot; =&gt; &quot;audio/x-ms-wma&quot;, &quot;.wax&quot; =&gt; &quot;audio/x-ms-wax&quot;, &quot;.ogg&quot; =&gt; &quot;audio/ogg&quot;, &quot;.wav&quot; =&gt; &quot;audio/x-wav&quot;, &quot;.dtd&quot; =&gt; &quot;text/xml&quot;, &quot;.xml&quot; =&gt; &quot;text/xml&quot;, &quot;.mpeg&quot; =&gt; &quot;video/mpeg&quot;, &quot;.mpg&quot; =&gt; &quot;video/mpeg&quot;, &quot;.mp4&quot; =&gt; &quot;video/mp4&quot;, &quot;.wmv&quot; =&gt; &quot;video/x-ms-wmv&quot;, &quot;.avi&quot; =&gt; &quot;video/x-msvideo&quot;, ) server.document-root = &quot;$WWW_ROOT&quot; server.port = $HTTP_PORT \\$SERVER[&quot;socket&quot;] == &quot;:$HTTPS_PORT&quot; { ssl.engine = &quot;enable&quot; ssl.pemfile = &quot;$WWW_PEMFILE&quot; } url.access-deny = (&quot;.htaccess&quot;) \\$HTTP[&quot;url&quot;] =~ &quot;^/rutorrent/(?:share|conf)&quot; { url.access-deny = (&quot;&quot;) } \\$HTTP[&quot;url&quot;] =~ &quot;/\\\\.svn&quot; { url.access-deny = (&quot;&quot;) } auth.backend = &quot;htpasswd&quot; auth.backend.htpasswd.userfile = &quot;$WWW_PASSWORD_FILE&quot; auth.require = ( $(lighttpdGetRpcRequire) &quot;/&quot; =&gt; ( &quot;method&quot; =&gt; &quot;basic&quot;, &quot;realm&quot; =&gt; &quot;$RUTORRENT_SITE_REALM&quot;, &quot;require&quot; =&gt; &quot;valid-user&quot;, ), ) $(lighttpdGetScgiServerTable) EOF [ $? -eq 0 ] || errorExit &quot;Could not write to file $LIGHTTPD_CONF&quot; } buildLighttpd() { buildStart PREFIX=$LIGHTTPD_DIR LIGHTTPD_BIN=$PREFIX/sbin/lighttpd LIGHTTPD_CONF=$PREFIX/lighttpd.conf # The log dir will be set to owner lighttpd since it&#39;s started as non-root. # Put the pid file there so it can write to it. LIGHTTPD_LOG_DIR=$PREFIX/logs LIGHTTPD_PID_FILE=$LIGHTTPD_LOG_DIR/lighttpd.pid LIGHTTPD_ERROR_LOG=$LIGHTTPD_LOG_DIR/error.log LIGHTTPD_ACCESS_LOG=$LIGHTTPD_LOG_DIR/access.log local configureFlags=&quot;\\ --prefix=$PREFIX \\ --with-openssl \\ --with-pcre \\ --with-zlib \\ --without-bzip2&quot; downloadAndBuild &quot;lighttpd&quot; &quot;$LIGHTTPD_URL&quot; &quot;$LIGHTTPD_NAME&quot; &quot;$configureFlags&quot; buildEnd } installLighttpd() { SCGI_USE_UNIX_DOMAIN_SOCKET=y installBuildTools osHandler_$os preLighttpdInstall installUnrar LIGHTTPD_DIR=/usr/local/lighttpd initializeWwwRootVar WWW_PASSWORD_FILE=$LIGHTTPD_DIR/rutorrent_passwd WWW_PEMFILE=$LIGHTTPD_DIR/rutorrent.pem WWW_USER=${WWW_USER:-lighttpd} WWW_GROUP=${WWW_GROUP:-lighttpd} detectPhpCgi createWebServerUserGroup createPhpcgiSocket buildLighttpd webServerCommonInitialization lighttpdWriteConfFile addLogrotateConfig lighttpd \\ &quot;$LIGHTTPD_ACCESS_LOG $LIGHTTPD_ERROR_LOG&quot; \\ &quot;[ -f \\&quot;$LIGHTTPD_PID_FILE\\&quot; ] &amp;&amp; kill -HUP \\$(cat \\&quot;$LIGHTTPD_PID_FILE\\&quot;) &gt;/dev/null 2&gt;&amp;1; true&quot; mkdir -p &quot;$LIGHTTPD_LOG_DIR&quot; chown -R $WWW_USER:$WWW_GROUP &quot;$LIGHTTPD_LOG_DIR&quot; resetWebServerPermissions osHandler_$os installPhpCgiService osHandler_$os installLighttpdService } # Add $name=$value to the file, or modify an existing line if present in the file setVsftpdValue() { local confFile=&quot;$1&quot; local name=&quot;$2&quot; local value=&quot;$3&quot; local newLine=&quot;$name=$value&quot; sed_i &quot;s!^[ ]*$name[ =:].*\\$!$newLine!&quot; &quot;$confFile&quot; grep -qE &quot;^$newLine$&quot; &quot;$confFile&quot; || echo &quot;$newLine&quot; &gt;&gt; &quot;$confFile&quot; } # Same as setVsftpdValue but makes sure the option exists setVsftpdValue2() { local confFile=&quot;$1&quot; local name=&quot;$2&quot; local value=&quot;$3&quot; [ -z &quot;$VSFTPD_PATH&quot; ] &amp;&amp; return grep -q &quot;$name&quot; &quot;$VSFTPD_PATH&quot; &amp;&amp; setVsftpdValue &quot;$confFile&quot; &quot;$name&quot; &quot;$value&quot; } updateVsftpdConf() { local confFile=&quot;$1&quot; touch &quot;$confFile&quot; VSFTPD_PATH=$(which vsftpd 2&gt;/dev/null) setVsftpdValue &quot;$confFile&quot; anonymous_enable NO setVsftpdValue &quot;$confFile&quot; dirlist_enable YES setVsftpdValue &quot;$confFile&quot; download_enable YES setVsftpdValue &quot;$confFile&quot; guest_enable NO setVsftpdValue &quot;$confFile&quot; listen YES setVsftpdValue &quot;$confFile&quot; listen_ipv6 NO setVsftpdValue &quot;$confFile&quot; local_enable YES setVsftpdValue &quot;$confFile&quot; local_umask $DEFAULT_UMASK setVsftpdValue &quot;$confFile&quot; max_per_ip 0 setVsftpdValue &quot;$confFile&quot; pasv_enable YES setVsftpdValue &quot;$confFile&quot; port_enable YES setVsftpdValue &quot;$confFile&quot; pasv_promiscuous NO setVsftpdValue &quot;$confFile&quot; port_promiscuous NO setVsftpdValue &quot;$confFile&quot; pasv_min_port 0 setVsftpdValue &quot;$confFile&quot; pasv_max_port 0 setVsftpdValue &quot;$confFile&quot; write_enable YES if [ &quot;$USE_ENCRYPTED_FTP&quot; = y ]; then local pemfile=/etc/vsftpd.pem createSelfSignedCertFile &quot;$pemfile&quot; FTP_SERVER_TYPE=&quot;FTPES - Encrypted (FTP over explicit TLS/SSL)&quot; FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTPES} setVsftpdValue &quot;$confFile&quot; listen_port $FTP_PORT setVsftpdValue &quot;$confFile&quot; ssl_enable YES setVsftpdValue &quot;$confFile&quot; allow_anon_ssl NO setVsftpdValue &quot;$confFile&quot; force_local_data_ssl YES setVsftpdValue &quot;$confFile&quot; force_local_logins_ssl YES setVsftpdValue &quot;$confFile&quot; ssl_sslv2 NO setVsftpdValue &quot;$confFile&quot; ssl_sslv3 NO setVsftpdValue &quot;$confFile&quot; ssl_tlsv1 YES setVsftpdValue &quot;$confFile&quot; rsa_cert_file &quot;$pemfile&quot; setVsftpdValue2 &quot;$confFile&quot; implicit_ssl NO setVsftpdValue2 &quot;$confFile&quot; require_cert NO setVsftpdValue2 &quot;$confFile&quot; require_ssl_reuse NO setVsftpdValue2 &quot;$confFile&quot; ssl_request_cert YES setVsftpdValue2 &quot;$confFile&quot; strict_ssl_read_eof NO setVsftpdValue2 &quot;$confFile&quot; strict_ssl_write_shutdown NO setVsftpdValue2 &quot;$confFile&quot; validate_cert NO else FTP_SERVER_TYPE=&quot;FTP - Non-encrypted&quot; FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTP} setVsftpdValue &quot;$confFile&quot; listen_port $FTP_PORT setVsftpdValue &quot;$confFile&quot; ssl_enable NO fi # The private key is in rsa_cert_file sed_i &#39;g/rsa_private_key_file/d&#39; &quot;$confFile&quot; } installVsftpd_chkconfig() { local vsftpdConf=&quot;$1&quot; installProgram vsftpd [ -f &quot;$vsftpdConf&quot; ] || errorExit &quot;Invalid vsftpd.conf file: $vsftpdConf&quot; updateVsftpdConf &quot;$vsftpdConf&quot; chkconfig vsftpd on if ! service vsftpd restart; then if [ &quot;$SELINUX_ENABLED&quot; = y ]; then errorExit &quot;Could not restart vsftpd. SELinux could be the reason.&quot; else errorExit &quot;Could not restart vsftpd&quot; fi fi } installVsftpd_gentoo() { installProgram net-ftp/vsftpd local vsftpdConf=/etc/vsftpd/vsftpd.conf if ! [ -f $vsftpdConf ]; then touch $vsftpdConf [ -f $vsftpdConf.example ] &amp;&amp; cp $vsftpdConf.example $vsftpdConf fi updateVsftpdConf $vsftpdConf rc-update add vsftpd default /etc/init.d/vsftpd restart } installService_chkconfig1() { CHKCONFIG_SERVICE_NAME=$1 CHKCONFIG_SERVICE_FILE=/etc/init.d/$CHKCONFIG_SERVICE_NAME CHKCONFIG_LOCK_FILE=/var/lock/subsys/$CHKCONFIG_SERVICE_NAME } installService_chkconfig2() { chmod +x &quot;$CHKCONFIG_SERVICE_FILE&quot; || errorExit &quot;Could not set +x bit, file $CHKCONFIG_SERVICE_FILE.&quot; chkconfig --add $CHKCONFIG_SERVICE_NAME || errorExit &quot;Could not install service $CHKCONFIG_SERVICE_FILE. Run this script as root.&quot; service $CHKCONFIG_SERVICE_NAME restart } getChkconfigScriptContents() { local desc=&quot;$1&quot; cat &lt;&lt; EOF # chkconfig: 2345 85 15 # description: $desc EOF } getLsbStartupScriptContents() { local startupName=&quot;$1&quot; local desc=&quot;$2&quot; cat &lt;&lt; EOF ### BEGIN INIT INFO # Provides: $startupName # Required-Start: \\$local_fs \\$network \\$syslog # Required-Stop: \\$local_fs \\$syslog # Default-Start: $LSB_DEFAULT_START # Default-Stop: $LSB_DEFAULT_STOP # Short-Description: $desc # Description: $desc ### END INIT INFO EOF } # You must define v_{startIt,stopIt,restartIt,showStatus} and isStarted funcs getLsbStartupFooter() { cat &lt;&lt; EOF resetPath # Some include files may have reset it LOCKFILE=$1 updateLock() { [ -z &quot;\\$LOCKFILE&quot; ] &amp;&amp; return if isStarted; then touch \\$LOCKFILE else rm -f \\$LOCKFILE fi } RETVAL=0 case \\$1 in start) v_startIt ;; stop) v_stopIt ;; force-reload|restart) v_restartIt ;; try-restart) isStarted &amp;&amp; v_restartIt ;; status) v_showStatus ;; *) echo &quot;Usage: \\$0 {start|stop|restart|try-restart|force-reload|status}&quot; RETVAL=1 ;; esac updateLock exit \\$RETVAL EOF } getCommonStartupScriptContents_autodl() { local USER=&quot;$1&quot; local STARTUPNAME=&quot;$2&quot; cat &lt;&lt; EOF NAME=$STARTUPNAME USER=$USER SESSIONNAME=autodl resetPath() { PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\\$PATH&quot; } resetPath # Make sure the path is correct, and make sure we&#39;re in the home dir. USER_INIT=&quot;umask $DEFAULT_UMASK; cd; PATH=\\\\\\$PATH:\\$PATH&quot; # Run user command, ignoring any messages sent to stdout (eg. &#39;No mail.&#39;) runUserCmd() { su - \\$USER -c &quot;\\$USER_INIT; \\$1&quot; &gt;/dev/null &amp;&amp; return 0 return 1 } isStarted() { su - \\$USER -c &quot;\\$USER_INIT; screen -ls | grep -qE \\\\&quot;[ ][0-9]+\\\\\\\\.\\$SESSIONNAME[ ]\\\\&quot;&quot; &gt;/dev/null &amp;&amp; return 0 return 1 } startIt() { isStarted &amp;&amp; return 0 local START_IRSSI=n local START_RTORRENT=n which irssi &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_IRSSI=y which rtorrent &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_RTORRENT=y case \\$START_IRSSI\\$START_RTORRENT in yy) runUserCmd &quot;screen -S \\$SESSIONNAME -d -t rtorrent -m rtorrent&quot; runUserCmd &quot;screen -d -r \\$SESSIONNAME -X screen -t irssi irssi&quot; ;; yn) runUserCmd &quot;screen -S \\$SESSIONNAME -d -t irssi -m irssi&quot; ;; ny) runUserCmd &quot;screen -S \\$SESSIONNAME -d -t rtorrent -m rtorrent&quot; ;; nn) ;; esac return 0 } stopIt() { isStarted || return 0 runUserCmd &quot;screen -d -r \\$SESSIONNAME -p irssi -X stuff \\\\&quot;/quit /quit \\\\&quot;&quot; runUserCmd &quot;screen -d -r \\$SESSIONNAME -p rtorrent -X xon&quot; for i in 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4; do isStarted || break sleep 1 done # If it&#39;s still not stopped, kill the whole screen session if isStarted; then echo -n &quot;Couldn&#39;t stop it. Killing screen session...&quot; runUserCmd &quot;screen -d -r \\$SESSIONNAME -p rtorrent -X xon&quot; sleep 2 runUserCmd &quot;screen -d -r \\$SESSIONNAME -X quit&quot; echo &quot;Done.&quot; fi return 0 } v_restartIt() { v_stopIt v_startIt } v_showStatus() { if isStarted; then echo &quot;\\$NAME is running.&quot; else echo &quot;\\$NAME is stopped.&quot; fi } EOF } getChkconfigScriptContents_autodl() { getChkconfigScriptContents &quot;$AUTODL_STARTUP_DESC&quot; } # LSB style script, also supports chkconfig # $1 = user name # $2 = service name getLsbStartupHeader_autodl() { local USER=&quot;$1&quot; local STARTUPNAME=&quot;$2&quot; cat &lt;&lt; EOF $(getChkconfigScriptContents_autodl) $(getLsbStartupScriptContents &quot;$STARTUPNAME&quot; &quot;$AUTODL_STARTUP_DESC&quot;) $(getCommonStartupScriptContents_autodl &quot;$USER&quot; &quot;$STARTUPNAME&quot;) EOF } installService_mandriva() { local serviceName=&quot;$1&quot; local headerCommand=&quot;$2&quot; installService_chkconfig1 $serviceName cat &gt; &quot;$CHKCONFIG_SERVICE_FILE&quot; &lt;&lt; EOF #!/bin/bash $(eval $headerCommand) . /etc/rc.d/init.d/functions v_startIt() { gprintf &quot;Starting %s:&quot; &quot;\\$NAME&quot; startIt &amp;&amp; success &quot;startup&quot; || failure &quot;startup&quot; echo } v_stopIt() { gprintf &quot;Stopping %s:&quot; &quot;\\$NAME&quot; stopIt &amp;&amp; success &quot;stop&quot; || failure &quot;stop&quot; echo } $(getLsbStartupFooter &quot;$CHKCONFIG_LOCK_FILE&quot;) EOF [ $? -eq 0 ] || errorExit &quot;Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root.&quot; installService_chkconfig2 } installService_mandriva_autodl() { local user=$1 installService_mandriva autodl_$user &quot;getLsbStartupHeader_autodl \\&quot;$user\\&quot; \\&quot;\\$CHKCONFIG_SERVICE_NAME\\&quot;&quot; } installService_mandriva_phpcgi() { installService_mandriva phpcgi getLsbStartupHeader_phpcgi } installService_mandriva_nginx() { installService_mandriva nginx getLsbStartupHeader_nginx } installService_mandriva_lighttpd() { installService_mandriva lighttpd getLsbStartupHeader_lighttpd } installService_gentoo() { local scriptName=&quot;$1&quot; local desc=&quot;$2&quot; local headerCommand=&quot;$3&quot; local serviceFile=&quot;/etc/init.d/$scriptName&quot; cat &gt; &quot;$serviceFile&quot; &lt;&lt; EOF #!/sbin/runscript name=$scriptName description=&quot;$desc&quot; depend() { need localmount need net } $(eval $headerCommand) start() { ebegin &quot;Starting \\$name&quot; startIt eend \\$? } stop() { ebegin &quot;Stopping \\$name&quot; stopIt eend \\$? } status() { if isStarted; then einfo &quot;status: started&quot; return 0 else einfo &quot;status: stopped&quot; return 1 fi } EOF [ $? -eq 0 ] || errorExit &quot;Could not write to file $serviceFile. Run this script as root.&quot; chmod +x &quot;$serviceFile&quot; rc-update add $scriptName default || errorExit &quot;Could not add service $scriptName&quot; $serviceFile restart } installService_gentoo_autodl() { local user=&quot;$1&quot; installService_gentoo autodl_$user &quot;$AUTODL_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_autodl \\&quot;$user\\&quot; \\&quot;\\$scriptName\\&quot;&quot; } installService_gentoo_phpcgi() { installService_gentoo phpcgi &quot;$PHPCGI_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_phpcgi \\&quot;$WWW_USER\\&quot; \\&quot;$WWW_PHP_CGI\\&quot;&quot; } installService_gentoo_nginx() { installService_gentoo nginx &quot;$NGINX_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_nginx \\&quot;$NGINX_BIN\\&quot;&quot; } installService_gentoo_lighttpd() { installService_gentoo lighttpd &quot;$LIGHTTPD_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_lighttpd \\&quot;$LIGHTTPD_BIN\\&quot;&quot; } installService_bsd_autodl() { local user=&quot;$1&quot; local scriptName=&quot;$2&quot; local file=&quot;$3&quot; cat &gt; &quot;$file&quot; &lt;&lt; EOF #!/bin/sh # PROVIDE: autodl_$user # REQUIRE: FILESYSTEMS NETWORKING # KEYWORD: shutdown . /etc/rc.subr name=$scriptName desc=&quot;$AUTODL_STARTUP_DESC&quot; start_cmd=v_startIt stop_cmd=v_stopIt restart_cmd=v_restartIt reload_cmd=v_restartIt status_cmd=v_showStatus extra_commands=&quot;status&quot; v_startIt() { echo -n &quot;Starting \\$NAME&quot; startIt &amp;&amp; echo &quot;.&quot; || echo &quot;. ERROR.&quot; } v_stopIt() { echo -n &quot;Stopping \\$NAME...&quot; stopIt &amp;&amp; echo &quot;done.&quot; || echo &quot;ERROR.&quot; } $(getCommonStartupScriptContents_autodl &quot;$user&quot; &quot;$scriptName&quot;) load_rc_config \\$name run_rc_command &quot;\\$1&quot; EOF [ $? -eq 0 ] || errorExit &quot;Could not write to file $file. Run this script as root.&quot; chmod +x &quot;$file&quot; } getCommonStartupScriptContents_simpleService() { local USER=&quot;$1&quot; local BINPATH=&quot;$2&quot; local START_CMD=&quot;$3&quot; local PID_FILE=&quot;$4&quot; cat &lt;&lt; EOF USER=$USER BINPATH=&quot;$BINPATH&quot; NAME=\\${BINPATH##*/} PID_FILE=&quot;$PID_FILE&quot; resetPath() { PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\\$PATH&quot; } resetPath getPids() { if [ -n &quot;\\$PID_FILE&quot; ]; then pids= [ -f &quot;\\$PID_FILE&quot; ] || return local the_pids=&quot;\\$(cat &quot;\\$PID_FILE&quot; 2&gt;/dev/null)&quot; for pid in \\$the_pids; do PS_FORMAT= LINES= COLUMNS= ps ax | grep -qE &quot;^[ ]*\\$pid[ ]&quot; &amp;&amp; pids=&quot;\\$pids \\$pid&quot; done [ -z &quot;\\$pids&quot; ] &amp;&amp; rm -f &quot;\\$PID_FILE&quot; else # ps uses the COLUMNS variable... Make sure it&#39;s off so we get the full path. pids=\\$(PS_FORMAT= LINES= COLUMNS= ps aux | grep -v grep | grep \\$BINPATH | awk &#39;{print \\$2}&#39;) fi } isStarted() { getPids [ -n &quot;\\$pids&quot; ] &amp;&amp; return 0 return 1 } startIt() { isStarted &amp;&amp; return 0 if [ \\$USER = root ]; then $START_CMD else su - \\$USER &quot;-c $START_CMD&quot; fi [ -n &quot;\\$PID_FILE&quot; ] &amp;&amp; sleep 2 # Allow it some time to create the pid file if ! isStarted; then for i in 1 2 3 4 5; do sleep 1 isStarted &amp;&amp; break done isStarted || return 1 fi return 0 } stopIt() { isStarted || return 0 kill \\$pids 2&gt;/dev/null for i in 0 1 2 3 4 5 6 7 8 9; do isStarted || break sleep 1 done isStarted &amp;&amp; kill -KILL \\$pids 2&gt;/dev/null return 0 } v_startIt() { startIt } v_stopIt() { stopIt } v_restartIt() { v_stopIt v_startIt } v_showStatus() { if isStarted; then echo &quot;\\$NAME is running.&quot; else echo &quot;\\$NAME is stopped.&quot; fi } EOF } getCommonStartupScriptContents_phpcgi() { [ -n &quot;$PHPCGI_SOCKET_FILE&quot; ] || errorExit &quot;PHPCGI_SOCKET_FILE is not initialized&quot; getCommonStartupScriptContents_simpleService &quot;$1&quot; &quot;$2&quot; \\ &quot;PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 \\$BINPATH -q -b \\&quot;$PHPCGI_SOCKET_FILE\\&quot; &amp;&quot; } getLsbStartupHeader_phpcgi() { getChkconfigScriptContents &quot;$PHPCGI_STARTUP_DESC&quot; getLsbStartupScriptContents phpcgi &quot;$PHPCGI_STARTUP_DESC&quot; getCommonStartupScriptContents_phpcgi &quot;$WWW_USER&quot; &quot;$WWW_PHP_CGI&quot; } getCommonStartupScriptContents_nginx() { getCommonStartupScriptContents_simpleService &quot;root&quot; &quot;$1&quot; &quot;\\$BINPATH&quot; &quot;$NGINX_PID_FILE&quot; } getLsbStartupHeader_nginx() { getChkconfigScriptContents &quot;$NGINX_STARTUP_DESC&quot; getLsbStartupScriptContents nginx &quot;$NGINX_STARTUP_DESC&quot; getCommonStartupScriptContents_nginx &quot;$NGINX_BIN&quot; } getCommonStartupScriptContents_lighttpd() { getCommonStartupScriptContents_simpleService &quot;root&quot; &quot;$1&quot; &quot;\\$BINPATH -f $LIGHTTPD_CONF 2&gt;/dev/null&quot; &quot;$LIGHTTPD_PID_FILE&quot; } getLsbStartupHeader_lighttpd() { getChkconfigScriptContents &quot;$LIGHTTPD_STARTUP_DESC&quot; getLsbStartupScriptContents lighttpd &quot;$LIGHTTPD_STARTUP_DESC&quot; getCommonStartupScriptContents_lighttpd &quot;$LIGHTTPD_BIN&quot; } addLsbHeaderToStartupScript() { local scriptPath=&quot;$1&quot; local provides=&quot;${2:-$scriptPath}&quot; local desc=&quot;${3:-$provides}&quot; [ -x &quot;$scriptPath&quot; ] || return grep -qE &#39;^### BEGIN INIT INFO&#39; &quot;$scriptPath&quot; &amp;&amp; return ed -s &quot;$scriptPath&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF 1a $(getLsbStartupScriptContents &quot;$provides&quot; &quot;$desc&quot;) . w q EOF } installMissingPerlModules() { detectMissingPerlModules [ -z &quot;$MISSING_PERL_MODULES&quot; ] &amp;&amp; return cat &lt;&lt; EOF $CWARNING The following Perl modules are still missing: $MISSING_PERL_MODULES I&#39;ll try to use the cpan script to install them.$CEND EOF # Some Perl modules will fail to build unless Test::More is installed MISSING_PERL_MODULES=&quot;Test::More $MISSING_PERL_MODULES&quot; echo &quot;${CMSG}Installing cpan and required build tools...$CEND&quot; installBuildTools osHandler_$os installCpanTools detectCpanBin if [ -n &quot;$CPAN&quot; ]; then $CPAN $MISSING_PERL_MODULES else local mods= for mod in $MISSING_PERL_MODULES; do [ -n &quot;$mods&quot; ] &amp;&amp; mods=&quot;$mods,&quot; mods=&quot;$mods \\&quot;$mod\\&quot;&quot; done perl -MCPAN -e &quot;CPAN::Shell-&gt;install($mods)&quot; fi detectMissingPerlModules [ -z &quot;$MISSING_PERL_MODULES&quot; ] &amp;&amp; return errorExit &quot;CPAN somehow failed to install the missing Perl modules. Missing: $MISSING_PERL_MODULES&quot; } osHandler_debian() { case $1 in init) INSTALL=&quot;apt-get -y install&quot; FEATURES=&quot;service rtorrent apache nginx lighttpd vsftpd webmin&quot; BUILD_TOOLS=&quot;build-essential make file pkg-config libtool m4&quot; ;; init2) apt-get update installProgram ed # Make sure Debian 6 doesn&#39;t fail when adding new services. We need ed for this # so run it after installing ed... addLsbHeaderToStartupScript /etc/init.d/webmin &quot;webmin&quot; &quot;webmin&quot; ;; installTools) PACKAGES= addProgram irssi addProgram mediainfo addProgram git-core addProgram svn subversion addProgram wget addProgram unzip addProgram screen installPackages # Make sure subversion won&#39;t complain about invalid certs $INSTALL ca-certificates ;; installAutodlTools) PACKAGES= addProgram perl addPerlModule Archive::Zip libarchive-zip-perl addPerlModule HTML::Parser libhtml-parser-perl addPerlModule Digest::SHA1 libdigest-sha-perl installPackages installPerlModule Net::SSLeay libnet-ssleay-perl installPerlModule XML::LibXML libxml-libxml-perl installPerlModule JSON::XS libjson-xs-perl installPerlModule JSON libjson-perl ;; installCpanTools) # Need to remove the old JSON or cpan may fail to build the modules if echo &quot;$OLD_PERL_MODULES&quot; | grep -qE &#39;(^| )JSON( |$)&#39;; then apt-get -y remove libjson-perl fi PACKAGES= if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;XML::LibXML&#39;; then PACKAGES=&quot;$PACKAGES libxml2 libxml2-dev zlib1g zlib1g-dev&quot; fi if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;Net::SSLeay&#39;; then # There&#39;s no libssl package PACKAGES=&quot;$PACKAGES openssl libssl-dev zlib1g zlib1g-dev&quot; fi installPackages ;; installRtorrentBuildTools) PACKAGES=&quot;libsigc++-2.0-dev libssl-dev libncurses-dev&quot; if apt-cache search libcurl4-openssl-dev 2&gt; /dev/null | grep -q &#39;libcurl4-openssl-dev&#39;; then PACKAGES=&quot;$PACKAGES libcurl4-openssl-dev&quot; else PACKAGES=&quot;$PACKAGES libcurl3-openssl-dev&quot; fi installPackages ;; installPhpModules) installMissingPhp5Packages ;; _installService) local serviceName=&quot;$2&quot; local headerCommand=&quot;$3&quot; local serviceFile=/etc/init.d/$serviceName local lockFile= cat &gt; &quot;$serviceFile&quot; &lt;&lt; EOF #!/bin/sh $(eval $headerCommand) . /lib/lsb/init-functions v_startIt() { log_begin_msg &quot;Starting \\$NAME...&quot; startIt log_end_msg \\$? } v_stopIt() { log_begin_msg &quot;Stopping \\$NAME...&quot; stopIt log_end_msg \\$? } $(getLsbStartupFooter &quot;$lockFile&quot;) EOF [ $? -eq 0 ] || errorExit &quot;Could not write to file $serviceFile. Run this script as root.&quot; chmod +x &quot;$serviceFile&quot; || errorExit &quot;Could not set +x bit, file $serviceFile.&quot; update-rc.d $serviceName defaults || errorExit &quot;Could not install service $serviceFile. Run this script as root.&quot; invoke-rc.d $serviceName restart ;; installAutodlService) local user=$2 osHandler_$os _installService autodl_$user &quot;getLsbStartupHeader_autodl \\&quot;$user\\&quot; \\&quot;\\$serviceName\\&quot;&quot; ;; _installCommonWebServerStuff) # Also add some extra tools for ruTorrent and some of its plugins PACKAGES=&quot;php5-cli gzip curl openssl logrotate&quot; installPackages # Ubuntu 8 doesn&#39;t have php5-geoip PACKAGES=&quot;php5-geoip&quot; installPackages PACKAGES=&quot;unrar&quot; installPackages ;; installApache) osHandler_$os _installCommonWebServerStuff PACKAGES=&quot;apache2-mpm-prefork libapache2-mod-php5 php5 &quot; installPackages PACKAGES=&quot;libapache2-mod-scgi&quot;; installPackages WWW_PHP_INI=/etc/php5/apache2/php.ini APACHE_DIR=/etc/apache2 APACHE_SITE_NAME=rutorrent.conf APACHE_SCGI_FILE=$APACHE_DIR/mods-available/scgi.load initializeApacheVars www-data www-data &quot;$APACHE_DIR/sites-available&quot; apacheCommonInitialization &quot;apache2-prefork-dev&quot; /usr/lib/apache2/modules a2enmod ssl || errorExit &quot;Could not enable mod_ssl&quot; a2enmod scgi || errorExit &quot;Could not enable mod_scgi&quot; # Ubuntu Server 6 doesn&#39;t come with this module a2enmod auth_basic a2dissite default a2dissite default-ssl a2ensite $APACHE_SITE_NAME || errorExit &quot;Could not enable site&quot; if ! grep -qE &quot;^[ ]*Listen.*[: ]$HTTPS_PORT\\\\&gt;&quot; &quot;$APACHE_DIR/ports.conf&quot;; then echo &quot;Listen $HTTPS_PORT&quot; &gt;&gt; &quot;$APACHE_DIR/ports.conf&quot; fi resetWebServerPermissions invoke-rc.d apache2 restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; restart_apache) invoke-rc.d apache2 restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; installVsftpd) installProgram vsftpd updateVsftpdConf /etc/vsftpd.conf invoke-rc.d vsftpd restart || errorExit &quot;Could not restart vsftpd&quot; ;; preNginxInstall) WWW_PHP_INI=/etc/php5/cgi/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES=&quot;libpcre3-dev libssl-dev zlib1g-dev php5-cgi&quot; installPackages # Make sure it builds on Debian GNU/kFreeBSD 6.0. if [ &quot;$(uname -s)&quot; != Linux ]; then NGINX_CFLAGS=&quot;-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64&quot; fi ;; installPhpCgiService) osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi ;; installNginxService) osHandler_$os _installService nginx getLsbStartupHeader_nginx ;; restart_nginx) invoke-rc.d phpcgi restart || errorExit &quot;Could not start php-cgi&quot; invoke-rc.d nginx restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; preLighttpdInstall) WWW_PHP_INI=/etc/php5/cgi/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES=&quot;libpcre3-dev libssl-dev zlib1g-dev php5-cgi&quot; installPackages ;; installLighttpdService) osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd ;; restart_lighttpd) invoke-rc.d phpcgi restart || errorExit &quot;Could not start php-cgi&quot; invoke-rc.d lighttpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; postWebminInstall) addLsbHeaderToStartupScript /etc/init.d/webmin &quot;webmin&quot; &quot;webmin&quot; ;; *) ;; esac } osHandler_fedora() { case $1 in init) INSTALL=&quot;yum -y install&quot; FEATURES=&quot;service rtorrent apache nginx lighttpd vsftpd webmin&quot; BUILD_TOOLS=&quot;gcc gcc-c++ make kernel-headers pkgconfig file libtool m4&quot; ;; init2) installProgram which installProgram ed ;; installTools) PACKAGES= addProgram svn subversion addProgram wget addProgram unzip addProgram screen addProgram git installPackages ;; installAutodlTools) if grep -q &quot;release 4[. ]&quot; /etc/redhat-release; then IRSSI_LOAD_PERL=y fi PACKAGES= addProgram perl addProgram irssi addPerlModule Time::HiRes perl-Time-HiRes addPerlModule Archive::Zip perl-Archive-Zip addPerlModule Net::SSLeay perl-Net-SSLeay addPerlModule HTML::Parser perl-HTML-Parser addPerlModule XML::LibXML perl-XML-LibXML addPerlModule Digest::SHA1 perl-Digest-SHA1 addPerlModule JSON::XS perl-JSON-XS addPerlModule JSON perl-JSON installPackages ;; installCpanTools) # Need to remove the old JSON or cpan may fail to build the modules if echo &quot;$OLD_PERL_MODULES&quot; | grep -qE &#39;(^| )JSON( |$)&#39;; then yum -y remove perl-JSON fi # CentOS doesn&#39;t have &#39;perl-CPAN&#39;. It&#39;s in the &#39;perl&#39; package though. PACKAGES=&quot;perl-CPAN&quot; if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;XML::LibXML&#39;; then PACKAGES=&quot;$PACKAGES libxml2 libxml2-devel zlib zlib-devel&quot; fi if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;Net::SSLeay&#39;; then PACKAGES=&quot;$PACKAGES openssl openssl-devel zlib zlib-devel&quot; fi installPackages ;; installRtorrentBuildTools) # CentOS 5: curl-devel, no libsigc++20 # Fedora 14: libcurl-devel PACKAGES=&quot;libsigc++20-devel ncurses-devel openssl-devel libcurl-devel curl-devel&quot; installPackages ;; installPhpModules) ;; _installService) local serviceName=&quot;$2&quot; local headerCommand=&quot;$3&quot; installService_chkconfig1 $serviceName cat &gt; &quot;$CHKCONFIG_SERVICE_FILE&quot; &lt;&lt; EOF #!/bin/bash $(eval $headerCommand) . /etc/rc.d/init.d/functions v_startIt() { echo -n &quot;Starting \\$NAME: &quot; startIt &amp;&amp; success || failure echo } v_stopIt() { echo -n &quot;Stopping \\$NAME: &quot; stopIt &amp;&amp; success || failure echo } $(getLsbStartupFooter &quot;$CHKCONFIG_LOCK_FILE&quot;) EOF [ $? -eq 0 ] || errorExit &quot;Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root.&quot; installService_chkconfig2 ;; installAutodlService) local user=$2 osHandler_$os _installService autodl_$user &quot;getLsbStartupHeader_autodl \\&quot;$user\\&quot; \\&quot;\\$CHKCONFIG_SERVICE_NAME\\&quot;&quot; ;; _installCommonWebServerStuff) PACKAGE=&quot;php-cli gzip curl openssl unrar logrotate&quot; installPackages # CentOS 4: will get an error about a php v4 dependency, so can&#39;t put it in above PACKAGE var PACKAGES=&quot;php-pecl-geoip&quot; installPackages ;; installApache) osHandler_$os _installCommonWebServerStuff # Also add some extra tools for ruTorrent and some of its plugins PACKAGES=&quot;httpd httpd-tools mod_ssl mod_scgi php&quot; installPackages WWW_PHP_INI=/etc/php.ini APACHE_DIR=/etc/httpd local APACHE_CONF_D=$APACHE_DIR/conf.d APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf initializeApacheVars apache apache &quot;$APACHE_CONF_D&quot; apacheCommonInitialization &quot;httpd-devel&quot; $APACHE_DIR/modules [ -f &quot;$APACHE_CONF_D/welcome.conf&quot; ] &amp;&amp; mv -f &quot;$APACHE_CONF_D/welcome.conf&quot; &quot;$APACHE_CONF_D/welcome.conf-bak&quot; # Remove an Apache warning by commenting out the default SSL VirtualHost sed_i &#39;/^&lt;VirtualHost _default_:443&gt;/,/^&lt;\\/VirtualHost&gt;/s/^/#/&#39; $APACHE_CONF_D/ssl.conf resetWebServerPermissions chkconfig httpd on service httpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; restart_apache) service httpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; installVsftpd) installVsftpd_chkconfig /etc/vsftpd/vsftpd.conf ;; preNginxInstall) WWW_PHP_INI=/etc/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES=&quot;pcre-devel openssl-devel zlib-devel php-cgi&quot; installPackages ;; installPhpCgiService) osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi ;; installNginxService) osHandler_$os _installService nginx getLsbStartupHeader_nginx ;; restart_nginx) service phpcgi restart || errorExit &quot;Could not start php-cgi&quot; service nginx restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; preLighttpdInstall) WWW_PHP_INI=/etc/php.ini osHandler_$os _installCommonWebServerStuff PACKAGES=&quot;pcre-devel openssl-devel zlib-devel php-cgi&quot; installPackages ;; installLighttpdService) osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd ;; restart_lighttpd) service phpcgi restart || errorExit &quot;Could not start php-cgi&quot; service lighttpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot; ;; *) ;; esac } isWebServerRpcModule() { ! arrayIsPresent rpc $RUTORRENT_PLUGINS &amp;&amp; ! arrayIsPresent httprpc $RUTORRENT_PLUGINS &amp;&amp; return 0 return 1 } canInstallService() { return $(arrayIsPresent service $FEATURES) } canInstallRtorrent() { return $(arrayIsPresent rtorrent $FEATURES) } canInstallApache() { return $(arrayIsPresent apache $FEATURES) } canInstallNginx() { return $(arrayIsPresent nginx $FEATURES) } canInstallLighttpd() { return $(arrayIsPresent lighttpd $FEATURES) } canInstallVsftpd() { return $(arrayIsPresent vsftpd $FEATURES) } canInstallWebmin() { return $(arrayIsPresent webmin $FEATURES) } getRequiredPrograms() { REQUIRED_PROGRAMS=&quot;which svn wget unzip ed sed grep tar expr ps awk kill printf&quot; if [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ]; then REQUIRED_PROGRAMS=&quot;$REQUIRED_PROGRAMS perl&quot; # NetBSD and DragonFly BSD don&#39;t compile Irssi with Perl support by default [ &quot;$IGNORE_IRSSI&quot; != y ] &amp;&amp; REQUIRED_PROGRAMS=&quot;$REQUIRED_PROGRAMS irssi&quot; fi } verifyInstalledPrograms() { getRequiredPrograms local MISSING_PROGRAMS= for prog in $REQUIRED_PROGRAMS; do local name=$prog [ &quot;$prog&quot; = svn ] &amp;&amp; name=subversion isProgramInstalled &quot;$prog&quot; || MISSING_PROGRAMS=&quot;$MISSING_PROGRAMS $name&quot; done [ -n &quot;$MISSING_PROGRAMS&quot; ] &amp;&amp; errorExit &quot;Can&#39;t continue. The following programs are not installed: $MISSING_PROGRAMS&quot; } initPluginDirVar() { AUTODL_IRSSI_PLUGIN_DIR=&quot;$RUTORRENT_BASE_PATH/plugins/autodl-irssi&quot; } getRtorrentDirs() { local user=&quot;$1&quot; getUserDir &quot;$user&quot; RTORRENT_DOWNLOAD_DIR=&quot;$userDir/$RTORRENT_REL_DOWNLOAD_DIR&quot; RTORRENT_WATCH_DIR=&quot;$userDir/$RTORRENT_REL_WATCH_DIR&quot; RTORRENT_SESSION_DIR=&quot;$userDir/$RTORRENT_REL_SESSION_DIR&quot; } getUserScgiSocketPath() { local user=&quot;$1&quot; getRtorrentDirs &quot;$user&quot; scgiSocketPath=&quot;$RTORRENT_SESSION_DIR/rpc.socket&quot; } waitenter() { local msg=&quot;${1-Press ENTER to continue...}&quot; echo -n &quot;$CCYAN$msg$CEND&quot; read dummy } askQuestion() { local question=&quot;$1&quot; local default=&quot;$2&quot; if [ -z &quot;$default&quot; ]; then echo -n &quot;$CQUESTION$question$CEND &quot; read answer else echo -n &quot;$CQUESTION$question$CEND [$CGREEN$default$CEND] &quot; read answer fi if [ -z &quot;$answer&quot; ]; then answer=&quot;$default&quot; fi } # Asks the user a question, and sets answer to y or n depending on the user&#39;s answer askYesNo() { local question=&quot;$1&quot; local default=&quot;$2&quot; while true; do askQuestion &quot;$question&quot; &quot;$default&quot; if echo &quot;$answer&quot; | grep -qiE &#39;^y(es)?$&#39;; then answer=y return 1 elif echo &quot;$answer&quot; | grep -qiE &#39;^no?$&#39;; then answer=n return 0 fi done } askOsUser() { local stopIfEmpty=${1:-n} local user= while true; do askQuestion &quot;Enter name of user:&quot; &quot;&quot; user=&quot;$answer&quot; [ -z &quot;$user&quot; ] &amp;&amp; [ &quot;$stopIfEmpty&quot; = y ] &amp;&amp; break userExists &quot;$user&quot; &amp;&amp; break echo &quot;${CWARNING}User $user does not exist.$CEND&quot; askYesNo &quot;Do you want to create user $user?&quot; &quot;No&quot; [ &quot;$answer&quot; = n ] &amp;&amp; continue echo &quot;${CMSG}Creating user $user.$CEND&quot; if ! useradd -m -s /bin/sh &quot;$user&quot;; then echo &quot;${CWARNING}Could not create user $user.$CEND&quot; continue fi echo &quot;${CMSG}Enter the user&#39;s password:$CEND&quot; if ! passwd &quot;$user&quot;; then echo &quot;${CWARNING}Failed to set password.$CEND&quot; continue fi userExists &quot;$user&quot; &amp;&amp; break done answer=&quot;$user&quot; } # Adds another user to USERS addUser() { local osUser=&quot;$1&quot; local webUser=&quot;$2&quot; local autodlPassword= local webpass= if [ &quot;$INSTALL_RUTORRENT&quot; = y ] || [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then if ! canGeneratePasswords; then cat &lt;&lt; EOF $CQUESTION The password makes sure only you can change your autodl-irssi settings. This is NOT your login password. Use any password, but each user should use a unique password. The password is used by the PHP code to access autodl-irssi settings. You don&#39;t need to remember this password. It can&#39;t contain any spaces or a colon &#39;:&#39;.$CEND EOF while true; do askQuestion &quot;Enter the autodl-irssi password (this is not your login password):&quot; &quot;&quot; autodlPassword=&quot;$answer&quot; isValidPassword &quot;$autodlPassword&quot; &amp;&amp; break echo &quot;${CWARNING}Invalid password. Try again.$CEND&quot; done fi if [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ]; then while true; do askQuestion &quot;Enter your ruTorrent password:&quot; &quot;&quot; webpass=&quot;$answer&quot; isValidPassword &quot;$webpass&quot; &amp;&amp; break echo &quot;${CWARNING}Invalid password. Try again.$CEND&quot; done fi USERS=&quot;$USERS $osUser:$autodlPassword:$webUser:$webpass&quot; else USERS=&quot;$USERS $osUser&quot; fi } installUser() { local userPluginDir=&quot;$1&quot; local osUser=&quot;$2&quot; local webUser=&quot;${3:-$osUser}&quot; local port=&quot;$4&quot; local autodlPassword=&quot;$5&quot; getUserGroup &quot;$osUser&quot; getUserDir &quot;$osUser&quot; cat &lt;&lt; EOF ========================= ${CGREEN}Installing autodl-irssi$CEND ========================= Use the ruTorrent plugin: $CGREEN$USE_RUTORRENT_PLUGIN$CEND OS user: $CGREEN$osUser$CEND EOF if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ] &amp;&amp; echo &quot;ruTorrent user: $CGREEN$webUser$CEND&quot; echo &quot;port: $CGREEN$port$CEND&quot; echo &quot;password: $CGREEN$autodlPassword$CEND&quot; fi cat &lt;&lt; EOF group: $CGREEN$group$CEND home: $CGREEN$userDir$CEND EOF if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then isValidPortNumber &quot;$port&quot; || errorExit &quot;Invalid port number: $port&quot; isValidPassword &quot;$autodlPassword&quot; || errorExit &quot;Invalid password: $autodlPassword&quot; isValidWebUser &quot;$webUser&quot; || errorExit &quot;Invalid web user: $webUser&quot; fi mkdir -p &quot;$userDir/.irssi/scripts/autorun&quot; cd &quot;$userDir/.irssi/scripts&quot; || errorExit &quot;Could not CD into user dir. Run the script as root.&quot; echo &quot;${CMSG}Downloading autodl-irssi.zip...$CEND&quot; if ! downloadFile autodl-irssi.zip &quot;$AUTODL_IRSSI_ZIP_URL&quot;; then errorExit &quot;Could not download autodl-irssi zip file&quot; fi echo &quot;${CMSG}Unpacking autodl-irssi...$CEND&quot; unzip -o autodl-irssi.zip &gt; /dev/null || errorExit &quot;Could not unpack autodl-irssi zip file&quot; rm -f autodl-irssi.zip cp autodl-irssi.pl autorun/ || errorExit &quot;Could not copy autodl-irssi.pl to Irssi autorun dir.&quot; mkdir -p &quot;$userDir/.autodl&quot; touch &quot;$userDir/.autodl/autodl.cfg&quot; if ! [ -s &quot;$userDir/.autodl/autodl.cfg&quot; ]; then [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; cat &gt; &quot;$userDir/.autodl/autodl.cfg&quot; &lt;&lt; EOF [options] upload-type = rtorrent EOF fi if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then if [ ! -d &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; ]; then errorExit &quot;The autodl-irssi ruTorrent plugin has not been installed. Install it.&quot; fi cat &gt; &quot;$userDir/.autodl/autodl2.cfg&quot; &lt;&lt; EOF [options] gui-server-port = $port gui-server-password = $autodlPassword EOF rm -f &quot;$AUTODL_IRSSI_PLUGIN_DIR/conf.php&quot; mkdir -p &quot;$userPluginDir&quot; cat &gt; &quot;$userPluginDir/conf.php&quot; &lt;&lt; EOF &lt;?php \\$autodlPort = $port; \\$autodlPassword = &quot;$autodlPassword&quot;; ?&gt; EOF [ $? -eq 0 ] || errorExit &quot;Could not write to $userPluginDir/conf.php. Run this script as root.&quot; # Only set perms to 0400 if the code knows the owner (web server owner) and will reset it [ &quot;$ISROOT&quot; = y ] &amp;&amp; [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; chmod 0400 &quot;$userPluginDir/conf.php&quot; else # Don&#39;t use the autodl-irssi ruTorrent plugin : &gt; &quot;$userDir/.autodl/autodl2.cfg&quot; fi # The Perl module isn&#39;t loaded by default if [ &quot;$IRSSI_LOAD_PERL&quot; = y ]; then if [ ! -f &quot;$userDir/.irssi/startup&quot; ] || ! grep -q &#39;load perl&#39; &quot;$userDir/.irssi/startup&quot;; then echo &quot;load perl&quot; &gt;&gt; &quot;$userDir/.irssi/startup&quot; fi fi # Make sure we redownload the tracker files since the ones in the zip file are possibly # old versions. local autodlStateFile=&quot;$userDir/.autodl/AutodlState.xml&quot; [ -f &quot;$autodlStateFile&quot; ] &amp;&amp; sed_i &#39;g/&lt;trackers-version&gt;/d&#39; &quot;$autodlStateFile&quot; resetOwner &quot;$osUser&quot; &quot;$userDir/.autodl&quot; &quot;$userDir/.irssi&quot; chmod 0700 &quot;$userDir/.autodl&quot; &quot;$userDir/.irssi&quot; } getRutorrentUserConfDir() { userConfDir=&quot;$RUTORRENT_BASE_PATH/conf/users/$webUser&quot; } getRutorrentUserShareDir() { userShareDir=&quot;$RUTORRENT_BASE_PATH/share/users/$webUser&quot; } resetRutorrentUserPermissions() { for packedUser in $USERS; do extractPackedUser $packedUser getRutorrentUserConfDir getRutorrentUserShareDir # Make sure only the web server and the user itself can access its share/conf dirs chown $osUser:$WWW_GROUP &quot;$userShareDir&quot; &quot;$userConfDir&quot; chmod 0770 &quot;$userShareDir&quot; &quot;$userConfDir&quot; done } ############################################################################ # # This is where we start # ############################################################################ SELINUX_ENABLED=n isProgramInstalled selinuxenabled &amp;&amp; selinuxenabled &amp;&amp; SELINUX_ENABLED=y echo &quot;SELinux enabled: $SELINUX_ENABLED&quot; ISROOT=n [ $(id -u) -eq 0 ] &amp;&amp; ISROOT=y echo &quot;Is root user: $ISROOT&quot; if [ $# -gt 0 ]; then parseCommandLine &quot;$@&quot; INTERACTIVE=n else INTERACTIVE=y fi detectOs cat &lt;&lt; EOF Detected OS: $CGREEN$os_long$CEND Type: $CGREEN$os$CEND Type sh $0 --help for all command line options. EOF osHandler_$os init if [ &quot;$INTERACTIVE&quot; = y ]; then if [ &quot;$ISROOT&quot; = n ]; then cat &lt;&lt; EOF $CRED You&#39;re not the root user! This install script may fail if you&#39;re not the root user. To start it as the root user do one of the following: Ubuntu and Ubuntu clones: ${CGREEN}sudo sh $0$CRED Any other OS: ${CGREEN}su sh $0$CRED $CEND EOF waitenter &quot;Press Ctrl+C to exit or ENTER to continue...&quot; fi cat &lt;&lt; EOF $CMSG Press ENTER to use the default answer in [brackets].$CEND EOF webServers= canInstallLighttpd &amp;&amp; webServers=&quot;$webServers lighttpd&quot; canInstallNginx &amp;&amp; webServers=&quot;$webServers nginx&quot; canInstallApache &amp;&amp; webServers=&quot;$webServers apache&quot; if [ -n &quot;$webServers&quot; ]; then cat &lt;&lt; EOF $CQUESTION If you want to install ruTorrent you must install a web server, eg. Apache. If you&#39;ve already installed another web server, you must first uninstall it or disable it. List of supported web servers:$CEND EOF canInstallLighttpd &amp;&amp; echo &quot; ${CGREEN}lighttpd$CEND ${CQUESTION}lighttpd web server (lightweight)$CEND&quot; canInstallNginx &amp;&amp; echo &quot; ${CGREEN}nginx$CEND ${CQUESTION}nginx web server (lightweight)$CEND&quot; canInstallApache &amp;&amp; echo &quot; ${CGREEN}apache$CEND ${CQUESTION}Apache web server$CEND&quot; echo &quot; ${CGREEN}none$CEND ${CQUESTION}Don&#39;t install a web server$CEND&quot; while true; do INSTALL_WEB_SERVER= echo &quot;${CQUESTION}Select one of:$CGREEN$webServers none$CEND&quot; askQuestion &quot;Enter name of web server&quot; &quot;$(getFirst $webServers)&quot; [ &quot;$answer&quot; = none ] &amp;&amp; break INSTALL_WEB_SERVER=&quot;$answer&quot; arrayIsPresent $INSTALL_WEB_SERVER $webServers &amp;&amp; break done if [ -n &quot;$INSTALL_WEB_SERVER&quot; ]; then askYesNo &quot;Do you want to install ruTorrent?&quot; &quot;Yes&quot; INSTALL_RUTORRENT=&quot;$answer&quot; else INSTALL_RUTORRENT=n fi fi if canInstallRtorrent; then cat &lt;&lt; EOF $CQUESTION ruTorrent requires a working rtorrent built with XML-RPC support.$CEND EOF askYesNo &quot;Do you want to build rtorrent?&quot; &quot;Yes&quot; BUILD_RTORRENT=&quot;$answer&quot; fi askYesNo &quot;Do you want to install the autodl-irssi ruTorrent plugin?&quot; &quot;Yes&quot; USE_RUTORRENT_PLUGIN=&quot;$answer&quot; if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then REINSTALL_RUTORRENT_PLUGIN=n RUTORRENT_PASSWORD_PROTECTED=y elif [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then echo &quot;&quot; while true; do echo &quot;${CQUESTION}The ruTorrent www base path is where you installed ruTorrent.$CEND&quot; askQuestion &quot;What is the ruTorrent www base path, eg. /var/www/rutorrent:&quot; &quot;&quot; RUTORRENT_BASE_PATH=&quot;$answer&quot; isValidRutorrentBasePath &quot;$RUTORRENT_BASE_PATH&quot; &amp;&amp; break echo &quot;$CWARNING$RUTORRENT_BASE_PATH is not the ruTorrent base path.$CEND&quot; done initPluginDirVar if [ -d &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; ]; then echo &quot;&quot; askYesNo &quot;The autodl-irssi ruTorrent plugin seems to be installed. Do you want to re-install it?&quot; &quot;No&quot; REINSTALL_RUTORRENT_PLUGIN=&quot;$answer&quot; else REINSTALL_RUTORRENT_PLUGIN=n fi cat &lt;&lt; EOF $CQUESTION To use more than one ruTorrent user, you must password protect ruTorrent.$CEND EOF askYesNo &quot;Is ruTorrent password protected?&quot; &quot;No&quot; RUTORRENT_PASSWORD_PROTECTED=&quot;$answer&quot; else RUTORRENT_PASSWORD_PROTECTED=n fi if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then INSTALL_AUTODL_IRSSI=y else askYesNo &quot;Do you want to install autodl-irssi?&quot; &quot;Yes&quot; INSTALL_AUTODL_IRSSI=&quot;$answer&quot; fi if canInstallService &amp;&amp; ([ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] || [ &quot;$INSTALL_RUTORRENT&quot; = y ]); then cat &lt;&lt; EOF $CQUESTION If you want to automatically start Irssi and rtorrent when the computer boots, install the startup script.$CEND EOF askYesNo &quot;Do you want to install the startup script?&quot; &quot;Yes&quot; INSTALL_STARTUP_SCRIPT=&quot;$answer&quot; fi askUser=n if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] || [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] || \\ [ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] || [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then askUser=y fi if [ &quot;$askUser&quot; = y ]; then if [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = n ]; then cat &lt;&lt; EOF $CQUESTION This is the user running rtorrent and/or Irssi.$CEND ${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND EOF askOsUser addUser &quot;$answer&quot; &quot;&quot; else while true; do cat &lt;&lt; EOF $CQUESTION ===================== USER ===================== This is the user running rtorrent and/or Irssi. ${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND ${CCYAN}Press ENTER to stop adding users.$CEND EOF askOsUser y osUser=&quot;$answer&quot; [ -z &quot;$osUser&quot; ] &amp;&amp; break while true; do cat &lt;&lt; EOF $CQUESTION The ruTorrent user is the name you use to log in to ruTorrent.$CEND EOF askQuestion &quot;Enter ruTorrent user:&quot; &quot;$osUser&quot; webUser=&quot;$answer&quot; isValidWebUser &quot;$webUser&quot; &amp;&amp; break echo &quot;${CWARNING}Invalid web user name &#39;$webUser&#39;. Use only lower case letters.&quot; done addUser &quot;$osUser&quot; &quot;$webUser&quot; done fi fi if canInstallVsftpd; then cat &lt;&lt; EOF $CQUESTION vsftpd is a very secure FTP daemon.$CEND EOF askYesNo &quot;Do you want to install vsftpd?&quot; &quot;Yes&quot; INSTALL_VSFTPD=&quot;$answer&quot; if [ &quot;$INSTALL_VSFTPD&quot; = y ]; then askYesNo &quot;Do you want to use encrypted FTP (FTPES)&quot; &quot;Yes&quot; USE_ENCRYPTED_FTP=&quot;$answer&quot; port=$DEFAULT_PORT_FTP [ &quot;$USE_ENCRYPTED_FTP&quot; = y ] &amp;&amp; port=$DEFAULT_PORT_FTPES askQuestion &quot;Enter FTP port number&quot; &quot;$port&quot; FTP_PORT=&quot;$answer&quot; fi fi if canInstallWebmin; then cat &lt;&lt; EOF $CQUESTION Webmin is a web-based administration tool for your OS.$CEND EOF askYesNo &quot;Do you want to install Webmin?&quot; &quot;Yes&quot; INSTALL_WEBMIN=&quot;$answer&quot; fi fi cmdline=&quot;sh $0&quot; [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -p&quot; [ &quot;$REINSTALL_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -i&quot; [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -a&quot; for user in $USERS; do cmdline=&quot;$cmdline -u $user&quot;; done [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -w&quot; [ -n &quot;$RUTORRENT_BASE_PATH&quot; ] &amp;&amp; cmdline=&quot;$cmdline -r &#39;$RUTORRENT_BASE_PATH&#39;&quot; [ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -s&quot; if [ -z &quot;$INSTALL_WEB_SERVER&quot; ]; then : elif [ &quot;$INSTALL_WEB_SERVER&quot; = apache ]; then cmdline=&quot;$cmdline --apache&quot; elif [ &quot;$INSTALL_WEB_SERVER&quot; = nginx ]; then cmdline=&quot;$cmdline --nginx&quot; elif [ &quot;$INSTALL_WEB_SERVER&quot; = lighttpd ]; then cmdline=&quot;$cmdline --lighttpd&quot; else errorExit &quot;Invalid web server: $INSTALL_WEB_SERVER&quot; fi [ &quot;$BUILD_RTORRENT&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --rtorrent&quot; [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --rutorrent&quot; [ &quot;$INSTALL_VSFTPD&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --vsftpd&quot; [ -n &quot;$FTP_PORT&quot; ] &amp;&amp; cmdline=&quot;$cmdline --ftp-port $FTP_PORT&quot; [ &quot;$USE_ENCRYPTED_FTP&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --ftpes&quot; [ &quot;$INSTALL_WEBMIN&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --webmin&quot; cat &lt;&lt; EOF You can execute this command as the root user (Ubuntu: use ${CRED}sudo$CEND): $CGREEN$cmdline$CEND Use the autodl-irssi ruTorrent plugin: $USE_RUTORRENT_PLUGIN Re-install the autodl-irssi ruTorrent plugin: $REINSTALL_RUTORRENT_PLUGIN Install autodl-irssi: $INSTALL_AUTODL_IRSSI Users: $USERS ruTorrent is password protected: $RUTORRENT_PASSWORD_PROTECTED ruTorrent base path: $RUTORRENT_BASE_PATH Install startup script: $INSTALL_STARTUP_SCRIPT Install web server: $INSTALL_WEB_SERVER Build rtorrent: $BUILD_RTORRENT Install ruTorrent: $INSTALL_RUTORRENT Install vsftpd: $INSTALL_VSFTPD FTP port: $FTP_PORT Use FTPES: $USE_ENCRYPTED_FTP Install Webmin: $INSTALL_WEBMIN EOF if [ -n &quot;$INSTALL_WEB_SERVER&quot; ]; then for port in $HTTP_PORT $HTTPS_PORT; do isPortUsed $port || continue cat &lt;&lt; EOF $CWARNING Port $port is in use. If it&#39;s not used by $INSTALL_WEB_SERVER, you may need to disable or uninstall that other web server before continuing.$CEND EOF done fi if [ &quot;$INTERACTIVE&quot; = y ]; then echo &quot;&quot; waitenter &quot;Press Ctrl+C to cancel or ENTER to install.&quot; fi osHandler_$os init2 initUsers initPluginDirVar [ -n &quot;$INSTALL_WEB_SERVER&quot; ] || [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; RUTORRENT_PASSWORD_PROTECTED=y [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; [ -z &quot;$INSTALL_WEB_SERVER&quot; ] &amp;&amp; errorExit &quot;You must install a web server if you want to install ruTorrent, eg. use --apache --rutorrent&quot; [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; REINSTALL_RUTORRENT_PLUGIN=n [ &quot;$BUILD_RTORRENT&quot; = y ] &amp;&amp; ! canInstallRtorrent &amp;&amp; errorExit &quot;Can&#39;t build rtorrent.&quot; [ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] &amp;&amp; ! canInstallService &amp;&amp; errorExit &quot;Can&#39;t install startup script.&quot; [ &quot;$INSTALL_VSFTPD&quot; = y ] &amp;&amp; ! canInstallVsftpd &amp;&amp; errorExit &quot;Can&#39;t install vsftpd.&quot; [ &quot;$INSTALL_WEBMIN&quot; = y ] &amp;&amp; ! canInstallWebmin &amp;&amp; errorExit &quot;Can&#39;t install webmin.&quot; if [ -z &quot;$INSTALL_WEB_SERVER&quot; ]; then : elif [ &quot;$INSTALL_WEB_SERVER&quot; = apache ]; then canInstallApache || errorExit &quot;Can&#39;t install Apache.&quot; elif [ &quot;$INSTALL_WEB_SERVER&quot; = nginx ]; then canInstallNginx || errorExit &quot;Can&#39;t install nginx.&quot; elif [ &quot;$INSTALL_WEB_SERVER&quot; = lighttpd ]; then canInstallLighttpd || errorExit &quot;Can&#39;t install lighttpd.&quot; else errorExit &quot;Invalid web server: $INSTALL_WEB_SERVER&quot; fi [ -n &quot;$FTP_PORT&quot; ] &amp;&amp; [ &quot;$FTP_PORT&quot; -lt 1 -o &quot;$FTP_PORT&quot; -gt 65535 ] &amp;&amp; errorExit &quot;Invalid FTP port: $FTP_PORT&quot; if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then if [ -z &quot;$INSTALL_WEB_SERVER&quot; ] &amp;&amp; ! isValidRutorrentBasePath &quot;$RUTORRENT_BASE_PATH&quot;; then errorExit &quot;$RUTORRENT_BASE_PATH is not a valid ruTorrent base path.&quot; fi fi if [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ]; then cat &lt;&lt; EOF ${CMSG}Installing required tools and Perl modules... Some Perl modules may not be present, but will be installed from CPAN.$CEND EOF else echo &quot;${CMSG}Installing required tools...$CEND&quot; fi osHandler_$os installTools setSvnOpts [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; osHandler_$os installAutodlTools verifyInstalledPrograms [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; installMissingPerlModules cat &lt;&lt; EOF $CMSG All required programs and Perl modules are now installed. Ignore any errors you saw.$CEND EOF INSTALLED_RTORRENT=n if [ &quot;$BUILD_RTORRENT&quot; = y ]; then cat &lt;&lt; EOF $CMSG Building rtorrent and dependencies...$CEND EOF installRtorrent INSTALLED_RTORRENT=y fi if [ -z &quot;$INSTALL_WEB_SERVER&quot; ]; then : elif [ &quot;$INSTALL_WEB_SERVER&quot; = apache ]; then echo &quot;&quot; echo &quot;${CMSG}Installing Apache$CEND&quot; osHandler_$os installApache installUnrar elif [ &quot;$INSTALL_WEB_SERVER&quot; = nginx ]; then echo &quot;&quot; echo &quot;${CMSG}Installing nginx$CEND&quot; installNginx elif [ &quot;$INSTALL_WEB_SERVER&quot; = lighttpd ]; then echo &quot;&quot; echo &quot;${CMSG}Installing lighttpd$CEND&quot; installLighttpd else errorExit &quot;Invalid web server: $INSTALL_WEB_SERVER&quot; fi if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then if isProgramInstalled php; then installMissingPhpModules else cat &lt;&lt; EOF $CWARNING Could not find the php executable. PHP is not installed or the PHP CLI version is not installed. The autodl-irssi ruTorrent plugin requires the following PHP modules: $CGREEN$REQUIRED_PHP_MODULES$CWARNING They&#39;re normally installed and enabled by default. If not you will need to install them (if needed) and then enable each one in php.ini, eg. extension=MODULE.so and then restart your web server.$CEND EOF fi fi if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then isProgramInstalled php || errorExit &quot;php is not installed!&quot; verifyWebServerVars echo &quot;&quot; echo &quot;${CMSG}Installing ruTorrent$CEND&quot; [ -d &quot;$WWW_ROOT&quot; ] || errorExit &quot;Invalid web root: &#39;$WWW_ROOT&#39; (does not exist)&quot; RUTORRENT_DIRNAME=rutorrent [ -f &quot;$WWW_ROOT/index.html&quot; ] || cat &gt; &quot;$WWW_ROOT/index.html&quot; &lt;&lt; EOF &lt;html&gt;&lt;head&gt;&lt;title&gt;Root page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;$RUTORRENT_DIRNAME/&quot;&gt;ruTorrent&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; EOF cd &quot;$WWW_ROOT&quot; rm -rf &quot;$RUTORRENT_DIRNAME&quot; tmpName=rutorrent-tmp rm -rf $tmpName if ! svn co $SVN_OPTS &quot;$RUTORRENT_TRUNK_DIR&quot; $tmpName &gt;/dev/null; then # Subversion failed. Try the official tar balls mkdir -p $tmpName cd $tmpName downloadFile &quot;$RUTORRENT_CORE_NAME&quot; &quot;$RUTORRENT_CORE_URL&quot; &quot;$RUTORRENT_CORE_URL2&quot; || errorExit &quot;Could not download ruTorrent.&quot; downloadFile &quot;$RUTORRENT_PLUGINS_NAME&quot; &quot;$RUTORRENT_PLUGINS_URL&quot; &quot;$RUTORRENT_PLUGINS_URL2&quot; || errorExit &quot;Could not download ruTorrent plugins.&quot; for name in &quot;$RUTORRENT_CORE_NAME&quot; &quot;$RUTORRENT_PLUGINS_NAME&quot;; do tar xzf &quot;$name&quot; || errorExit &quot;Could not unpack $name&quot; rm -f &quot;$name&quot; done cd .. fi cd $tmpName RUTORRENT_BASE_PATH=&quot;$WWW_ROOT/$RUTORRENT_DIRNAME&quot; initPluginDirVar mv rutorrent/ &quot;$RUTORRENT_BASE_PATH&quot; mkdir -p &quot;$RUTORRENT_BASE_PATH/plugins&quot; for plugin in $RUTORRENT_PLUGINS; do if [ -d &quot;plugins/$plugin/&quot; ]; then echo &quot;${CMSG}Installing ruTorrent plugin: $plugin$CEND...&quot; mv plugins/$plugin/ &quot;$RUTORRENT_BASE_PATH/plugins/&quot; || errorExit &quot;Could not install plugin &#39;$plugin&#39;.&quot; else echo &quot;${CWARNING}Can&#39;t install missing plugin $plugin!$CEND&quot; fi done cd .. rm -rf $tmpName cp &quot;$RUTORRENT_BASE_PATH/favicon.ico&quot; &quot;$WWW_ROOT&quot; i=1 touch &quot;$WWW_PASSWORD_FILE&quot; resetAuthPasswordFilePermissions detectHtpasswd for packedUser in $USERS; do extractPackedUser $packedUser getRutorrentUserConfDir getRutorrentUserShareDir getUserScgiSocketPath &quot;$osUser&quot; getRtorrentDirs &quot;$osUser&quot; # Create user&#39;s ruTorrent config.php rpcMount=&quot;$(getUserRpcMount $i)&quot; mkdir -p &quot;$userConfDir&quot; rutConfigFile=&quot;$userConfDir/config.php&quot; if [ &quot;$SCGI_USE_UNIX_DOMAIN_SOCKET&quot; = y ]; then cat &gt; &quot;$rutConfigFile&quot; &lt;&lt; EOF &lt;?php \\$scgi_port = 0; \\$scgi_host = &quot;unix://$scgiSocketPath&quot;; \\$XMLRPCMountPoint = &quot;$rpcMount&quot;; ?&gt; EOF exitCode=$? else cat &gt; &quot;$rutConfigFile&quot; &lt;&lt; EOF &lt;?php \\$scgi_port = $scgiPort; \\$scgi_host = &quot;$SCGI_HOST&quot;; \\$XMLRPCMountPoint = &quot;$rpcMount&quot;; ?&gt; EOF exitCode=$? fi [ $exitCode -eq 0 ] || errorExit &quot;Could not write to file $rutConfigFile&quot; # Create user&#39;s directory to prevent certain errors the first time ruTorrent is started mkdir -p &quot;$userShareDir/settings&quot; mkdir -p &quot;$userShareDir/torrents&quot; chmod 0777 &quot;$userShareDir/settings&quot; &quot;$userShareDir/torrents&quot; # Setup rtorrent mkdir -p &quot;$RTORRENT_DOWNLOAD_DIR&quot; mkdir -p &quot;$RTORRENT_WATCH_DIR&quot; mkdir -p &quot;$RTORRENT_SESSION_DIR&quot; rtorrentRc=&quot;$userDir/.rtorrent.rc&quot; [ -f &quot;$rtorrentRc&quot; ] &amp;&amp; mv -f &quot;$rtorrentRc&quot; &quot;$rtorrentRc-backup&quot; cat &gt; &quot;$rtorrentRc&quot; &lt;&lt; EOF $(if [ &quot;$SCGI_USE_UNIX_DOMAIN_SOCKET&quot; = y ]; then cat &lt;&lt; EOF2 execute = {sh,-c,rm -f $scgiSocketPath} scgi_local = $scgiSocketPath execute = {sh,-c,chmod 0666 $scgiSocketPath} EOF2 else echo &quot;scgi_port = $SCGI_HOST:$scgiPort&quot; fi) encoding_list = UTF-8 system.umask.set = $DEFAULT_UMASK port_range = $rtorrentPort-$rtorrentPort port_random = no check_hash = no directory = $RTORRENT_DOWNLOAD_DIR session = $RTORRENT_SESSION_DIR encryption = allow_incoming, try_outgoing, enable_retry schedule = watch_directory,1,1,&quot;load_start=$RTORRENT_WATCH_DIR/*.torrent&quot; #schedule = untied_directory,5,5,&quot;stop_untied=$RTORRENT_WATCH_DIR/*.torrent&quot; trackers.enable = 1 #min_peers = 40 #max_peers = 100 #min_peers_seed = 10 #max_peers_seed = 50 #max_uploads = 15 #download_rate = 0 #upload_rate = 0 use_udp_trackers = yes dht = auto dht_port = 6881 peer_exchange = yes #hash_read_ahead = 10 #hash_interval = 100 #hash_max_tries = 10 EOF PHP_BIN_PATH=$(which php 2&gt; /dev/null) COMMENT= [ -x &quot;$PHP_BIN_PATH&quot; ] || COMMENT=&quot;#&quot; PHP_BIN_PATH=/path/to/php cat &gt;&gt; &quot;$rtorrentRc&quot; &lt;&lt; EOF ${COMMENT}execute = {sh,-c,$PHP_BIN_PATH $RUTORRENT_BASE_PATH/php/initplugins.php $webUser &amp;} EOF # Add user to web server&#39;s password file sed_i &quot;g/^$webUser:/d&quot; &quot;$WWW_PASSWORD_FILE&quot; $htpasswd -b &quot;$WWW_PASSWORD_FILE&quot; &quot;$webUser&quot; &quot;$webPass&quot; || errorExit &quot;Could not add user to password file&quot; resetAuthPasswordFilePermissions resetOwner &quot;$osUser&quot; &quot;$rtorrentRc&quot; &quot;$userDir&quot; &quot;$RTORRENT_DOWNLOAD_DIR&quot; &quot;$RTORRENT_WATCH_DIR&quot; &quot;$RTORRENT_SESSION_DIR&quot; # Required so some ruTorrent plugins work, eg. _getdir chmod 0755 &quot;$userDir&quot; # Protect some dirs and files, giving only the user and the web server # access. We need to do this since we set perms to 0755 above, or if # the perms already were 0755 to begin with. if [ -n &quot;$WWW_GROUP&quot; ]; then chmod 0600 &quot;$rtorrentRc&quot; for dir in $RTORRENT_REL_DOWNLOAD_DIR $RTORRENT_REL_WATCH_DIR $RTORRENT_REL_SESSION_DIR; do chown $osUser:$WWW_GROUP &quot;$userDir/$dir&quot; chmod 0770 &quot;$userDir/$dir&quot; done fi i=$(expr $i + 1) done [ &quot;$CREATE_ONE_PASSWORD_FILE_PER_USER&quot; = y ] &amp;&amp; createOnePasswordFilePerUser fi if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then [ -z &quot;$RUTORRENT_BASE_PATH&quot; ] &amp;&amp; errorExit &quot;Invalid ruTorrent base path.&quot; [ &quot;$REINSTALL_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; rm -rf &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; mkdir -p &quot;$RUTORRENT_BASE_PATH/plugins&quot; cd &quot;$RUTORRENT_BASE_PATH/plugins&quot; if [ -d &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; ]; then echo &quot;${CMSG}The autodl-irssi ruTorrent plugin dir already exists. Updating it...$CEND&quot; cd &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; if ! svn up $SVN_OPTS &gt; /dev/null; then errorExit &quot;Could not update the autodl-irssi ruTorrent plugin. Run the script as root.&quot; fi else echo &quot;${CMSG}Downloading the autodl-irssi ruTorrent plugin...$CEND&quot; if ! git clone &quot;$GIT_PATH_RUTORRENT_PLUGIN&quot; autodl-irssi &gt; /dev/null; then errorExit &quot;Could not check out the autodl-irssi ruTorrent plugin&quot; fi fi fi if [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ]; then if [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ]; then for packedUser in $USERS; do extractPackedUser $packedUser installUser &quot;$RUTORRENT_BASE_PATH/conf/users/$webUser/plugins/autodl-irssi&quot; &quot;$osUser&quot; &quot;$webUser&quot; &quot;$autodlPort&quot; &quot;$autodlPassword&quot; done else for packedUser in $USERS; do extractPackedUser $packedUser installUser &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; &quot;$osUser&quot; &quot;$webUser&quot; &quot;$autodlPort&quot; &quot;$autodlPassword&quot; [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; break done fi fi if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then verifyWebServerVars resetWebServerPermissions resetRutorrentUserPermissions # Restart it just in case we enabled/installed PHP modules. osHandler_$os restart_$INSTALL_WEB_SERVER fi if [ &quot;$INSTALL_VSFTPD&quot; = y ]; then echo &quot;${CMSG}Installing vsftpd...$CEND&quot; osHandler_$os installVsftpd fi if [ &quot;$INSTALL_WEBMIN&quot; = y ]; then cd rm -rf webmin-*/ webmin*.tar.gz if ! downloadFile webmin.tar.gz &quot;$WEBMIN_URL&quot;; then errorExit &quot;Could not download Webmin.&quot; fi tar xzf webmin.tar.gz rm -f webmin.tar.gz cd webmin-*/ || errorExit &quot;Could not CD to webmin dir&quot; osHandler_$os preWebminInstall [ -x &quot;setup.sh&quot; ] || errorExit &quot;Missing Webmin setup.sh file or not executable.&quot; cat &lt;&lt; EOF $CMSG Starting Webmin installer. Use another port than 10000, enable SSL, start webmin at boot, and use a strong admin password.$CEND $CWARNING When it asks you if it should use SSL and whether it should start at boot, type y.$CEND EOF ./setup.sh /usr/local/webmin osHandler_$os postWebminInstall cd rm -rf webmin-*/ fi if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then # Some plugins will fail unless they can write to the /tmp directory # We MUST do this AFTER installing Webmin since it will reset the perms! chmod 1777 /tmp fi if [ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ]; then for packedUser in $USERS; do extractPackedUser $packedUser echo &quot;${CMSG}Installing service for user $osUser.$CEND&quot; osHandler_$os installAutodlService $osUser done fi echo &quot;&quot; echo &quot;${CGREEN}================================= DONE =================================$CEND&quot; [ &quot;$INSTALLED_RTORRENT&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Built and installed rtorrent with XML-RPC support$CEND&quot; [ -n &quot;$INSTALL_WEB_SERVER&quot; ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed and configured web server ($INSTALL_WEB_SERVER)$CEND&quot; [ &quot;$INSTALL_VSFTPD&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed and configured FTP server (vsftpd)$CEND&quot; [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed ruTorrent$CEND&quot; [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed/updated the autodl-irssi ruTorrent plugin$CEND&quot; [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed autodl-irssi$CEND&quot; [ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed and started Irssi and rtorrent service$CEND&quot; [ &quot;$INSTALL_WEBMIN&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed Webmin$CEND&quot; if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then getIpAddress cat &lt;&lt; EOF ${CMSG}ruTorrent URLs.$CEND ${CWARNING}Verify that the IP address below is correct!$CEND ${CMAGENTA}http://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND ${CMAGENTA}https://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND EOF fi if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then cat &lt;&lt; EOF ${CMSG}rtorrent directories$CEND: EOF for packedUser in $USERS; do extractPackedUser $packedUser getRtorrentDirs &quot;$osUser&quot; cat &lt;&lt; EOF ${CMSG}User $CGREEN$osUser$CEND: ${CGREEN}Downloads$CEND : $CMAGENTA$RTORRENT_DOWNLOAD_DIR$CEND ${CGREEN}Watch dir$CEND : $CMAGENTA$RTORRENT_WATCH_DIR$CEND ${CGREEN}Session dir$CEND : $CMAGENTA$RTORRENT_SESSION_DIR$CEND ${CGREEN}rtorrent port$CEND: $CMAGENTA$rtorrentPort$CEND EOF done fi if [ -n &quot;$INSTALL_WEB_SERVER&quot; ]; then cat &lt;&lt; EOF ${CMSG}Web server info$CEND: ${CGREEN}Web server root$CEND: ${CMAGENTA}$WWW_ROOT$CEND ${CGREEN}ruTorrent dir$CEND : ${CMAGENTA}$RUTORRENT_BASE_PATH$CEND EOF fi if [ &quot;$INSTALL_VSFTPD&quot; = y ]; then getIpAddress cat &lt;&lt; EOF $CMSG To log in to the FTP server, use your $(uname -s) login name and password. I guessed the IP address below. Make sure it&#39;s correct.$CEND ${CGREEN}FTP IP address$CEND: ${CMAGENTA}$OUR_IP_ADDRESS$CEND ${CGREEN}FTP port$CEND: ${CMAGENTA}$FTP_PORT$CEND ${CGREEN}FTP server type$CEND: $CMAGENTA$FTP_SERVER_TYPE$CEND EOF fi if [ &quot;$INSTALL_WEBMIN&quot; = y ]; then getIpAddress WEBMIN_PORT= WEBMIN_SSL= WEBMIN_NAME= WEBMIN_CONFIG=/etc/webmin/miniserv.conf WEBMIN_USERS=/etc/webmin/miniserv.users if [ -f $WEBMIN_CONFIG ]; then WEBMIN_PORT=$(grep &#39;^port=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^port=\\([0-9]*\\).*/\\1/&#39;) WEBMIN_SSL=$(grep &#39;^ssl=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^ssl=\\([0-9]*\\).*/\\1/&#39;) WEBMIN_NAME=$(head -n1 $WEBMIN_USERS | cut -d: -f1) fi WEBMIN_PORT=${WEBMIN_PORT:-UNKNOWN} WEBMIN_NAME=${WEBMIN_NAME:-UNKNOWN} cat &lt;&lt; EOF $CMSG Webmin was installed. Port is $WEBMIN_PORT and the user is $WEBMIN_NAME. ${CRED}Verify the IP address below.$CEND EOF if [ -z &quot;$WEBMIN_SSL&quot; ]; then echo &quot; ${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot; echo &quot;${CMSG}or:$CEND&quot; echo &quot; ${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot; elif [ &quot;$WEBMIN_SSL&quot; = 0 ]; then echo &quot; ${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot; else echo &quot; ${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot; fi fi if [ -n &quot;$INSTALL_WEB_SERVER&quot; ] || [ &quot;$INSTALL_VSFTPD&quot; = y ] || \\ [ &quot;$INSTALL_RUTORRENT&quot; = y ] || [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then if [ &quot;$SELINUX_ENABLED&quot; = y ]; then cat &lt;&lt; EOF $CWARNING SELinux is enabled. It could cause some problems with the web server, vsftpd or ruTorrent. EOF fi fi if [ &quot;$CREATED_CERT_FILE&quot; = y ]; then cat &lt;&lt; EOF $CWARNING A self-signed certificate was created. Your browser or FTP client will most likely warn you about a non-trusted certificate.$CEND EOF fi if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then if isProgramInstalled php; then detectMissingPhpModules if [ -n &quot;$MISSING_PHP_MODULES&quot; ]; then cat &lt;&lt; EOF $CWARNING The following PHP modules seem to be missing. It&#39;s possible that the autodl-irssi ruTorrent plugin won&#39;t work. Missing PHP modules: $MISSING_PHP_MODULES$CEND EOF fi else cat &lt;&lt; EOF $CWARNING Could not find the php executable. Make sure the following PHP modules are enabled or the autodl-irssi ruTorrent plugin won&#39;t work: $REQUIRED_PHP_MODULES$CEND EOF fi fi",
        "headline": "Seedbox Config",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://parttimelegend.github.io/gistbook/gist/d71482792011133f46bb"
        },
        "url": "https://parttimelegend.github.io/gistbook/gist/d71482792011133f46bb"
      }
    </script>
    <!-- End Jekyll SEO tag -->
    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://parttimelegend.github.io/gistbook/feed.xml"
      title="Gistbook"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/gistbook/logo.png" />
    <link rel="stylesheet" href="/gistbook/assets/css/main.css" />
  </head>
  <body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/gistbook/">home</a>
        <article>
          <p class="post-meta">
            <time datetime="2015-08-29 14:09:29 +0000">2015-08-29</time>
          </p>

          <h1>Seedbox Config</h1>
          <noscript>
            <pre>
#!/bin/sh
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is IRC Auto Downloader
#
# The Initial Developer of the Original Code is
# David Nilsson.
# Portions created by the Initial Developer are Copyright (C) 2010, 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#
# ***** END LICENSE BLOCK *****

AUTODL_IRSSI_ZIP_URL=&quot;http://update.autodl-community.com/autodl-irssi-community.zip&quot;
GIT_PATH_RUTORRENT_PLUGIN=&quot;https://github.com/autodl-community/autodl-rutorrent.git&quot;

WEBMIN_URL=&quot;http://www.webmin.com/download/webmin-current.tar.gz&quot;

RUTORRENT_TRUNK_DIR=&quot;https://rutorrent.googlecode.com/svn/trunk&quot;

# The official tarballs are tried if subversion fails.
RUTORRENT_VERSION=&quot;3.6&quot;
RUTORRENT_CORE_NAME=&quot;rutorrent-$RUTORRENT_VERSION.tar.gz&quot;
RUTORRENT_CORE_URL=&quot;http://dl.bintray.com/novik65/generic/$RUTORRENT_CORE_NAME&quot;
#RUTORRENT_CORE_URL=&quot;http://rutorrent.googlecode.com/files/$RUTORRENT_CORE_NAME&quot;
RUTORRENT_PLUGINS_NAME=&quot;plugins-$RUTORRENT_VERSION.tar.gz&quot;
#RUTORRENT_PLUGINS_URL=&quot;http://rutorrent.googlecode.com/files/$RUTORRENT_PLUGINS_NAME&quot;
RUTORRENT_PLUGINS_URL=&quot;http://dl.bintray.com/novik65/generic/$RUTORRENT_PLUGINS_NAME&quot;
#RUTORRENT_CORE_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_CORE_NAME/download&quot;
#RUTORRENT_PLUGINS_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RUTORRENT_PLUGINS_NAME/download&quot;

RUTORRENT_PLUGINS=

# These are the ruTorrent plugins that will get installed. To remove one, either
# remove the whole line or comment it (prepend a &#39;#&#39; to the start of the line).
# If the line starts with &#39;#&#39;, the plugin is not installed.
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS _getdir&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS _task&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS autotools&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS chunks&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS cookies&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS cpuload&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS create&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS data&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS datadir&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS diskspace&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS edit&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS erasedata&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS extsearch&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS feeds&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS geoip&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS httprpc&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS ipad&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS loginmgr&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS logoff&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS mediainfo&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS ratio&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS retrackers&quot;
#RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS rpc&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS rss&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS rssurlrewrite&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS scheduler&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS seedingtime&quot;
#RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS show_peers_like_wtorrent&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS source&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS theme&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS throttle&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS tracklabels&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS trafic&quot;
RUTORRENT_PLUGINS=&quot;$RUTORRENT_PLUGINS unpack&quot;


# For building rtorrent
LIBCURL_NAME=&quot;curl-7.36.0&quot;
LIBCURL_URL=&quot;http://curl.haxx.se/download/$LIBCURL_NAME.tar.gz&quot;
SIGCPP20_NAME=&quot;libsigc++-2.3.1&quot;
SIGCPP20_URL=&quot;http://ftp.gnome.org/pub/GNOME/sources/libsigc++/2.3/$SIGCPP20_NAME.tar.gz&quot;
XMLRPC_SVN_DIR=&quot;https://svn.code.sf.net/p/xmlrpc-c/code/stable&quot;
LIBTORRENT_VERSION=&quot;0.13.4&quot;
LIBTORRENT_NAME=&quot;libtorrent-$LIBTORRENT_VERSION&quot;
LIBTORRENT_URL=&quot;http://libtorrent.rakshasa.no/downloads/$LIBTORRENT_NAME.tar.gz&quot;
LIBTORRENT_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$LIBTORRENT_NAME.tar.gz/download&quot;
RTORRENT_VERSION=&quot;0.9.4&quot;
RTORRENT_NAME=&quot;rtorrent-$RTORRENT_VERSION&quot;
RTORRENT_URL=&quot;http://libtorrent.rakshasa.no/downloads/$RTORRENT_NAME.tar.gz&quot;
RTORRENT_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/$RTORRENT_NAME.tar.gz/download&quot;

HTPASSWD_PY_SCRIPT_URL=&quot;http://trac.edgewall.org/export/10433/trunk/contrib/htpasswd.py&quot;
HTPASSWD_PY_SCRIPT_URL2=&quot;http://sourceforge.net/projects/autodl-irssi/files/inst-files/htpasswd.py/download&quot;

NGINX_NAME=&quot;nginx-1.7.0&quot;
NGINX_URL=&quot;http://nginx.org/download/$NGINX_NAME.tar.gz&quot;

LIGHTTPD_NAME=&quot;lighttpd-1.4.35&quot;
LIGHTTPD_URL=&quot;http://download.lighttpd.net/lighttpd/releases-1.4.x/$LIGHTTPD_NAME.tar.gz&quot;

MOD_SCGI_VERSION=&quot;1.14&quot;
MOD_SCGI_URL=&quot;http://python.ca/scgi/releases/scgi-$MOD_SCGI_VERSION.tar.gz&quot;

UNRAR_VERSION=&quot;4.0.7&quot;
UNRAR_URL=&quot;http://www.rarlab.com/rar/unrarsrc-$UNRAR_VERSION.tar.gz&quot;

# Dirs relative to user&#39;s home directory
RTORRENT_REL_DOWNLOAD_DIR=&quot;downloads&quot;
RTORRENT_REL_WATCH_DIR=&quot;rtorrent/watch&quot;
RTORRENT_REL_SESSION_DIR=&quot;rtorrent/session&quot;

REQUIRED_PERL_MODULES=&quot;Time::HiRes XML::LibXML Archive::Zip Net::SSLeay HTML::Parser Digest::SHA1 JSON&quot;
REQUIRED_PHP_MODULES=&quot;json xml sockets&quot;

# If set to y, add &#39;load perl&#39; to .irssi/startup
IRSSI_LOAD_PERL=n
IGNORE_IRSSI=n

# Start port. When we need a new port number, this port is incremented by one.
CURRENT_PORT=23875
DEFAULT_PORT_FTP=21
DEFAULT_PORT_FTPES=990
DEFAULT_UMASK=022
RPC_PREFIX=RPC

LSB_DEFAULT_START=&quot;2 3 4 5&quot;
LSB_DEFAULT_STOP=&quot;0 1 6&quot;

# Setting these to anything other than 80 and 443 may not work with Apache (since the
# code assumed it would always be 80 and 443).
HTTP_PORT=80
HTTPS_PORT=443

SCGI_HOST=&quot;127.0.0.1&quot;

INTERACTIVE=n
USE_RUTORRENT_PLUGIN=n
REINSTALL_RUTORRENT_PLUGIN=n
INSTALL_AUTODL_IRSSI=n
RUTORRENT_PASSWORD_PROTECTED=n
USERS=
RUTORRENT_BASE_PATH=
INSTALL_STARTUP_SCRIPT=n
BUILD_RTORRENT=n
INSTALL_WEB_SERVER=
INSTALL_RUTORRENT=n
INSTALL_VSFTPD=n
FTP_PORT=
USE_ENCRYPTED_FTP=n
INSTALL_WEBMIN=n
USER_TIMEZONE=

RUTORRENT_SITE_REALM=&quot;My ruTorrent web site&quot;
AUTODL_STARTUP_DESC=&quot;Start autodl-irssi and rtorrent&quot;
PHPCGI_STARTUP_DESC=&quot;Start php-cgi&quot;
NGINX_STARTUP_DESC=&quot;Start nginx&quot;
LIGHTTPD_STARTUP_DESC=&quot;Start lighttpd&quot;

PATH=&quot;$PATH:/usr/local/bin&quot;

# Find an echo that supports -e
echo=echo
for cmd in echo /bin/echo; do
	$cmd &gt;/dev/null 2&gt;&amp;1 || continue
	if ! $cmd -e &quot;&quot; | grep -qE &#39;^-e&#39;; then
		echo=$cmd
		break
	fi
done

CSI=$($echo -e &quot;\033[&quot;)
CEND=&quot;${CSI}0m&quot;
CDGREEN=&quot;${CSI}32m&quot;
CRED=&quot;${CSI}1;31m&quot;
CGREEN=&quot;${CSI}1;32m&quot;
CYELLOW=&quot;${CSI}1;33m&quot;
CBLUE=&quot;${CSI}1;34m&quot;
CMAGENTA=&quot;${CSI}1;35m&quot;
CCYAN=&quot;${CSI}1;36m&quot;
CQUESTION=&quot;$CMAGENTA&quot;
CWARNING=&quot;$CRED&quot;
CMSG=&quot;$CCYAN&quot;

errorExit() {
	cat &lt;&lt; EOF
$CWARNING
***ERROR***
$*
***ERROR***
$CEND
Help channel: ${CGREEN}#autodl-community@irc.p2p-network.net$CEND
EOF
	exit 1
}

exitHelp() {
	cat &lt;&lt; EOF

autodl-irssi and ruTorrent plugin installer

    sh $0 [options]

Options:

--rtorrent
    Will build and install rtorrent, libtorrent and xmlrpc-c from source code.

--rtorrent-noexec-patch
    Patch rtorrent to disallow remote users from executing code.

--apache
    Install Apache web server.

--nginx
    Install nginx web server.

--lighttpd
    Install lighttpd web server.

--rutorrent
    Install ruTorrent. Requires a web server, eg. --apache.

--vsftpd
    Install vsftpd.

--ftpes
    Use encrypted FTP (FTPES).

--ftp-port &lt;port&gt;
    FTP server port.

--webmin
    Install Webmin.

-p
--rutorrent-plugin
    Use or install the autodl-irssi ruTorrent plugin. If it&#39;s already installed,
    it will be updated (svn up), unless --reinstall-plugin option is used in
    which case it will be re-installed.

-i
--reinstall-plugin
    Re-install the autodl-irssi ruTorrent plugin if it&#39;s already installed.

-a
--install-autodl
    Install autodl-irssi.

-u user:autodlPass:webUser:webPass
--user user:autodlPass:webUser:webPass
    The $(uname -s) user, autodl-irssi password, ruTorrent user, ruTorrent password.
    You can use more than one -u option. If autodlPassword is not set, a random
    password will be used.

-w
--password-protected
    Use this option if ruTorrent is password protected. It&#39;s required if you
    want to use more than one ruTorrent user. Not needed if you install
    ruTorrent.

-r PATH
--rutorrent-base-path PATH
    Path to ruTorrent, eg. /var/www/rutorrent. Not needed if you install
    ruTorrent.

-s
--install-startup-script
    Install a startup script (service) which will start Irssi and rtorrent when
    the computer boots.

-h
--help
    Show this help text

Examples (as root user):

  sh $0 --rtorrent --apache --rutorrent --vsftpd --ftpes --webmin -p -a -s -u user1::user1:pass1 -u user2::user2:pass2

Installs rtorrent, Apache, ruTorrent, vsftpd (encrypted), Webmin the
autodl-irssi plugin, autodl-irssi, installs a service (starting Irssi and
rtorrent) for both users.

  sh $0 -p -a -u user::user:pass -r /var/www/rutorrent -s

Installs autodl-irssi + ruTorrent plugin for user &#39;user&#39;. ruTorrent has not been
password protected. Also installs the startup script.

  sh $0 -p -a -u user1::user1:pass1 -u user2::user2:pass2 -w -r /var/www/rutorrent -s

Installs autodl-irssi + ruTorrent plugin for users &#39;user1&#39; and &#39;user2&#39;.
ruTorrent has been password protected. Also installs the startup script.

  sh $0 --rtorrent -a -u user1 -u user2 -u user3 -u user4 -s

Installs rtorrent, autodl-irssi and the startup script.

Help fchannel: #autodl-community@irc.p2p-network.net
EOF
	exit 1
}

parseCommandLine() {
	while [ $# -gt 0 ]; do
		local arg=&quot;$1&quot;
		shift

		if [ &quot;$arg&quot; = &quot;-p&quot; ] || [ &quot;$arg&quot; = &quot;--rutorrent-plugin&quot; ]; then
			USE_RUTORRENT_PLUGIN=y
		elif [ &quot;$arg&quot; = &quot;-i&quot; ] || [ &quot;$arg&quot; = &quot;--reinstall-plugin&quot; ]; then
			REINSTALL_RUTORRENT_PLUGIN=y
		elif [ &quot;$arg&quot; = &quot;-a&quot; ] || [ &quot;$arg&quot; = &quot;--install-autodl&quot; ]; then
			INSTALL_AUTODL_IRSSI=y
		elif [ &quot;$arg&quot; = &quot;-u&quot; ] || [ &quot;$arg&quot; = &quot;--user&quot; ]; then
			USERS=&quot;$USERS $1&quot;
			shift
		elif [ &quot;$arg&quot; = &quot;-w&quot; ] || [ &quot;$arg&quot; = &quot;--password-protected&quot; ]; then
			RUTORRENT_PASSWORD_PROTECTED=y
		elif [ &quot;$arg&quot; = &quot;-r&quot; ] || [ &quot;$arg&quot; = &quot;--rutorrent-base-path&quot; ]; then
			RUTORRENT_BASE_PATH=&quot;$1&quot;
			shift
		elif [ &quot;$arg&quot; = &quot;-s&quot; ] || [ &quot;$arg&quot; = &quot;--install-startup-script&quot; ]; then
			INSTALL_STARTUP_SCRIPT=y
		elif [ &quot;$arg&quot; = &quot;--rtorrent&quot; ]; then
			BUILD_RTORRENT=y
		elif [ &quot;$arg&quot; = &quot;--apache&quot; ]; then
			INSTALL_WEB_SERVER=apache
		elif [ &quot;$arg&quot; = &quot;--nginx&quot; ]; then
			INSTALL_WEB_SERVER=nginx
		elif [ &quot;$arg&quot; = &quot;--lighttpd&quot; ]; then
			INSTALL_WEB_SERVER=lighttpd
		elif [ &quot;$arg&quot; = &quot;--rutorrent&quot; ]; then
			INSTALL_RUTORRENT=y
		elif [ &quot;$arg&quot; = &quot;--vsftpd&quot; ]; then
			INSTALL_VSFTPD=y
		elif [ &quot;$arg&quot; = &quot;--ftpes&quot; ]; then
			USE_ENCRYPTED_FTP=y
		elif [ &quot;$arg&quot; = &quot;--ftp-port&quot; ]; then
			FTP_PORT=&quot;$1&quot;
			shift
		elif [ &quot;$arg&quot; = &quot;--webmin&quot; ]; then
			INSTALL_WEBMIN=y
		else
			exitHelp
		fi
	done
}

# Sets os and os_long to the OS type and OS name respectively
detectOs() {
	local DISTRIB_ID=
	local DISTRIB_DESCRIPTION=
	if [ -f /etc/lsb-release ]; then
		. /etc/lsb-release
	fi

	if [ -f /etc/fedora-release ]; then
		os=fedora
		os_long=&quot;$(cat /etc/fedora-release)&quot;
	# Must be before a whole bunch of other OS tests
	elif [ &quot;$DISTRIB_ID&quot; = &quot;Ubuntu&quot; ]; then
		os=debian
		os_long=&quot;$DISTRIB_DESCRIPTION&quot;
	elif [ &quot;$DISTRIB_ID&quot; = &quot;LinuxMint&quot; ]; then
		os=debian
		os_long=&quot;$DISTRIB_DESCRIPTION&quot;
	# Must be before Debian
	elif [ &quot;$DISTRIB_ID&quot; = &quot;Peppermint&quot; ]; then
		os=debian
		os_long=&quot;$DISTRIB_DESCRIPTION&quot;
	elif [ &quot;$DISTRIB_ID&quot; = &quot;MEPIS&quot; ]; then
		os=debian
		os_long=&quot;$DISTRIB_DESCRIPTION&quot;
	elif [ -f /etc/clearos-release ]; then
		os=fedora
		os_long=&quot;$(cat /etc/clearos-release)&quot;
	elif [ -f /etc/debian_version ]; then
		os=debian
		local prefix=
		if ! uname -s | grep -q GNU; then
			prefix=&quot;GNU/&quot;
		fi
		os_long=&quot;Debian $prefix$(uname -s) $(cat /etc/debian_version)&quot;
	elif [ -f /etc/redhat-release ]; then
		os=fedora
		os_long=&quot;$(cat /etc/redhat-release)&quot;
	else
         echo -e &quot;\e[1;31mYour OS is not detected as an OS supported by this script. This script only supports \e[5;32mDebian and Fedora\e[0m \e[1;31mbased OSes.\e[0m&quot;
         exit 1

	fi

	os_long=&quot;${os_long:-$(uname -s)}&quot;
}

# In-place editing like sed -i but more portable...
sed_i() {
	local cmd=&quot;$1&quot;
	local file=&quot;$2&quot;
	isProgramInstalled ed || errorExit &quot;ed is not installed!&quot;
	local addr=&quot;,&quot;
	echo &quot;$cmd&quot; | grep -qE &#39;^/&#39; &amp;&amp; addr=
	ed -s &quot;$file&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF
$addr$cmd
w
q
EOF
}

getFirst() {
	echo $1
}

# Returns true if $1 is one of $2..$n
arrayIsPresent() {
	local val=&quot;$1&quot;
	shift
	for v in &quot;$@&quot;; do
		[ &quot;$v&quot; = &quot;$val&quot; ] &amp;&amp; return 0
	done
	return 1
}

canGeneratePasswords() {
	[ -c /dev/urandom ]
}

generatePassword() {
	newPassword=$(cat /dev/urandom | tr -dc _A-Z-a-z-0-9 | head -c17)
}

isProgramInstalled() {
	which &quot;$1&quot; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0
	return 1
}

isPerlModuleInstalled() {
	perl -M$1 -e &#39;&#39; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0
	return 1
}

# Add $1 or $2 if it exists, to PACKAGES if program $1 isn&#39;t present
addProgram() {
	isProgramInstalled $1 || PACKAGES=&quot;$PACKAGES ${2:-$1}&quot;
}

# Add $2 to PACKAGES if perl module $1 isn&#39;t present
addPerlModule() {
	isPerlModuleInstalled $1 || PACKAGES=&quot;$PACKAGES $2&quot;
}

installPackages() {
	[ -z &quot;$INSTALL&quot; ] &amp;&amp; return
	[ -z &quot;$PACKAGES&quot; ] &amp;&amp; return
	$INSTALL $PACKAGES
	PACKAGES=
}

installPerlModule() {
	isPerlModuleInstalled $1 || $INSTALL $2
}

installProgram() {
	isProgramInstalled $1 || $INSTALL ${2:-$1}
}

installBuildTools() {
	[ &quot;$BUILD_TOOLS_INSTALLED&quot; = y ] &amp;&amp; return
	PACKAGES=&quot;$BUILD_TOOLS&quot;
	installPackages
	BUILD_TOOLS_INSTALLED=y
}

# Detects missing Perl modules and stores them in MISSING_PERL_MODULES
detectMissingPerlModules() {
	OLD_PERL_MODULES=
	MISSING_PERL_MODULES=
	for module in $REQUIRED_PERL_MODULES; do
		isPerlModuleInstalled $module || MISSING_PERL_MODULES=&quot;$MISSING_PERL_MODULES $module&quot;
	done

	# Make sure the JSON module is new
	if isPerlModuleInstalled JSON &amp;&amp; ! perl -MJSON -e &#39;&amp;decode_json(&quot;{}&quot;)&#39; &gt; /dev/null 2&gt;&amp;1; then
		echo &quot;${CWARNING}Old JSON module is installed. Need to install from CPAN.$CEND&quot;
		MISSING_PERL_MODULES=&quot;$MISSING_PERL_MODULES JSON&quot;
		OLD_PERL_MODULES=&quot;$OLD_PERL_MODULES JSON&quot;
	fi

	if echo &quot;$MISSING_PERL_MODULES&quot; | grep -wq JSON; then
		MISSING_PERL_MODULES=&quot;JSON::XS $MISSING_PERL_MODULES&quot;
	fi
	if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;XML::LibXML&#39;; then
		# Sometimes the cpan script doesn&#39;t install the required dependencies
		MISSING_PERL_MODULES=&quot;XML::NamespaceSupport XML::SAX $MISSING_PERL_MODULES&quot;
	fi
}

# Detect where cpan is installed and place the path in the CPAN variable.
# PCLinuxOS/Mandriva append the version number...
detectCpanBin() {
	for file in $(which cpan 2&gt; /dev/null) $(ls /usr/bin/cpan-* 2&gt; /dev/null); do
		if [ -x &quot;$file&quot; ]; then
			CPAN=&quot;$file&quot;
			return
		fi
	done
	isPerlModuleInstalled CPAN &amp;&amp; return
	errorExit &quot;Could not find the cpan script or the CPAN Perl module. Can&#39;t install missing Perl modules.&quot;
}

isValidTzName() {
	echo &quot;$1&quot; | LC_ALL=C grep -qE &#39;^[A-Z][^/ ]*(/[A-Z][^/ ]*)?$&#39; &amp;&amp; return 0
	return 1
}

detectTimeZone() {
	[ -n &quot;$USER_TIMEZONE&quot; ] &amp;&amp; return

	local hash=
	local hasher=
	local files=
	local zoneinfoPath=/usr/share/zoneinfo
	[ -d &quot;$zoneinfoPath&quot; ] || return
	if hasher=md5sum; isProgramInstalled $hasher || hasher=sha1sum; isProgramInstalled $hasher; then
		hash=$($hasher /etc/localtime | awk &#39;{print $1}&#39;)
		files=&quot;$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E &quot;^$hash\\&gt;&quot; | awk &#39;{print $2}&#39;)&quot;
	elif hasher=md5; isProgramInstalled $hasher || hasher=sha1; isProgramInstalled $hasher; then
		hash=$($hasher /etc/localtime | sed -e &#39;s/^.* = \([a-zA-Z0-9]*\)$/\1/&#39;)
		files=&quot;$(find $zoneinfoPath -type f -print | xargs $hasher | grep -E &quot;$hash\$&quot; | sed -e &#39;s/^[^ ]* (\([^)]*\)).*/\1/&#39;)&quot;
	else
		return
	fi

	# Detect all possible timezone names
	local timezones=
	for path in $files; do
		local tz=&quot;${path#$zoneinfoPath/}&quot;
		while true; do
			isValidTzName &quot;$tz&quot; &amp;&amp; break
			local newTz=&quot;${tz#*/}&quot;
			[ &quot;$newTz&quot; = &quot;$tz&quot; ] &amp;&amp; tz= &amp;&amp; break
			tz=&quot;$newTz&quot;
		done
		isValidTzName &quot;$tz&quot; &amp;&amp; timezones=&quot;$timezones $tz&quot;
	done

	# Now find the ones PHP likes...
	local okRegions=&quot;(Africa|America|Antarctica|Arctic|Asia|Atlantic|Australia|Europe|Indian|Pacific)&quot;
	for tz in $timezones; do
		echo &quot;$tz&quot; | grep -qE &quot;^$okRegions/&quot; &amp;&amp; USER_TIMEZONE=&quot;$tz&quot; &amp;&amp; return
	done

	# Return the first one we found
	for tz in $timezones; do
		USER_TIMEZONE=&quot;$tz&quot;
		return
	done
}

getNumCpus() {
	[ -n &quot;$NUMCPUS&quot; ] &amp;&amp; return
	[ -f /proc/cpuinfo ] &amp;&amp; NUMCPUS=$(cat /proc/cpuinfo | grep &#39;^processor&#39; | wc -l) &amp;&amp; return
	isProgramInstalled sysctl &amp;&amp; sysctl -n hw.ncpu | grep -qE &#39;^[1-9][0-9]*$&#39; &amp;&amp; NUMCPUS=$(sysctl -n hw.ncpu) &amp;&amp; return
	NUMCPUS=1
}

# Appends $value to $varName in $file, creating the var if it doesn&#39;t exist. The
# value is not appended if it already exists.
appendFileStringVar() {
	local file=&quot;$1&quot;
	local varName=&quot;$2&quot;
	local value=&quot;$3&quot;

	[ -f &quot;$file&quot; ] || errorExit &quot;File &#39;$file&#39; does not exist&quot;

	local varLine=$(grep -E &quot;^$varName=&quot; &quot;$file&quot; | tail -n1)
	if [ -z &quot;$varLine&quot; ]; then
		echo &quot;$varName=\&quot;$value\&quot;&quot; &gt;&gt; &quot;$file&quot;
	else
		echo &quot;$varLine&quot; | grep -qE &quot;[=&#39;\&quot; ]$value(\&quot;|&#39;| |$)&quot; &amp;&amp; return

		local q=
		echo &quot;$varLine&quot; | grep -qE &quot;^$varName=&#39;&quot; &amp;&amp; q=&quot;&#39;&quot;
		echo &quot;$varLine&quot; | grep -qE &quot;^$varName=\&quot;&quot; &amp;&amp; q=&#39;&quot;&#39;
		sed_i &quot;s#^\\($varName=\\)$q\\(.*\\)$q#\\1\&quot;\\2 $value\&quot;#&quot; &quot;$file&quot;
	fi
}

# Set a variable in a script file to a new value. The variable is created if it does not exist
setScriptVariable() {
	local file=&quot;$1&quot;
	local name=$2
	local value=&quot;$3&quot;

	[ -f &quot;$file&quot; ] || errorExit &quot;File does not exist: $file&quot;

	local newLine=&quot;$name=\&quot;$value\&quot;&quot;
	if grep -qE &quot;^$name=&quot; $file; then
		sed_i &quot;s!^$name=.*\$!$newLine!&quot; &quot;$file&quot;
	else
		echo &quot;$newLine&quot; &gt;&gt; &quot;$file&quot;
	fi
}

userExists() {
	id -rg &quot;$1&quot; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return 0
	return 1
}

setSvnOpts() {
	SVN_OPTS=
	isProgramInstalled svn || return
	# svn sometimes gives an error message &#39;broken pipe&#39;. Ignore it.
	if svn help co 2&gt;/dev/null | grep -q &#39;non-interactive&#39; &amp;&amp; svn help co 2&gt;/dev/null | grep -q &#39;trust-server-cert&#39;; then
		SVN_OPTS=&quot;--non-interactive --trust-server-cert&quot;
	fi
}

downloadFile() {
	local filename=&quot;$1&quot;
	shift
	for url in &quot;$@&quot;; do
		for i in 1 2 3 4 5; do
			wget --no-check-certificate -O &quot;$filename&quot; &quot;$url&quot; &amp;&amp; return 0
		done
	done
	return 1
}

buildMakeProgram() {
	local url=&quot;$1&quot;
	local name=&quot;$2&quot;
	local builddir=&quot;$3&quot;
	local srcdir=&quot;$4&quot;
	local makefile=&quot;${5:-Makefile}&quot;

	buildStart
	echo &quot;${CMSG}Downloading $name source code...$CEND&quot;
	cd &quot;$BUILD_DIR&quot;
	local filename=&quot;${url##*/}&quot;
	downloadFile &quot;$filename&quot; &quot;$url&quot; || errorExit &quot;Could not download $name source code.&quot;
	tar xzf &quot;$filename&quot;
	srcdir=&quot;${srcdir:-${filename%.tar.gz}}&quot;
	cd &quot;$srcdir/$builddir&quot;
	local make=${MAKE:-make}
	echo &quot;${CMSG}Building $name...$CEND&quot;
	$make -f $makefile all || errorExit &quot;Could not build $name.&quot;
	$make -f $makefile install || errorExit &quot;Could not install $name.&quot;
	echo &quot;${CMSG}$name is now installed$CEND&quot;
	buildEnd
}

buildProgram() {
	local prog=&quot;$1&quot;

	echo &quot;${CMSG}Building $prog...$CEND&quot;

	./configure --prefix=$PREFIX $2 || errorExit &quot;Could not configure $prog. Try again, or try logging out and in and try again.&quot;

	getNumCpus
	local make=${MAKE:-make}
	local makeopts=&quot;-j$NUMCPUS&quot;
	$make $makeopts || $make || errorExit &quot;Could not build $prog&quot;
	$make install || errorExit &quot;Could not install $prog&quot;

	local ldsoconf=/etc/ld.so.conf
	touch &quot;$ldsoconf&quot;
	grep -qE &quot;^$PREFIX/lib$&quot; $ldsoconf || echo &quot;$PREFIX/lib&quot; &gt;&gt; $ldsoconf
	ldconfig || errorExit &quot;ldconfig failed&quot;

	echo &quot;${CMSG}$prog is now installed.$CEND&quot;
}

downloadAndBuild() {
	local prog=&quot;$1&quot;
	local urls=&quot;$2&quot;
	local name=&quot;$3&quot;
	local configOptions=&quot;$4&quot;
	local patchUrl=&quot;$5&quot;

	cd &quot;$BUILD_DIR&quot;
	echo &quot;${CMSG}Downloading $prog source code...$CEND&quot;
	downloadFile &quot;$name.tar.gz&quot; $urls || errorExit &quot;Could not download $prog source code.&quot;
	tar xzf $name.tar.gz

	if echo &quot;$patchUrl&quot; | grep &#39;^[a-z]*://&#39;; then
		echo &quot;${CMSG}Patching $prog...$CEND&quot;
		PACKAGES=&quot;patch&quot;
		installPackages
		isProgramInstalled patch || errorExit &quot;patch is not installed!&quot;
		downloadFile the.patch &quot;$patchUrl&quot; || errorExit &quot;Could not download the patch file.&quot;
		patch -p1 -d $name &lt; the.patch || errorExit &quot;Could not patch $prog.&quot;
	elif [ -n &quot;$patchUrl&quot; ]; then
		echo &quot;${CMSG}Patching $prog...$CEND&quot;
		cd $name
		eval $patchUrl
		cd ..
	fi

	cd $name
	buildProgram &quot;$prog&quot; &quot;$configOptions&quot;
}

checkoutAndBuild() {
	local prog=&quot;$1&quot;
	local url=&quot;$2&quot;
	local configOptions=&quot;$3&quot;
	cd &quot;$BUILD_DIR&quot;
	echo &quot;${CMSG}Downloading $prog source code...$CEND&quot;
	svn export $SVN_OPTS &quot;$url&quot; &quot;$prog&quot; || errorExit &quot;Could not download $prog source code.&quot;
	cd &quot;$prog&quot;
	buildProgram &quot;$prog&quot; &quot;$configOptions&quot;
}

buildStart() {
	PREFIX=/usr/local
	OLD_PATH=&quot;$PATH&quot;
	PATH=&quot;$PATH:$PREFIX/bin&quot;
	PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
	export PKG_CONFIG_PATH
	BUILD_DIR=&quot;$(echo ~)/build-tmp&quot;

	rm -rf &quot;$BUILD_DIR&quot;
	mkdir &quot;$BUILD_DIR&quot; || errorExit &quot;Could not create build directory.&quot;
}

buildEnd() {
	cd
	rm -rf &quot;$BUILD_DIR&quot;

	[ -n &quot;$OLD_PATH&quot; ] &amp;&amp; PATH=&quot;$OLD_PATH&quot;
	unset OLD_PATH
	unset PKG_CONFIG_PATH
}

buildRtorrent() {
	installBuildTools
	osHandler_$os installRtorrentBuildTools
	isProgramInstalled pkg-config || errorExit &quot;pkg-config is not installed.&quot;

	# Minimum version is 7.15.4 but I had problems with 7.15.5 on CentOS. Set
	# it to 7.18.0 (the version Ubuntu Server 8.04 is using).
	if ! pkg-config --atleast-version=7.18.0 libcurl; then
		downloadAndBuild &quot;libcurl&quot; &quot;$LIBCURL_URL&quot; &quot;$LIBCURL_NAME&quot; &quot;&quot;
		# Prevent &#39;Unknown keyword &#39;URL&#39; in ....&#39; error
		sed_i &#39;s/^URL:/#URL:/&#39; $PREFIX/lib/pkgconfig/libcurl.pc
	fi
	if ! pkg-config --exists sigc++-2.0; then
		downloadAndBuild &quot;sigc++-2.0&quot; &quot;$SIGCPP20_URL&quot; &quot;$SIGCPP20_NAME&quot; &quot;&quot;
	fi
	checkoutAndBuild &quot;xmlrpc-c&quot; &quot;$XMLRPC_SVN_DIR&quot; &quot;--disable-cplusplus&quot;
	downloadAndBuild &quot;libtorrent&quot; &quot;$LIBTORRENT_URL $LIBTORRENT_URL2&quot; &quot;$LIBTORRENT_NAME&quot; &quot;&quot; patchLibtorrent
	downloadAndBuild &quot;rtorrent&quot; &quot;$RTORRENT_URL $RTORRENT_URL2&quot; &quot;$RTORRENT_NAME&quot; &quot;--with-xmlrpc-c&quot; &quot;&quot;
}

patchLibtorrent() {
	# For gcc 4.6.0
	ed -s &quot;src/torrent/data/block_transfer.h&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF
/#define LIBTORRENT_BLOCK_TRANSFER_H
a
#include &lt;stddef.h&gt;
.
w
q
EOF
	ed -s &quot;src/data/memory_chunk.cc&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF
/#include &quot;config.h&quot;
a
#include &lt;stddef.h&gt;
.
w
q
EOF
}

installRtorrent() {
	buildStart
	buildRtorrent
	buildEnd
}

installUnrar() {
	isProgramInstalled unrar &amp;&amp; return
	installBuildTools
	buildMakeProgram &quot;$UNRAR_URL&quot; &quot;unrar&quot; &quot;&quot; &quot;unrar&quot; &quot;makefile.unix&quot;
}

installModScgi() {
	local modScgiFile=&quot;$1&quot;
	local modulesPath=&quot;$2&quot;
	[ -f &quot;$modScgiFile&quot; ] &amp;&amp; errorExit &quot;mod_scgi file already exists.&quot;
	[ -d &quot;$modulesPath&quot; ] || errorExit &quot;Apache modules path &#39;$modulesPath&#39; does not exist.&quot;

	buildMakeProgram &quot;$MOD_SCGI_URL&quot; &quot;mod_scgi&quot; &quot;apache2&quot;
	echo &quot;LoadModule scgi_module $modulesPath/mod_scgi.so&quot; &gt; $modScgiFile
}

isPortUsed() {
	local port=&quot;$1&quot;
	netstat -an | grep tcp | grep -w LISTEN | grep -qE &quot;[.:]$port[ 	]&quot; &amp;&amp; return 0
	return 1
}

isValidIpAddress() {
	# It&#39;s not 100% accurate ... ;)
	echo $1 | grep -qE &#39;^[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?$&#39;
}

getIpAddress() {
	isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; &amp;&amp; return
	echo &quot;${CMSG}Detecting your IP address...$CEND&quot;
	isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; || OUR_IP_ADDRESS=$(wget --no-check-certificate http://www.whatismyip.com/automation/n09230945.asp -O - -o /dev/null)
	isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; || OUR_IP_ADDRESS=$(ifconfig -a | grep &quot;inet addr&quot; | head -n1 | awk -F: &#39;{print $2}&#39; | awk &#39;{print $1}&#39;)
	isValidIpAddress &quot;$OUR_IP_ADDRESS&quot; || OUR_IP_ADDRESS=&quot;1.2.3.4&quot;
}

getNewPortNumber() {
	while true; do
		newPortNumber=$CURRENT_PORT
		CURRENT_PORT=$(expr $CURRENT_PORT + 1)
		isValidPortNumber $newPortNumber || errorExit &quot;Invalid port number. Change CURRENT_PORT.&quot;
		isPortUsed $newPortNumber || break
		echo &quot;${CWARNING}Port $newPortNumber is in use, trying next port...$CEND&quot;
	done
}

# Returns true if it&#39;s a valid ruTorrent base path
isValidRutorrentBasePath() {
	[ -n &quot;$1&quot; ] &amp;&amp; [ -d &quot;$1/conf&quot; ]
}

isValidPassword() {
	echo &quot;$1&quot; | grep -qE &quot;^ &quot; &amp;&amp; return 1
	echo &quot;$1&quot; | grep -qE &quot; \$&quot; &amp;&amp; return 1
	echo &quot;$1&quot; | grep -qE &#39;^$&#39; &amp;&amp; return 1
	echo &quot;$1&quot; | grep -q &#39;:&#39; &amp;&amp; return 1
	echo &quot;&#39;$1&#39;&quot; | grep -q &#39; &#39; &amp;&amp; return 1
	return 0
}

isValidPortNumber() {
	echo &quot;$1&quot; | grep -qiE &#39;^[0-9]+$&#39; || return 1
	echo &quot;$1&quot; | grep -qiE &#39;[0-9][0-9][0-9][0-9][0-9][0-9]&#39; &amp;&amp; return 1
	[ $1 -ge 1024 ] &amp;&amp; [ $1 -le 65535 ]
}

isValidWebUser() {
	[ -z &quot;$1&quot; ] &amp;&amp; return 1
	echo &quot;$1&quot; | LC_ALL=C grep -qE &#39;[A-Z:]&#39; &amp;&amp; return 1
	return 0
}

initUsers() {
	local users=
	for packedUser in $USERS; do
		extractPackedUser $packedUser

		if [ -z &quot;$autodlPort&quot; ]; then
			getNewPortNumber
			autodlPort=$newPortNumber
		fi
		if [ -z &quot;$scgiPort&quot; ]; then
			getNewPortNumber
			scgiPort=$newPortNumber
		fi
		if [ -z &quot;$rtorrentPort&quot; ]; then
			getNewPortNumber
			rtorrentPort=$newPortNumber
		fi
		if canGeneratePasswords; then
			if [ -z &quot;$autodlPassword&quot; ]; then
				generatePassword
				autodlPassword=&quot;$newPassword&quot;
			fi
		fi

		users=&quot;$users $osUser:$autodlPassword:$webUser:$webPass:$autodlPort:$scgiPort:$rtorrentPort&quot;
	done
	USERS=&quot;$users&quot;
}

extractPackedUser() {
	local packedUser=&quot;$1&quot;

	osUser=&quot;$(echo $packedUser | cut -d: -f1)&quot;
	autodlPassword=&quot;$(echo $packedUser | cut -d: -f2)&quot;
	webUser=&quot;$(echo $packedUser | cut -d: -f3)&quot;
	webPass=&quot;$(echo $packedUser | cut -d: -f4)&quot;
	autodlPort=&quot;$(echo $packedUser | cut -d: -f5)&quot;
	scgiPort=&quot;$(echo $packedUser | cut -d: -f6)&quot;
	rtorrentPort=&quot;$(echo $packedUser | cut -d: -f7)&quot;
}

getUserGroup() {
	local user=&quot;$1&quot;

	userExists &quot;$user&quot; || errorExit &quot;The user &#39;$user&#39; does not exist.&quot;
	group=$(grep -w $(id -rg $user) /etc/group | cut -d: -f1)
	[ -z &quot;$group&quot; ] &amp;&amp; group=&quot;$user&quot;
}

getUserDir() {
	local user=&quot;$1&quot;

	[ -z &quot;$user&quot; ] &amp;&amp; errorExit &quot;Invalid user (blank).&quot;
	userDir=&quot;$(eval echo ~$user)&quot;
	[ -d &quot;$userDir&quot; ] || errorExit &quot;User $user&#39;s home directory does not exist.&quot;
}

resetOwner() {
	local user=&quot;$1&quot;
	shift

	if [ &quot;$ISROOT&quot; = y ]; then
		getUserGroup &quot;$user&quot;
		chown -R $user:$group &quot;$@&quot;
	fi
}

# Updates MISSING_PHP_MODULES with all missing required PHP modules
detectMissingPhpModules() {
	MISSING_PHP_MODULES=
	local php=${WWW_PHP_CGI:-php}
	for module in $REQUIRED_PHP_MODULES; do
		$php -m 2&gt; /dev/null | grep -wq $module || MISSING_PHP_MODULES=&quot;$MISSING_PHP_MODULES $module&quot;
	done
}

installMissingPhpPackages() {
	PACKAGES=
	for module in $MISSING_PHP_MODULES; do
		PACKAGES=&quot;$PACKAGES php-$module&quot;
	done
	installPackages
}

installMissingPhp5Packages() {
	PACKAGES=
	for module in $MISSING_PHP_MODULES; do
		PACKAGES=&quot;$PACKAGES php5-$module&quot;
	done
	installPackages
}

enablePhpIniModules() {
	local phpIni=&quot;$1&quot;
	shift
	for module in &quot;$@&quot;; do
		grep -qE &quot;^extension=$module.so&quot; &quot;$phpIni&quot; &amp;&amp; continue
		sed_i &quot;s/^; *\\(extension=$module.so.*\\)/\\1/&quot; &quot;$phpIni&quot;
		grep -qE &quot;^extension=$module.so&quot; &quot;$phpIni&quot; &amp;&amp; continue
		echo &quot;extension=$module.so&quot; &gt;&gt; &quot;$phpIni&quot;
	done
}

installMissingPhpModules() {
	detectMissingPhpModules
	[ -z &quot;$MISSING_PHP_MODULES&quot; ] &amp;&amp; return

	osHandler_$os installPhpModules

	detectMissingPhpModules
	[ -z &quot;$MISSING_PHP_MODULES&quot; ] &amp;&amp; return
	cat &lt;&lt; EOF
$CWARNING
The following PHP modules appear to be missing:
	$MISSING_PHP_MODULES
If the autodl-irssi ruTorrent plugin isn&#39;t working, you now know why. Install
them using your package manager or enable them in your php.ini file, and
restart your web server.$CEND
EOF
}

addLogrotateConfig() {
	local serviceName=&quot;$1&quot;
	local logFiles=&quot;$2&quot;
	local postrotateScript=&quot;$3&quot;

	local logrotate_d=/etc/logrotate.d
	[ -d &quot;$logrotate_d&quot; ] || errorExit &quot;Missing logrotate dir: $logrotate_d&quot;

	cat &gt; &quot;$logrotate_d/$serviceName&quot; &lt;&lt; EOF
$logFiles {
	missingok
	daily
	rotate 14
	notifempty
	compress
	delaycompress
	sharedscripts
	postrotate
		$postrotateScript
	endscript
}
EOF
	[ $? -eq 0 ] || errorExit &quot;Could not write logrotate file $logrotate_d/$serviceName&quot;
}

detectPhpCgi() {
	WWW_PHP_CGI=${WWW_PHP_CGI:-$(which php-cgi | head -n1)}
	[ -x &quot;$WWW_PHP_CGI&quot; ] || errorExit &quot;Could not find php-cgi&quot;
	&quot;$WWW_PHP_CGI&quot; -v | grep -q &#39;cgi-fcgi&#39; || errorExit &quot;$WWW_PHP_CGI does not support FastCGI&quot;
}

# $i is the i&#39;th user number
getUserRpcMount() {
	local i=$1
	verifyWebServerVars
	# Make sure /RPC10 accesses aren&#39;t going to /RPC1 by padding with zeros. This is
	# easier than making sure every web server handles it correctly. Eg., lighttpd&#39;s
	# scgi.server table is read in order, so if you add /RPC1 before /RPC10, then
	# /RPC10 accesses will go to /RPC1. A fix would of course be to place /RPC10
	# before /RPC1 but it&#39;s easy to forget. Now we use /RPC00001 .. /RPC99999
	echo &quot;/$RPC_PREFIX$(printf &#39;%05d&#39; $i)&quot;
}

createSelfSignedCertFile() {
	local pemfile=&quot;$1&quot;

	if [ ! -f &quot;$OTHER_PEM_FILE&quot; ]; then
		echo &quot;${CMSG}Creating the self-signed certificate.$CEND&quot;
		rm -f &quot;$pemfile&quot;
		openssl req -new -newkey rsa:1024 -days 1000 -nodes -x509 -keyout &quot;$pemfile&quot; -out &quot;$pemfile&quot; -batch \
			|| errorExit &quot;Failed to create self-signed certificate.&quot;
		OTHER_PEM_FILE=&quot;$pemfile&quot;
		CREATED_CERT_FILE=y
	else
		rm -f &quot;$pemfile&quot;
		cp &quot;$OTHER_PEM_FILE&quot; &quot;$pemfile&quot; || errorExit &quot;Failed to copy self-signed certificate.&quot;
	fi

	chmod 0600 &quot;$pemfile&quot;
}

detectHtpasswd() {
	[ -z &quot;$htpasswd&quot; ] &amp;&amp; isProgramInstalled htpasswd &amp;&amp; htpasswd=htpasswd
	[ -z &quot;$htpasswd&quot; ] &amp;&amp; isProgramInstalled htpasswd2 &amp;&amp; htpasswd=htpasswd2
	if [ -z &quot;$htpasswd&quot; ]; then
		installProgram python
		if isProgramInstalled python; then
			cd
			downloadFile &quot;htpasswd.py&quot; &quot;$HTPASSWD_PY_SCRIPT_URL&quot; &quot;$HTPASSWD_PY_SCRIPT_URL2&quot; \
				&amp;&amp; htpasswd=&quot;python $(pwd)/htpasswd.py&quot;
		fi
	fi
	[ -z &quot;$htpasswd&quot; ] &amp;&amp; errorExit &quot;Could not find htpasswd&quot;
}

verifyWebServerVars() {
	[ -z &quot;$WWW_PEMFILE&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_PEMFILE&quot;
	[ -z &quot;$WWW_PASSWORD_FILE&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_PASSWORD_FILE&quot;
	[ -z &quot;$WWW_ROOT&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_ROOT&quot;
	[ -z &quot;$WWW_USER&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_USER&quot;
	[ -z &quot;$WWW_GROUP&quot; ] &amp;&amp; errorExit &quot;You have not initialized WWW_GROUP&quot;
}

initializeWwwRootVar() {
	WWW_ROOT=${WWW_ROOT:-/var/rutorrent}
}

createWebServerUserGroup() {
	verifyWebServerVars
	if ! grep -qE &quot;^$WWW_GROUP:&quot; /etc/group; then
		groupadd -r $WWW_GROUP 2&gt;/dev/null || groupadd $WWW_GROUP || errorExit &quot;Could not create web server group.&quot;
	fi
	if ! grep -qE &quot;^$WWW_USER:&quot; /etc/passwd; then
		local useradd=&quot;useradd -d $WWW_ROOT -g $WWW_GROUP -s /bin/sh&quot;
		$useradd -M -r $WWW_USER 2&gt;/dev/null || $useradd $WWW_USER || errorExit &quot;Could not create web server user.&quot;
	fi
}

resetAuthPasswordFilePermissions() {
	[ -n &quot;$WWW_USER&quot; ] || errorExit &quot;WWW_USER not initialized&quot;
	[ -n &quot;$WWW_GROUP&quot; ] || errorExit &quot;WWW_GROUP not initialized&quot;
	chmod 0400 &quot;$WWW_PASSWORD_FILE&quot;*
	chown $WWW_USER:$WWW_GROUP &quot;$WWW_PASSWORD_FILE&quot;*
}

createAuthPasswordFile() {
	verifyWebServerVars
	: &gt; &quot;$WWW_PASSWORD_FILE&quot;
	resetAuthPasswordFilePermissions
}

# Some web servers (eg. nginx) can&#39;t allow just ONE user access to a certain
# location. To fix that, create one password file per user.
createOnePasswordFilePerUser() {
	for packedUser in $USERS; do
		extractPackedUser $packedUser
		grep &quot;^$webUser:&quot; &quot;$WWW_PASSWORD_FILE&quot; &gt; &quot;${WWW_PASSWORD_FILE}_$webUser&quot;
	done
	resetAuthPasswordFilePermissions
}

updatePhpTimezone() {
	if [ ! -f &quot;$WWW_PHP_INI&quot; ]; then
		echo &quot;${CWARNING}Could not find php.ini file: $WWW_PHP_INI$CEND&quot;
		return
	fi
	[ -z &quot;$USER_TIMEZONE&quot; ] &amp;&amp; return

	local zws=&quot;[ 	]*&quot;
	local newLine=&quot;date.timezone = $USER_TIMEZONE&quot;
	if grep -qE &quot;^${zws}date\\.timezone[ 	=]&quot; &quot;$WWW_PHP_INI&quot;; then
		return
	elif grep -qE &quot;^${zws}[;#]${zws}date\\.timezone[ 	=]&quot; &quot;$WWW_PHP_INI&quot;; then
		sed_i &quot;s!^${zws}[;#]${zws}date\\.timezone[ 	=].*\$!$newLine!&quot; &quot;$WWW_PHP_INI&quot;
	else
		cat &gt;&gt; &quot;$WWW_PHP_INI&quot; &lt;&lt; EOF
[Date]
$newLine
EOF
	fi
}

doDetectTimeZone() {
	echo &quot;${CMSG}Detecting timezone...$CEND&quot;
	detectTimeZone
	if [ -n &quot;$USER_TIMEZONE&quot; ]; then
		echo &quot;${CMSG}Timezone: $USER_TIMEZONE$CEND&quot;

		updatePhpTimezone
	else
		echo &quot;${CWARNING}Could not detect timezone!$CEND&quot;
	fi
}

webServerCommonInitialization() {
	mkdir -p $WWW_ROOT
	doDetectTimeZone
	createSelfSignedCertFile &quot;$WWW_PEMFILE&quot;
	createAuthPasswordFile
}

resetWebServerPermissions() {
	verifyWebServerVars
	chown -R $WWW_USER:$WWW_GROUP $WWW_ROOT || errorExit &quot;Could not set web server as owner of $WWW_ROOT&quot;
}

createPhpcgiSocket() {
	PHPCGI_SOCKET_DIR=/etc/phpcgi
	PHPCGI_SOCKET_FILE=&quot;$PHPCGI_SOCKET_DIR/php-cgi.socket&quot;
	mkdir -p &quot;$PHPCGI_SOCKET_DIR&quot;
	chown $WWW_USER:$WWW_GROUP &quot;$PHPCGI_SOCKET_DIR&quot;
	chmod 0770 &quot;$PHPCGI_SOCKET_DIR&quot;
}

verifyApacheServerVars() {
	verifyWebServerVars
	[ -z &quot;$APACHE_SITE_FILE&quot; ] &amp;&amp; errorExit &quot;You have not initialized APACHE_SITE_FILE&quot;
}

apacheCreateApxs2Symlink() {
	# The makefile uses apxs2, so make a symlink
	if ! isProgramInstalled apxs2; then
		local apxs=$(which apxs 2&gt;/dev/null) &amp;&amp; ln -s &quot;$apxs&quot; &quot;${apxs}2&quot;
	fi
}

initializeApacheVars() {
	local apacheUser=&quot;$1&quot;
	local apacheGroup=&quot;$2&quot;
	local apacheSitesDir=&quot;$3&quot;

	[ -n &quot;$apacheUser&quot; ] || errorExit &quot;Invalid apache user: $apacheUser&quot;
	[ -n &quot;$apacheGroup&quot; ] || errorExit &quot;Invalid apache group: $apacheGroup&quot;
	[ -d &quot;$apacheSitesDir&quot; ] || errorExit &quot;Invalid apache sites dir: $apacheSitesDir&quot;
	[ -d &quot;$APACHE_DIR&quot; ] || errorExit &quot;Invalid apache dir: $APACHE_DIR&quot;

	APACHE_SITE_NAME=${APACHE_SITE_NAME:-rutorrent.conf}
	APACHE_SITE_FILE=$apacheSitesDir/$APACHE_SITE_NAME
	initializeWwwRootVar
	WWW_PASSWORD_FILE=$APACHE_DIR/rutorrent_passwd
	WWW_PEMFILE=$APACHE_DIR/rutorrent.pem
	WWW_USER=&quot;$apacheUser&quot;
	WWW_GROUP=&quot;$apacheGroup&quot;
}

apacheGetRpcLocationDirectives() {
	if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		local i=1
		for packedUser in $USERS; do
			extractPackedUser $packedUser
			local rpcMount=&quot;$(getUserRpcMount $i)&quot;
			cat &lt;&lt; EOF
	&lt;Location &quot;$rpcMount&quot;&gt;
		AuthType Basic
		AuthName &quot;$RUTORRENT_SITE_REALM&quot;
		AuthUserFile &quot;$WWW_PASSWORD_FILE&quot;
		Require user $webUser
	&lt;/Location&gt;
EOF
			i=$(expr $i + 1)
		done
	fi
}

apacheGetVirtualHost() {
	local port=$1
	local ssl=$2
	cat &lt;&lt; EOF
&lt;VirtualHost *:$port&gt;
$(if [ &quot;$ssl&quot; = y ]; then
	echo &quot;	SSLEngine On&quot;
	echo &quot;	SSLCertificateFile $WWW_PEMFILE&quot;
fi)
	ServerAdmin admin@rutorrent
	ServerName localhost
	DocumentRoot $WWW_ROOT

	&lt;Directory /&gt;
		AllowOverride None
		Order deny,allow
		Deny from all
	&lt;/Directory&gt;
	&lt;Location /&gt;
		AuthType Basic
		AuthName &quot;$RUTORRENT_SITE_REALM&quot;
		AuthUserFile &quot;$WWW_PASSWORD_FILE&quot;
		Require valid-user
		Order allow,deny
		Allow from all
	&lt;/Location&gt;
	&lt;Location ~ &quot;^/rutorrent/(conf|share)&quot;&gt;
		Order deny,allow
		Deny from all
	&lt;/Location&gt;
	&lt;Location ~ &quot;/\\\\.svn&quot;&gt;
		Order deny,allow
		Deny from all
	&lt;/Location&gt;
$(apacheGetRpcLocationDirectives)
&lt;/VirtualHost&gt;
EOF
}

apacheWriteSiteFile() {
	verifyApacheServerVars
	cat &gt; &quot;$APACHE_SITE_FILE&quot; &lt;&lt; EOF
ServerName localhost

$(apacheGetVirtualHost $HTTP_PORT n)
$(apacheGetVirtualHost $HTTPS_PORT y)
EOF

	if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		local i=1
		local lp=; isWebServerRpcModule || lp=&#39;#&#39;
		for packedUser in $USERS; do
			extractPackedUser $packedUser
			local rpcMount=&quot;$(getUserRpcMount $i)&quot;
			echo &quot;${lp}SCGIMount $rpcMount $SCGI_HOST:$scgiPort&quot; &gt;&gt; &quot;$APACHE_SITE_FILE&quot;

			i=$(expr $i + 1)
		done
	fi
}

apacheCommonInitialization() {
	local buildTools=&quot;$1&quot;
	local modulesDir=&quot;$2&quot;

	webServerCommonInitialization
	apacheWriteSiteFile

	if [ -n &quot;$APACHE_SCGI_FILE&quot; ] &amp;&amp; [ ! -f &quot;$APACHE_SCGI_FILE&quot; ]; then
		installBuildTools
		PACKAGES=&quot;$buildTools&quot;
		installPackages
		apacheCreateApxs2Symlink

		# Compiling mod_scgi will fail unless we remove this warning-as-error flag
		local configVarsFile=&quot;$APACHE_DIR/modules/build/config_vars.mk&quot;
		[ -f &quot;$configVarsFile&quot; ] &amp;&amp; sed_i &#39;s/-Werror=format-security//g&#39; &quot;$configVarsFile&quot;

		installModScgi &quot;$APACHE_SCGI_FILE&quot; &quot;$modulesDir&quot;
	fi
}

installCommonWebServerStuff_mandriva() {
	# Also add some extra tools for ruTorrent and some of its plugins
	PACKAGES=&quot;php-cli gzip curl openssl logrotate&quot;
	installPackages
	PACKAGE=&quot;unrar&quot;
	installPackages
	PACKAGES=&quot;php-geoip&quot;
	installPackages
}

# Used by Mandriva, Unity Linux, and PCLinuxOS
installApache_mandriva() {
	installCommonWebServerStuff_mandriva
	PACKAGES=&quot;apache-mpm-prefork apache-mod_ssl apache-mod_php&quot;
	installPackages

	WWW_PHP_INI=/etc/php.ini
	APACHE_DIR=/etc/httpd
	local APACHE_CONF_D=$APACHE_DIR/conf.d
	local APACHE_SITES_DIR=$APACHE_DIR/conf/vhosts.d
	APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf
	initializeApacheVars apache apache &quot;$APACHE_SITES_DIR&quot;
	apacheCommonInitialization &quot;libopenssl-devel apache-devel&quot; $APACHE_DIR/modules

	for file in 00_default_vhosts.conf 01_default_ssl_vhost.conf; do
		[ -f &quot;$APACHE_SITES_DIR/$file&quot; ] &amp;&amp; mv -f &quot;$APACHE_SITES_DIR/$file&quot; &quot;$APACHE_SITES_DIR/$file-bak&quot;
	done

	resetWebServerPermissions
	chkconfig httpd on
	service httpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
}

installCommonWebServerStuff_gentoo() {
	# Also add some extra tools for ruTorrent and some of its plugins
	PACKAGES=&quot;dev-lang/php logrotate&quot;
	addProgram gzip app-arch/gzip
	addProgram curl net-misc/curl
	addProgram openssl dev-libs/openssl
	addProgram unrar app-arch/unrar
	installPackages

	ACCEPT_LICENSE=MaxMind
	export ACCEPT_LICENSE
	PACKAGES=&quot;dev-php5/pecl-geoip&quot;
	installPackages
	unset ACCEPT_LICENSE
}

installApache_gentoo() {
	installCommonWebServerStuff_gentoo
	PACKAGES=&quot;www-servers/apache app-admin/apache-tools&quot;
	installPackages
	PACKAGES=&quot;www-apache/mod_scgi&quot;
	installPackages

	WWW_PHP_INI=$(ls /etc/php/apache2-php5*/php.ini | tail -n1)
	[ -f &quot;$WWW_PHP_INI&quot; ] || errorExit &quot;Could not find Apache php.ini file&quot;
	APACHE_DIR=/etc/apache2
	local APACHE_CONF=$APACHE_DIR/httpd.conf
	local APACHE_SITES_DIR=$APACHE_DIR/vhosts.d
	local SERVER_ROOT=$(grep -E ^ServerRoot $APACHE_CONF | head -n1 | sed -e &#39;s!^.*[ 	][^/]*\(/[^&quot;]*\).*!\1!&#39;)
	APACHE_SCGI_FILE=&quot;$APACHE_DIR/modules.d/scgi.conf&quot;
	[ -d &quot;$SERVER_ROOT&quot; ] || errorExit &quot;Apache server root dir does not exist: $SERVER_ROOT&quot;
	initializeApacheVars apache apache &quot;$APACHE_SITES_DIR&quot;
	apacheCommonInitialization &quot;&quot; $SERVER_ROOT/modules

	for file in 00_default_ssl_vhost.conf 00_default_vhost.conf; do
		[ -f &quot;$APACHE_SITES_DIR/$file&quot; ] &amp;&amp; mv -f &quot;$APACHE_SITES_DIR/$file&quot; &quot;$APACHE_SITES_DIR/$file-bak&quot;
	done

	appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS &quot;-D SCGI&quot;
	appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS &quot;-D PHP5&quot;
	appendFileStringVar /etc/conf.d/apache2 APACHE2_OPTS &quot;-D SSL&quot;
	cat &gt;&gt; $APACHE_SITE_FILE &lt;&lt; EOF
Listen $HTTP_PORT
Listen $HTTPS_PORT
EOF

	resetWebServerPermissions
	rc-update add apache2 default
	osHandler_$os restart_$INSTALL_WEB_SERVER
}

nginxGetRpcMounts() {
	if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		local i=1
		local lp=; isWebServerRpcModule || lp=&#39;#&#39;
		for packedUser in $USERS; do
			extractPackedUser $packedUser
			getUserScgiSocketPath &quot;$osUser&quot;
			local rpcMount=&quot;$(getUserRpcMount $i)&quot;

			cat &lt;&lt; EOF
$lp		location ~ ^$rpcMount\$ {
$lp			include scgi_params;
$lp			scgi_pass unix:$scgiSocketPath;
$lp			auth_basic &quot;$RUTORRENT_SITE_REALM&quot;;
$lp			auth_basic_user_file &quot;${WWW_PASSWORD_FILE}_$webUser&quot;;
$lp		}
EOF

			i=$(expr $i + 1)
		done
	fi
}

nginxGetServerSection() {
	local port=$1
	local ssl=$2

	cat &lt;&lt; EOF
	server {
		listen $port;
		server_name localhost;
		auth_basic &quot;$RUTORRENT_SITE_REALM&quot;;
		auth_basic_user_file &quot;$WWW_PASSWORD_FILE&quot;;

$(if [ &quot;$ssl&quot; = y ]; then
	cat &lt;&lt; EOF2
		ssl on;
		ssl_certificate $WWW_PEMFILE;
		ssl_certificate_key $WWW_PEMFILE;
EOF2
fi)

		location ~ ^/rutorrent/(?:share|conf) {
			deny all;
		}

		location ~ /\.ht {
			deny all;
		}

		location ~ /\.svn {
			deny all;
		}

		location / {
			root $WWW_ROOT;
			index index.php index.html index.htm;
		}

		location ~ \.php$ {
			root &quot;$WWW_ROOT&quot;;
			fastcgi_pass unix:$PHPCGI_SOCKET_FILE;
			fastcgi_index index.php;
			fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
			include fastcgi_params;
		}

$(nginxGetRpcMounts)
	}
EOF
}

nginxWriteConfFile() {
	getNumCpus
	cat &gt; $NGINX_CONF &lt;&lt; EOF
worker_processes $NUMCPUS;
user $WWW_USER $WWW_GROUP;
events {
	worker_connections 1024;
}

http {
	include mime.types;
	default_type application/octet-stream;
	sendfile on;
	keepalive_timeout 65;

	# I have to set min length to 0 and http version to 1.0 or it won&#39;t compress
	# the XML-RPC (SCGI) responses. Those responses can be quite large if you&#39;re
	# using many torrent files.
	gzip on;
	gzip_min_length 0;
	gzip_http_version 1.0;
	gzip_types text/plain text/xml application/xml application/json text/css application/x-javascript text/javascript application/javascript;

$(nginxGetServerSection $HTTP_PORT n)
$(nginxGetServerSection $HTTPS_PORT y)
}
EOF
	[ $? -eq 0 ] || errorExit &quot;Could not write to file $NGINX_CONF&quot;
}

buildNginx() {
	buildStart
	PREFIX=$NGINX_DIR
	NGINX_BIN=$PREFIX/sbin/nginx
	NGINX_CONF=$PREFIX/conf/nginx.conf
	NGINX_PID_FILE=$PREFIX/nginx.pid
	NGINX_ACCESS_LOG=$PREFIX/logs/access.log
	NGINX_ERROR_LOG=$PREFIX/logs/error.log
	local configureFlags=&quot;\
				--prefix=$PREFIX \
				--sbin-path=$NGINX_BIN \
				--conf-path=$NGINX_CONF \
				--pid-path=$NGINX_PID_FILE \
				--lock-path=$PREFIX/logs/nginx.lock \
				--error-log-path=$NGINX_ERROR_LOG \
				--http-log-path=$NGINX_ACCESS_LOG \
				--user=$WWW_USER \
				--group=$WWW_GROUP \
				--with-http_ssl_module&quot;
	export CFLAGS=&quot;$NGINX_CFLAGS&quot;
	downloadAndBuild &quot;nginx&quot; &quot;$NGINX_URL&quot; &quot;$NGINX_NAME&quot; &quot;$configureFlags&quot; patchNginx
	unset CFLAGS
	buildEnd
}

patchNginx() {
	# Get rid of the -Werror flag for gcc 4.6.0
	sed_i &quot;s!-Werror[a-zA-Z0-9=-]*!!&quot; &quot;auto/cc/gcc&quot;
}

installNginx() {
	SCGI_USE_UNIX_DOMAIN_SOCKET=y
	CREATE_ONE_PASSWORD_FILE_PER_USER=y
	installBuildTools
	osHandler_$os preNginxInstall
	installUnrar

	NGINX_DIR=/usr/local/nginx
	initializeWwwRootVar
	WWW_PASSWORD_FILE=$NGINX_DIR/rutorrent_passwd
	WWW_PEMFILE=$NGINX_DIR/rutorrent.pem
	WWW_USER=${WWW_USER:-nginx}
	WWW_GROUP=${WWW_GROUP:-nginx}

	detectPhpCgi
	createWebServerUserGroup
	createPhpcgiSocket

	buildNginx
	webServerCommonInitialization
	nginxWriteConfFile

	addLogrotateConfig nginx \
			&quot;$NGINX_ACCESS_LOG $NGINX_ERROR_LOG&quot; \
			&quot;[ -f \&quot;$NGINX_PID_FILE\&quot; ] &amp;&amp; kill -USR1 \$(cat \&quot;$NGINX_PID_FILE\&quot;) &gt;/dev/null 2&gt;&amp;1; true&quot;

	resetWebServerPermissions
	osHandler_$os installPhpCgiService
	osHandler_$os installNginxService
}

preNginxInstall_gentoo() {
	installCommonWebServerStuff_gentoo
	PACKAGES=&quot;libpcre openssl zlib php&quot;
	installPackages
	WWW_PHP_INI=$(ls /etc/php/cgi-php5*/php.ini | tail -n1)
	[ -f &quot;$WWW_PHP_INI&quot; ] || errorExit &quot;Could not find php-cgi php.ini file&quot;
}

preLighttpdInstall_gentoo() {
	preNginxInstall_gentoo
}

lighttpdGetRpcRequire() {
	if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		local i=1
		for packedUser in $USERS; do
			extractPackedUser $packedUser
			local rpcMount=&quot;$(getUserRpcMount $i)&quot;

			cat &lt;&lt; EOF
	&quot;$rpcMount&quot; =&gt; (
		&quot;method&quot; =&gt; &quot;basic&quot;,
		&quot;realm&quot; =&gt; &quot;$RUTORRENT_SITE_REALM&quot;,
		&quot;require&quot; =&gt; &quot;user=$webUser&quot;,
	),
EOF
			i=$(expr $i + 1)
		done
	fi
}

lighttpdGetScgiServerTable() {
	echo &#39;scgi.server = (&#39;

	if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		local i=1
		local lp=; isWebServerRpcModule || lp=&#39;#&#39;
		for packedUser in $USERS; do
			extractPackedUser $packedUser
			getUserScgiSocketPath &quot;$osUser&quot;
			local rpcMount=&quot;$(getUserRpcMount $i)&quot;

			cat &lt;&lt; EOF
$lp	&quot;$rpcMount&quot; =&gt; (
$lp		(
$lp			&quot;socket&quot; =&gt; &quot;$scgiSocketPath&quot;,
$lp			&quot;check-local&quot; =&gt; &quot;disable&quot;,
$lp			&quot;disable-time&quot; =&gt; 0,
$lp		),
$lp	),
EOF
			i=$(expr $i + 1)
		done
	fi

	echo &#39;)&#39;
}

lighttpdWriteConfFile() {
	cat &gt; $LIGHTTPD_CONF &lt;&lt; EOF
server.follow-symlink = &quot;disable&quot;
server.max-connections = 512
server.max-fds = 1024
server.max-keep-alive-idle = 15
dir-listing.activate = &quot;disable&quot;
server.pid-file = &quot;$LIGHTTPD_PID_FILE&quot;
server.errorlog = &quot;$LIGHTTPD_ERROR_LOG&quot;
accesslog.filename = &quot;$LIGHTTPD_ACCESS_LOG&quot;

$(if [ $(uname -s) = Linux ]; then
	echo &#39;server.event-handler = &quot;linux-sysepoll&quot;&#39;
	echo &#39;server.network-backend = &quot;linux-sendfile&quot;&#39;
fi)

server.username = &quot;$WWW_USER&quot;
server.groupname = &quot;$WWW_GROUP&quot;

server.modules = (
#	&quot;mod_rewrite&quot;,
#	&quot;mod_redirect&quot;,
#	&quot;mod_alias&quot;,
	&quot;mod_access&quot;,
	&quot;mod_auth&quot;,
#	&quot;mod_status&quot;,
#	&quot;mod_simple_vhost&quot;,
#	&quot;mod_evhost&quot;,
#	&quot;mod_userdir&quot;,
#	&quot;mod_secdownload&quot;,
	&quot;mod_fastcgi&quot;,
#	&quot;mod_proxy&quot;,
#	&quot;mod_cgi&quot;,
	&quot;mod_scgi&quot;,
#	&quot;mod_ssi&quot;,
#	&quot;mod_compress&quot;,
#	&quot;mod_usertrack&quot;,
#	&quot;mod_expire&quot;,
#	&quot;mod_rrdtool&quot;,
	&quot;mod_accesslog&quot;,
)

fastcgi.server = (
	&quot;.php&quot; =&gt; (
		(
			&quot;socket&quot; =&gt; &quot;$PHPCGI_SOCKET_FILE&quot;,
		),
	),
)

index-file.names = ( &quot;index.php&quot;, &quot;index.html&quot;, &quot;index.htm&quot; )
static-file.exclude-extensions = ( &quot;.fcgi&quot;, &quot;.php&quot;, &quot;.rb&quot;, &quot;~&quot;, &quot;.inc&quot; )

mimetype.assign = (
	&quot;.html&quot;		=&gt; &quot;text/html&quot;,
	&quot;.htm&quot;		=&gt; &quot;text/html&quot;,
	&quot;.txt&quot;		=&gt; &quot;text/plain&quot;,
	&quot;.csv&quot;		=&gt; &quot;text/plain&quot;,
	&quot;.ini&quot;		=&gt; &quot;text/plain&quot;,
	&quot;.jpg&quot;		=&gt; &quot;image/jpeg&quot;,
	&quot;.jpeg&quot;		=&gt; &quot;image/jpeg&quot;,
	&quot;.gif&quot;		=&gt; &quot;image/gif&quot;,
	&quot;.png&quot;		=&gt; &quot;image/png&quot;,
	&quot;.bmp&quot;		=&gt; &quot;image/bmp&quot;,
	&quot;.css&quot;		=&gt; &quot;text/css&quot;,
	&quot;.js&quot;		=&gt; &quot;application/javascript&quot;,
	&quot;.ico&quot;		=&gt; &quot;image/x-icon&quot;,
	&quot;.json&quot;		=&gt; &quot;application/json&quot;,
	&quot;.torrent&quot;	=&gt; &quot;application/x-bittorrent&quot;,
	&quot;.pdf&quot;		=&gt; &quot;application/pdf&quot;,
	&quot;.bz2&quot;		=&gt; &quot;application/x-bzip2&quot;,
	&quot;.gz&quot;		=&gt; &quot;application/x-gzip&quot;,
	&quot;.tar.gz&quot;	=&gt; &quot;application/x-tgz&quot;,
	&quot;.tar&quot;		=&gt; &quot;application/x-tar&quot;,
	&quot;.tar.bz2&quot;	=&gt; &quot;application/x-bzip-compressed-tar&quot;,
	&quot;.tbz&quot;		=&gt; &quot;application/x-bzip-compressed-tar&quot;,
	&quot;.tgz&quot;		=&gt; &quot;application/x-tgz&quot;,
	&quot;.zip&quot;		=&gt; &quot;application/zip&quot;,
	&quot;.mp3&quot;		=&gt; &quot;audio/mpeg&quot;,
	&quot;.flac&quot;		=&gt; &quot;audio/x-flac&quot;,
	&quot;.m3u&quot;		=&gt; &quot;audio/x-mpegurl&quot;,
	&quot;.wma&quot;		=&gt; &quot;audio/x-ms-wma&quot;,
	&quot;.wax&quot;		=&gt; &quot;audio/x-ms-wax&quot;,
	&quot;.ogg&quot;		=&gt; &quot;audio/ogg&quot;,
	&quot;.wav&quot;		=&gt; &quot;audio/x-wav&quot;,
	&quot;.dtd&quot;		=&gt; &quot;text/xml&quot;,
	&quot;.xml&quot;		=&gt; &quot;text/xml&quot;,
	&quot;.mpeg&quot;		=&gt; &quot;video/mpeg&quot;,
	&quot;.mpg&quot;		=&gt; &quot;video/mpeg&quot;,
	&quot;.mp4&quot;		=&gt; &quot;video/mp4&quot;,
	&quot;.wmv&quot;		=&gt; &quot;video/x-ms-wmv&quot;,
	&quot;.avi&quot;		=&gt; &quot;video/x-msvideo&quot;,
)

server.document-root = &quot;$WWW_ROOT&quot;
server.port = $HTTP_PORT

\$SERVER[&quot;socket&quot;] == &quot;:$HTTPS_PORT&quot; {
	ssl.engine = &quot;enable&quot;
	ssl.pemfile = &quot;$WWW_PEMFILE&quot;
}

url.access-deny = (&quot;.htaccess&quot;)
\$HTTP[&quot;url&quot;] =~ &quot;^/rutorrent/(?:share|conf)&quot; {
	url.access-deny = (&quot;&quot;)
}
\$HTTP[&quot;url&quot;] =~ &quot;/\\.svn&quot; {
	url.access-deny = (&quot;&quot;)
}

auth.backend = &quot;htpasswd&quot;
auth.backend.htpasswd.userfile = &quot;$WWW_PASSWORD_FILE&quot;
auth.require = (
$(lighttpdGetRpcRequire)
	&quot;/&quot; =&gt; (
		&quot;method&quot; =&gt; &quot;basic&quot;,
		&quot;realm&quot; =&gt; &quot;$RUTORRENT_SITE_REALM&quot;,
		&quot;require&quot; =&gt; &quot;valid-user&quot;,
	),
)

$(lighttpdGetScgiServerTable)
EOF
	[ $? -eq 0 ] || errorExit &quot;Could not write to file $LIGHTTPD_CONF&quot;
}

buildLighttpd() {
	buildStart
	PREFIX=$LIGHTTPD_DIR
	LIGHTTPD_BIN=$PREFIX/sbin/lighttpd
	LIGHTTPD_CONF=$PREFIX/lighttpd.conf

	# The log dir will be set to owner lighttpd since it&#39;s started as non-root.
	# Put the pid file there so it can write to it.
	LIGHTTPD_LOG_DIR=$PREFIX/logs
	LIGHTTPD_PID_FILE=$LIGHTTPD_LOG_DIR/lighttpd.pid
	LIGHTTPD_ERROR_LOG=$LIGHTTPD_LOG_DIR/error.log
	LIGHTTPD_ACCESS_LOG=$LIGHTTPD_LOG_DIR/access.log

	local configureFlags=&quot;\
				--prefix=$PREFIX \
				--with-openssl \
				--with-pcre \
				--with-zlib \
				--without-bzip2&quot;
	downloadAndBuild &quot;lighttpd&quot; &quot;$LIGHTTPD_URL&quot; &quot;$LIGHTTPD_NAME&quot; &quot;$configureFlags&quot;
	buildEnd
}

installLighttpd() {
	SCGI_USE_UNIX_DOMAIN_SOCKET=y
	installBuildTools
	osHandler_$os preLighttpdInstall
	installUnrar

	LIGHTTPD_DIR=/usr/local/lighttpd
	initializeWwwRootVar
	WWW_PASSWORD_FILE=$LIGHTTPD_DIR/rutorrent_passwd
	WWW_PEMFILE=$LIGHTTPD_DIR/rutorrent.pem
	WWW_USER=${WWW_USER:-lighttpd}
	WWW_GROUP=${WWW_GROUP:-lighttpd}

	detectPhpCgi
	createWebServerUserGroup
	createPhpcgiSocket

	buildLighttpd
	webServerCommonInitialization
	lighttpdWriteConfFile

	addLogrotateConfig lighttpd \
			&quot;$LIGHTTPD_ACCESS_LOG $LIGHTTPD_ERROR_LOG&quot; \
			&quot;[ -f \&quot;$LIGHTTPD_PID_FILE\&quot; ] &amp;&amp; kill -HUP \$(cat \&quot;$LIGHTTPD_PID_FILE\&quot;) &gt;/dev/null 2&gt;&amp;1; true&quot;

	mkdir -p &quot;$LIGHTTPD_LOG_DIR&quot;
	chown -R $WWW_USER:$WWW_GROUP &quot;$LIGHTTPD_LOG_DIR&quot;

	resetWebServerPermissions
	osHandler_$os installPhpCgiService
	osHandler_$os installLighttpdService
}

# Add $name=$value to the file, or modify an existing line if present in the file
setVsftpdValue() {
	local confFile=&quot;$1&quot;
	local name=&quot;$2&quot;
	local value=&quot;$3&quot;
	local newLine=&quot;$name=$value&quot;

	sed_i &quot;s!^[ 	]*$name[ 	=:].*\$!$newLine!&quot; &quot;$confFile&quot;
	grep -qE &quot;^$newLine$&quot; &quot;$confFile&quot; || echo &quot;$newLine&quot; &gt;&gt; &quot;$confFile&quot;
}

# Same as setVsftpdValue but makes sure the option exists
setVsftpdValue2() {
	local confFile=&quot;$1&quot;
	local name=&quot;$2&quot;
	local value=&quot;$3&quot;

	[ -z &quot;$VSFTPD_PATH&quot; ] &amp;&amp; return
	grep -q &quot;$name&quot; &quot;$VSFTPD_PATH&quot; &amp;&amp; setVsftpdValue &quot;$confFile&quot; &quot;$name&quot; &quot;$value&quot;
}

updateVsftpdConf() {
	local confFile=&quot;$1&quot;
	touch &quot;$confFile&quot;

	VSFTPD_PATH=$(which vsftpd 2&gt;/dev/null)

	setVsftpdValue &quot;$confFile&quot; anonymous_enable NO
	setVsftpdValue &quot;$confFile&quot; dirlist_enable YES
	setVsftpdValue &quot;$confFile&quot; download_enable YES
	setVsftpdValue &quot;$confFile&quot; guest_enable NO
	setVsftpdValue &quot;$confFile&quot; listen YES
	setVsftpdValue &quot;$confFile&quot; listen_ipv6 NO
	setVsftpdValue &quot;$confFile&quot; local_enable YES
	setVsftpdValue &quot;$confFile&quot; local_umask $DEFAULT_UMASK
	setVsftpdValue &quot;$confFile&quot; max_per_ip 0
	setVsftpdValue &quot;$confFile&quot; pasv_enable YES
	setVsftpdValue &quot;$confFile&quot; port_enable YES
	setVsftpdValue &quot;$confFile&quot; pasv_promiscuous NO
	setVsftpdValue &quot;$confFile&quot; port_promiscuous NO
	setVsftpdValue &quot;$confFile&quot; pasv_min_port 0
	setVsftpdValue &quot;$confFile&quot; pasv_max_port 0
	setVsftpdValue &quot;$confFile&quot; write_enable YES

	if [ &quot;$USE_ENCRYPTED_FTP&quot; = y ]; then
		local pemfile=/etc/vsftpd.pem
		createSelfSignedCertFile &quot;$pemfile&quot;

		FTP_SERVER_TYPE=&quot;FTPES - Encrypted (FTP over explicit TLS/SSL)&quot;
		FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTPES}
		setVsftpdValue &quot;$confFile&quot; listen_port $FTP_PORT
		setVsftpdValue &quot;$confFile&quot; ssl_enable YES

		setVsftpdValue &quot;$confFile&quot; allow_anon_ssl NO
		setVsftpdValue &quot;$confFile&quot; force_local_data_ssl YES
		setVsftpdValue &quot;$confFile&quot; force_local_logins_ssl YES
		setVsftpdValue &quot;$confFile&quot; ssl_sslv2 NO
		setVsftpdValue &quot;$confFile&quot; ssl_sslv3 NO
		setVsftpdValue &quot;$confFile&quot; ssl_tlsv1 YES
		setVsftpdValue &quot;$confFile&quot; rsa_cert_file &quot;$pemfile&quot;

		setVsftpdValue2 &quot;$confFile&quot; implicit_ssl NO
		setVsftpdValue2 &quot;$confFile&quot; require_cert NO
		setVsftpdValue2 &quot;$confFile&quot; require_ssl_reuse NO
		setVsftpdValue2 &quot;$confFile&quot; ssl_request_cert YES
		setVsftpdValue2 &quot;$confFile&quot; strict_ssl_read_eof NO
		setVsftpdValue2 &quot;$confFile&quot; strict_ssl_write_shutdown NO
		setVsftpdValue2 &quot;$confFile&quot; validate_cert NO
	else
		FTP_SERVER_TYPE=&quot;FTP - Non-encrypted&quot;
		FTP_PORT=${FTP_PORT:-$DEFAULT_PORT_FTP}
		setVsftpdValue &quot;$confFile&quot; listen_port $FTP_PORT
		setVsftpdValue &quot;$confFile&quot; ssl_enable NO
	fi

	# The private key is in rsa_cert_file
	sed_i &#39;g/rsa_private_key_file/d&#39; &quot;$confFile&quot;
}

installVsftpd_chkconfig() {
	local vsftpdConf=&quot;$1&quot;
	installProgram vsftpd
	[ -f &quot;$vsftpdConf&quot; ] || errorExit &quot;Invalid vsftpd.conf file: $vsftpdConf&quot;
	updateVsftpdConf &quot;$vsftpdConf&quot;
	chkconfig vsftpd on
	if ! service vsftpd restart; then
		if [ &quot;$SELINUX_ENABLED&quot; = y ]; then
			errorExit &quot;Could not restart vsftpd. SELinux could be the reason.&quot;
		else
			errorExit &quot;Could not restart vsftpd&quot;
		fi
	fi
}

installVsftpd_gentoo() {
	installProgram net-ftp/vsftpd
	local vsftpdConf=/etc/vsftpd/vsftpd.conf
	if ! [ -f $vsftpdConf ]; then
		touch $vsftpdConf
		[ -f $vsftpdConf.example ] &amp;&amp; cp $vsftpdConf.example $vsftpdConf
	fi
	updateVsftpdConf $vsftpdConf
	rc-update add vsftpd default
	/etc/init.d/vsftpd restart
}

installService_chkconfig1() {
	CHKCONFIG_SERVICE_NAME=$1
	CHKCONFIG_SERVICE_FILE=/etc/init.d/$CHKCONFIG_SERVICE_NAME
	CHKCONFIG_LOCK_FILE=/var/lock/subsys/$CHKCONFIG_SERVICE_NAME
}

installService_chkconfig2() {
	chmod +x &quot;$CHKCONFIG_SERVICE_FILE&quot; || errorExit &quot;Could not set +x bit, file $CHKCONFIG_SERVICE_FILE.&quot;
	chkconfig --add $CHKCONFIG_SERVICE_NAME || errorExit &quot;Could not install service $CHKCONFIG_SERVICE_FILE. Run this script as root.&quot;
	service $CHKCONFIG_SERVICE_NAME restart
}

getChkconfigScriptContents() {
	local desc=&quot;$1&quot;
	cat &lt;&lt; EOF
# chkconfig: 2345 85 15
# description: $desc
EOF
}

getLsbStartupScriptContents() {
	local startupName=&quot;$1&quot;
	local desc=&quot;$2&quot;
	cat &lt;&lt; EOF
### BEGIN INIT INFO
# Provides:          $startupName
# Required-Start:    \$local_fs \$network \$syslog
# Required-Stop:     \$local_fs \$syslog
# Default-Start:     $LSB_DEFAULT_START
# Default-Stop:      $LSB_DEFAULT_STOP
# Short-Description: $desc
# Description:       $desc
### END INIT INFO
EOF
}

# You must define v_{startIt,stopIt,restartIt,showStatus} and isStarted funcs
getLsbStartupFooter() {
	cat &lt;&lt; EOF
resetPath	# Some include files may have reset it
LOCKFILE=$1
updateLock() {
	[ -z &quot;\$LOCKFILE&quot; ] &amp;&amp; return
	if isStarted; then
		touch \$LOCKFILE
	else
		rm -f \$LOCKFILE
	fi
}

RETVAL=0
case \$1 in
	start)
		v_startIt
		;;
	stop)
		v_stopIt
		;;
	force-reload|restart)
		v_restartIt
		;;
	try-restart)
		isStarted &amp;&amp; v_restartIt
		;;
	status)
		v_showStatus
		;;
	*)
		echo &quot;Usage: \$0 {start|stop|restart|try-restart|force-reload|status}&quot;
		RETVAL=1
		;;
esac

updateLock
exit \$RETVAL
EOF
}

getCommonStartupScriptContents_autodl() {
	local USER=&quot;$1&quot;
	local STARTUPNAME=&quot;$2&quot;
	cat &lt;&lt; EOF
NAME=$STARTUPNAME
USER=$USER
SESSIONNAME=autodl

resetPath() {
	PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\$PATH&quot;
}
resetPath

# Make sure the path is correct, and make sure we&#39;re in the home dir.
USER_INIT=&quot;umask $DEFAULT_UMASK; cd; PATH=\\\$PATH:\$PATH&quot;

# Run user command, ignoring any messages sent to stdout (eg. &#39;No mail.&#39;)
runUserCmd() {
	su - \$USER -c &quot;\$USER_INIT; \$1&quot; &gt;/dev/null &amp;&amp; return 0
	return 1
}

isStarted() {
	su - \$USER -c &quot;\$USER_INIT; screen -ls | grep -qE \\&quot;[ 	][0-9]+\\\\.\$SESSIONNAME[ 	]\\&quot;&quot; &gt;/dev/null &amp;&amp; return 0
	return 1
}

startIt() {
	isStarted &amp;&amp; return 0

	local START_IRSSI=n
	local START_RTORRENT=n
	which irssi &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_IRSSI=y
	which rtorrent &gt; /dev/null 2&gt;&amp;1 &amp;&amp; START_RTORRENT=y

	case \$START_IRSSI\$START_RTORRENT in
		yy)
			runUserCmd &quot;screen -S \$SESSIONNAME -d -t rtorrent -m rtorrent&quot;
			runUserCmd &quot;screen -d -r \$SESSIONNAME -X screen -t irssi irssi&quot;
			;;
		yn)
			runUserCmd &quot;screen -S \$SESSIONNAME -d -t irssi -m irssi&quot;
			;;
		ny)
			runUserCmd &quot;screen -S \$SESSIONNAME -d -t rtorrent -m rtorrent&quot;
			;;
		nn)
			;;
	esac
	return 0
}

stopIt() {
	isStarted || return 0

	runUserCmd &quot;screen -d -r \$SESSIONNAME -p irssi -X stuff \\&quot;/quit
/quit
\\&quot;&quot;
	runUserCmd &quot;screen -d -r \$SESSIONNAME -p rtorrent -X xon&quot;

	for i in 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4; do
		isStarted || break
		sleep 1
	done

	# If it&#39;s still not stopped, kill the whole screen session
	if isStarted; then
		echo -n &quot;Couldn&#39;t stop it. Killing screen session...&quot;
		runUserCmd &quot;screen -d -r \$SESSIONNAME -p rtorrent -X xon&quot;
		sleep 2
		runUserCmd &quot;screen -d -r \$SESSIONNAME -X quit&quot;
		echo &quot;Done.&quot;
	fi

	return 0
}

v_restartIt() {
	v_stopIt
	v_startIt
}

v_showStatus() {
	if isStarted; then
		echo &quot;\$NAME is running.&quot;
	else
		echo &quot;\$NAME is stopped.&quot;
	fi
}
EOF
}

getChkconfigScriptContents_autodl() {
	getChkconfigScriptContents &quot;$AUTODL_STARTUP_DESC&quot;
}

# LSB style script, also supports chkconfig
# $1 = user name
# $2 = service name
getLsbStartupHeader_autodl() {
	local USER=&quot;$1&quot;
	local STARTUPNAME=&quot;$2&quot;
	cat &lt;&lt; EOF
$(getChkconfigScriptContents_autodl)
$(getLsbStartupScriptContents &quot;$STARTUPNAME&quot; &quot;$AUTODL_STARTUP_DESC&quot;)

$(getCommonStartupScriptContents_autodl &quot;$USER&quot; &quot;$STARTUPNAME&quot;)
EOF
}

installService_mandriva() {
	local serviceName=&quot;$1&quot;
	local headerCommand=&quot;$2&quot;
	installService_chkconfig1 $serviceName
	cat &gt; &quot;$CHKCONFIG_SERVICE_FILE&quot; &lt;&lt; EOF
#!/bin/bash
$(eval $headerCommand)

. /etc/rc.d/init.d/functions

v_startIt() {
	gprintf &quot;Starting %s:&quot; &quot;\$NAME&quot;
	startIt &amp;&amp; success &quot;startup&quot; || failure &quot;startup&quot;
	echo
}

v_stopIt() {
	gprintf &quot;Stopping %s:&quot; &quot;\$NAME&quot;
	stopIt &amp;&amp; success &quot;stop&quot; || failure &quot;stop&quot;
	echo
}

$(getLsbStartupFooter &quot;$CHKCONFIG_LOCK_FILE&quot;)
EOF
	[ $? -eq 0 ] || errorExit &quot;Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root.&quot;
	installService_chkconfig2
}

installService_mandriva_autodl() {
	local user=$1
	installService_mandriva autodl_$user &quot;getLsbStartupHeader_autodl \&quot;$user\&quot; \&quot;\$CHKCONFIG_SERVICE_NAME\&quot;&quot;
}

installService_mandriva_phpcgi() {
	installService_mandriva phpcgi getLsbStartupHeader_phpcgi
}

installService_mandriva_nginx() {
	installService_mandriva nginx getLsbStartupHeader_nginx
}

installService_mandriva_lighttpd() {
	installService_mandriva lighttpd getLsbStartupHeader_lighttpd
}

installService_gentoo() {
	local scriptName=&quot;$1&quot;
	local desc=&quot;$2&quot;
	local headerCommand=&quot;$3&quot;
	local serviceFile=&quot;/etc/init.d/$scriptName&quot;

	cat &gt; &quot;$serviceFile&quot; &lt;&lt; EOF
#!/sbin/runscript

name=$scriptName
description=&quot;$desc&quot;

depend() {
	need localmount
	need net
}

$(eval $headerCommand)

start() {
	ebegin &quot;Starting \$name&quot;
	startIt
	eend \$?
}

stop() {
	ebegin &quot;Stopping \$name&quot;
	stopIt
	eend \$?
}

status() {
	if isStarted; then
		einfo &quot;status: started&quot;
		return 0
	else
		einfo &quot;status: stopped&quot;
		return 1
	fi
}
EOF
	[ $? -eq 0 ] || errorExit &quot;Could not write to file $serviceFile. Run this script as root.&quot;
	chmod +x &quot;$serviceFile&quot;
	rc-update add $scriptName default || errorExit &quot;Could not add service $scriptName&quot;
	$serviceFile restart
}

installService_gentoo_autodl() {
	local user=&quot;$1&quot;
	installService_gentoo autodl_$user &quot;$AUTODL_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_autodl \&quot;$user\&quot; \&quot;\$scriptName\&quot;&quot;
}

installService_gentoo_phpcgi() {
	installService_gentoo phpcgi &quot;$PHPCGI_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_phpcgi \&quot;$WWW_USER\&quot; \&quot;$WWW_PHP_CGI\&quot;&quot;
}

installService_gentoo_nginx() {
	installService_gentoo nginx &quot;$NGINX_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_nginx \&quot;$NGINX_BIN\&quot;&quot;
}

installService_gentoo_lighttpd() {
	installService_gentoo lighttpd &quot;$LIGHTTPD_STARTUP_DESC&quot; &quot;getCommonStartupScriptContents_lighttpd \&quot;$LIGHTTPD_BIN\&quot;&quot;
}

installService_bsd_autodl() {
	local user=&quot;$1&quot;
	local scriptName=&quot;$2&quot;
	local file=&quot;$3&quot;

	cat &gt; &quot;$file&quot; &lt;&lt; EOF
#!/bin/sh
# PROVIDE: autodl_$user
# REQUIRE: FILESYSTEMS NETWORKING
# KEYWORD: shutdown

. /etc/rc.subr

name=$scriptName
desc=&quot;$AUTODL_STARTUP_DESC&quot;
start_cmd=v_startIt
stop_cmd=v_stopIt
restart_cmd=v_restartIt
reload_cmd=v_restartIt
status_cmd=v_showStatus
extra_commands=&quot;status&quot;

v_startIt() {
	echo -n &quot;Starting \$NAME&quot;
	startIt &amp;&amp; echo &quot;.&quot; || echo &quot;. ERROR.&quot;
}

v_stopIt() {
	echo -n &quot;Stopping \$NAME...&quot;
	stopIt &amp;&amp; echo &quot;done.&quot; || echo &quot;ERROR.&quot;
}

$(getCommonStartupScriptContents_autodl &quot;$user&quot; &quot;$scriptName&quot;)

load_rc_config \$name
run_rc_command &quot;\$1&quot;
EOF
	[ $? -eq 0 ] || errorExit &quot;Could not write to file $file. Run this script as root.&quot;
	chmod +x &quot;$file&quot;
}

getCommonStartupScriptContents_simpleService() {
	local USER=&quot;$1&quot;
	local BINPATH=&quot;$2&quot;
	local START_CMD=&quot;$3&quot;
	local PID_FILE=&quot;$4&quot;
	cat &lt;&lt; EOF
USER=$USER
BINPATH=&quot;$BINPATH&quot;
NAME=\${BINPATH##*/}
PID_FILE=&quot;$PID_FILE&quot;

resetPath() {
	PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\$PATH&quot;
}
resetPath

getPids() {
	if [ -n &quot;\$PID_FILE&quot; ]; then
		pids=
		[ -f &quot;\$PID_FILE&quot; ] || return
		local the_pids=&quot;\$(cat &quot;\$PID_FILE&quot; 2&gt;/dev/null)&quot;
		for pid in \$the_pids; do
			PS_FORMAT= LINES= COLUMNS= ps ax | grep -qE &quot;^[ 	]*\$pid[ 	]&quot; &amp;&amp; pids=&quot;\$pids \$pid&quot;
		done
		[ -z &quot;\$pids&quot; ] &amp;&amp; rm -f &quot;\$PID_FILE&quot;
	else
		# ps uses the COLUMNS variable... Make sure it&#39;s off so we get the full path.
		pids=\$(PS_FORMAT= LINES= COLUMNS= ps aux | grep -v grep | grep \$BINPATH | awk &#39;{print \$2}&#39;)
	fi
}

isStarted() {
	getPids
	[ -n &quot;\$pids&quot; ] &amp;&amp; return 0
	return 1
}

startIt() {
	isStarted &amp;&amp; return 0

	if [ \$USER = root ]; then
		$START_CMD
	else
		su - \$USER &quot;-c $START_CMD&quot;
	fi
	[ -n &quot;\$PID_FILE&quot; ] &amp;&amp; sleep 2	# Allow it some time to create the pid file
	if ! isStarted; then
		for i in 1 2 3 4 5; do
			sleep 1
			isStarted &amp;&amp; break
		done
		isStarted || return 1
	fi

	return 0
}

stopIt() {
	isStarted || return 0

	kill \$pids 2&gt;/dev/null

	for i in 0 1 2 3 4 5 6 7 8 9; do
		isStarted || break
		sleep 1
	done

	isStarted &amp;&amp; kill -KILL \$pids 2&gt;/dev/null

	return 0
}

v_startIt() {
	startIt
}

v_stopIt() {
	stopIt
}

v_restartIt() {
	v_stopIt
	v_startIt
}

v_showStatus() {
	if isStarted; then
		echo &quot;\$NAME is running.&quot;
	else
		echo &quot;\$NAME is stopped.&quot;
	fi
}
EOF
}

getCommonStartupScriptContents_phpcgi() {
	[ -n &quot;$PHPCGI_SOCKET_FILE&quot; ] || errorExit &quot;PHPCGI_SOCKET_FILE is not initialized&quot;
	getCommonStartupScriptContents_simpleService &quot;$1&quot; &quot;$2&quot; \
		&quot;PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 \$BINPATH -q -b \&quot;$PHPCGI_SOCKET_FILE\&quot; &amp;&quot;
}

getLsbStartupHeader_phpcgi() {
	getChkconfigScriptContents &quot;$PHPCGI_STARTUP_DESC&quot;
	getLsbStartupScriptContents phpcgi &quot;$PHPCGI_STARTUP_DESC&quot;

	getCommonStartupScriptContents_phpcgi &quot;$WWW_USER&quot; &quot;$WWW_PHP_CGI&quot;
}

getCommonStartupScriptContents_nginx() {
	getCommonStartupScriptContents_simpleService &quot;root&quot; &quot;$1&quot; &quot;\$BINPATH&quot; &quot;$NGINX_PID_FILE&quot;
}

getLsbStartupHeader_nginx() {
	getChkconfigScriptContents &quot;$NGINX_STARTUP_DESC&quot;
	getLsbStartupScriptContents nginx &quot;$NGINX_STARTUP_DESC&quot;

	getCommonStartupScriptContents_nginx &quot;$NGINX_BIN&quot;
}

getCommonStartupScriptContents_lighttpd() {
	getCommonStartupScriptContents_simpleService &quot;root&quot; &quot;$1&quot; &quot;\$BINPATH -f $LIGHTTPD_CONF 2&gt;/dev/null&quot; &quot;$LIGHTTPD_PID_FILE&quot;
}

getLsbStartupHeader_lighttpd() {
	getChkconfigScriptContents &quot;$LIGHTTPD_STARTUP_DESC&quot;
	getLsbStartupScriptContents lighttpd &quot;$LIGHTTPD_STARTUP_DESC&quot;

	getCommonStartupScriptContents_lighttpd &quot;$LIGHTTPD_BIN&quot;
}

addLsbHeaderToStartupScript() {
	local scriptPath=&quot;$1&quot;
	local provides=&quot;${2:-$scriptPath}&quot;
	local desc=&quot;${3:-$provides}&quot;
	[ -x &quot;$scriptPath&quot; ] || return
	grep -qE &#39;^### BEGIN INIT INFO&#39; &quot;$scriptPath&quot; &amp;&amp; return
	ed -s &quot;$scriptPath&quot; &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF
1a
$(getLsbStartupScriptContents &quot;$provides&quot; &quot;$desc&quot;)
.
w
q
EOF
}

installMissingPerlModules() {
	detectMissingPerlModules
	[ -z &quot;$MISSING_PERL_MODULES&quot; ] &amp;&amp; return
	cat &lt;&lt; EOF
$CWARNING
The following Perl modules are still missing:
	$MISSING_PERL_MODULES
I&#39;ll try to use the cpan script to install them.$CEND
EOF

	# Some Perl modules will fail to build unless Test::More is installed
	MISSING_PERL_MODULES=&quot;Test::More $MISSING_PERL_MODULES&quot;

	echo &quot;${CMSG}Installing cpan and required build tools...$CEND&quot;
	installBuildTools
	osHandler_$os installCpanTools
	detectCpanBin
	if [ -n &quot;$CPAN&quot; ]; then
		$CPAN $MISSING_PERL_MODULES
	else
		local mods=
		for mod in $MISSING_PERL_MODULES; do
			[ -n &quot;$mods&quot; ] &amp;&amp; mods=&quot;$mods,&quot;
			mods=&quot;$mods \&quot;$mod\&quot;&quot;
		done
		perl -MCPAN -e &quot;CPAN::Shell-&gt;install($mods)&quot;
	fi

	detectMissingPerlModules
	[ -z &quot;$MISSING_PERL_MODULES&quot; ] &amp;&amp; return
	errorExit &quot;CPAN somehow failed to install the missing Perl modules. Missing: $MISSING_PERL_MODULES&quot;
}

osHandler_debian() {
	case $1 in
		init)
			INSTALL=&quot;apt-get -y install&quot;
			FEATURES=&quot;service rtorrent apache nginx lighttpd vsftpd webmin&quot;
			BUILD_TOOLS=&quot;build-essential make file pkg-config libtool m4&quot;
			;;
		init2)
			apt-get update
			installProgram ed

			# Make sure Debian 6 doesn&#39;t fail when adding new services. We need ed for this
			# so run it after installing ed...
			addLsbHeaderToStartupScript /etc/init.d/webmin &quot;webmin&quot; &quot;webmin&quot;
			;;
		installTools)
			PACKAGES=
			addProgram irssi
			addProgram mediainfo
			addProgram git-core
			addProgram svn subversion
			addProgram wget
			addProgram unzip
			addProgram screen
			installPackages
			# Make sure subversion won&#39;t complain about invalid certs
			$INSTALL ca-certificates
			;;
		installAutodlTools)
			PACKAGES=
			addProgram perl
			addPerlModule Archive::Zip libarchive-zip-perl
			addPerlModule HTML::Parser libhtml-parser-perl
			addPerlModule Digest::SHA1 libdigest-sha-perl
			installPackages

			installPerlModule Net::SSLeay libnet-ssleay-perl
			installPerlModule XML::LibXML libxml-libxml-perl
			installPerlModule JSON::XS libjson-xs-perl
			installPerlModule JSON libjson-perl
			;;
		installCpanTools)
			# Need to remove the old JSON or cpan may fail to build the modules
			if echo &quot;$OLD_PERL_MODULES&quot; | grep -qE &#39;(^| )JSON( |$)&#39;; then
				apt-get -y remove libjson-perl
			fi

			PACKAGES=
			if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;XML::LibXML&#39;; then
				PACKAGES=&quot;$PACKAGES libxml2 libxml2-dev zlib1g zlib1g-dev&quot;
			fi
			if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;Net::SSLeay&#39;; then
				# There&#39;s no libssl package
				PACKAGES=&quot;$PACKAGES openssl libssl-dev zlib1g zlib1g-dev&quot;
			fi
			installPackages
			;;
		installRtorrentBuildTools)
			PACKAGES=&quot;libsigc++-2.0-dev libssl-dev libncurses-dev&quot;
			if apt-cache search libcurl4-openssl-dev 2&gt; /dev/null | grep -q &#39;libcurl4-openssl-dev&#39;; then
				PACKAGES=&quot;$PACKAGES libcurl4-openssl-dev&quot;
			else
				PACKAGES=&quot;$PACKAGES libcurl3-openssl-dev&quot;
			fi
			installPackages
			;;
		installPhpModules)
			installMissingPhp5Packages
			;;
		_installService)
			local serviceName=&quot;$2&quot;
			local headerCommand=&quot;$3&quot;
			local serviceFile=/etc/init.d/$serviceName
			local lockFile=
			cat &gt; &quot;$serviceFile&quot; &lt;&lt; EOF
#!/bin/sh
$(eval $headerCommand)

. /lib/lsb/init-functions

v_startIt() {
	log_begin_msg &quot;Starting \$NAME...&quot;
	startIt
	log_end_msg \$?
}

v_stopIt() {
	log_begin_msg &quot;Stopping \$NAME...&quot;
	stopIt
	log_end_msg \$?
}

$(getLsbStartupFooter &quot;$lockFile&quot;)
EOF
			[ $? -eq 0 ] || errorExit &quot;Could not write to file $serviceFile. Run this script as root.&quot;
			chmod +x &quot;$serviceFile&quot; || errorExit &quot;Could not set +x bit, file $serviceFile.&quot;
			update-rc.d $serviceName defaults || errorExit &quot;Could not install service $serviceFile. Run this script as root.&quot;
			invoke-rc.d $serviceName restart
			;;
		installAutodlService)
			local user=$2
			osHandler_$os _installService autodl_$user &quot;getLsbStartupHeader_autodl \&quot;$user\&quot; \&quot;\$serviceName\&quot;&quot;
			;;
		_installCommonWebServerStuff)
			# Also add some extra tools for ruTorrent and some of its plugins
			PACKAGES=&quot;php5-cli gzip curl openssl logrotate&quot;
			installPackages
			# Ubuntu 8 doesn&#39;t have php5-geoip
			PACKAGES=&quot;php5-geoip&quot;
			installPackages
			PACKAGES=&quot;unrar&quot;
			installPackages
			;;
		installApache)
			osHandler_$os _installCommonWebServerStuff
			PACKAGES=&quot;apache2-mpm-prefork libapache2-mod-php5 php5 &quot;
			installPackages
			PACKAGES=&quot;libapache2-mod-scgi&quot;; installPackages

			WWW_PHP_INI=/etc/php5/apache2/php.ini
			APACHE_DIR=/etc/apache2
			APACHE_SITE_NAME=rutorrent.conf
			APACHE_SCGI_FILE=$APACHE_DIR/mods-available/scgi.load
			initializeApacheVars www-data www-data &quot;$APACHE_DIR/sites-available&quot;
			apacheCommonInitialization &quot;apache2-prefork-dev&quot; /usr/lib/apache2/modules

			a2enmod ssl || errorExit &quot;Could not enable mod_ssl&quot;
			a2enmod scgi || errorExit &quot;Could not enable mod_scgi&quot;
			# Ubuntu Server 6 doesn&#39;t come with this module
			a2enmod auth_basic
			a2dissite default
			a2dissite default-ssl
			a2ensite $APACHE_SITE_NAME || errorExit &quot;Could not enable site&quot;
			if ! grep -qE &quot;^[ 	]*Listen.*[: 	]$HTTPS_PORT\\&gt;&quot; &quot;$APACHE_DIR/ports.conf&quot;; then
				echo &quot;Listen $HTTPS_PORT&quot; &gt;&gt; &quot;$APACHE_DIR/ports.conf&quot;
			fi
			resetWebServerPermissions
			invoke-rc.d apache2 restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		restart_apache)
			invoke-rc.d apache2 restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		installVsftpd)
			installProgram vsftpd
			updateVsftpdConf /etc/vsftpd.conf
			invoke-rc.d vsftpd restart || errorExit &quot;Could not restart vsftpd&quot;
			;;
		preNginxInstall)
			WWW_PHP_INI=/etc/php5/cgi/php.ini
			osHandler_$os _installCommonWebServerStuff
			PACKAGES=&quot;libpcre3-dev libssl-dev zlib1g-dev php5-cgi&quot;
			installPackages

			# Make sure it builds on Debian GNU/kFreeBSD 6.0.
			if [ &quot;$(uname -s)&quot; != Linux ]; then
				NGINX_CFLAGS=&quot;-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64&quot;
			fi
			;;
		installPhpCgiService)
			osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi
			;;
		installNginxService)
			osHandler_$os _installService nginx getLsbStartupHeader_nginx
			;;
		restart_nginx)
			invoke-rc.d phpcgi restart || errorExit &quot;Could not start php-cgi&quot;
			invoke-rc.d nginx restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		preLighttpdInstall)
			WWW_PHP_INI=/etc/php5/cgi/php.ini
			osHandler_$os _installCommonWebServerStuff
			PACKAGES=&quot;libpcre3-dev libssl-dev zlib1g-dev php5-cgi&quot;
			installPackages
			;;
		installLighttpdService)
			osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd
			;;
		restart_lighttpd)
			invoke-rc.d phpcgi restart || errorExit &quot;Could not start php-cgi&quot;
			invoke-rc.d lighttpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		postWebminInstall)
			addLsbHeaderToStartupScript /etc/init.d/webmin &quot;webmin&quot; &quot;webmin&quot;
			;;
		*)
			;;
	esac
}

osHandler_fedora() {
	case $1 in
		init)
			INSTALL=&quot;yum -y install&quot;
			FEATURES=&quot;service rtorrent apache nginx lighttpd vsftpd webmin&quot;
			BUILD_TOOLS=&quot;gcc gcc-c++ make kernel-headers pkgconfig file libtool m4&quot;
			;;
		init2)
			installProgram which
			installProgram ed
			;;
		installTools)
			PACKAGES=
			addProgram svn subversion
			addProgram wget
			addProgram unzip
			addProgram screen
			addProgram git
			installPackages
			;;
		installAutodlTools)
			if grep -q &quot;release 4[. ]&quot; /etc/redhat-release; then
				IRSSI_LOAD_PERL=y
			fi
			PACKAGES=
			addProgram perl
			addProgram irssi
			addPerlModule Time::HiRes perl-Time-HiRes
			addPerlModule Archive::Zip perl-Archive-Zip
			addPerlModule Net::SSLeay perl-Net-SSLeay
			addPerlModule HTML::Parser perl-HTML-Parser
			addPerlModule XML::LibXML perl-XML-LibXML
			addPerlModule Digest::SHA1 perl-Digest-SHA1
			addPerlModule JSON::XS perl-JSON-XS
			addPerlModule JSON perl-JSON
			installPackages
			;;
		installCpanTools)
			# Need to remove the old JSON or cpan may fail to build the modules
			if echo &quot;$OLD_PERL_MODULES&quot; | grep -qE &#39;(^| )JSON( |$)&#39;; then
				yum -y remove perl-JSON
			fi

			# CentOS doesn&#39;t have &#39;perl-CPAN&#39;. It&#39;s in the &#39;perl&#39; package though.
			PACKAGES=&quot;perl-CPAN&quot;
			if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;XML::LibXML&#39;; then
				PACKAGES=&quot;$PACKAGES libxml2 libxml2-devel zlib zlib-devel&quot;
			fi
			if echo &quot;$MISSING_PERL_MODULES&quot; | grep -q &#39;Net::SSLeay&#39;; then
				PACKAGES=&quot;$PACKAGES openssl openssl-devel zlib zlib-devel&quot;
			fi
			installPackages
			;;
		installRtorrentBuildTools)
			# CentOS 5: curl-devel, no libsigc++20
			# Fedora 14: libcurl-devel
			PACKAGES=&quot;libsigc++20-devel ncurses-devel openssl-devel libcurl-devel curl-devel&quot;
			installPackages
			;;
		installPhpModules)
			;;
		_installService)
			local serviceName=&quot;$2&quot;
			local headerCommand=&quot;$3&quot;
			installService_chkconfig1 $serviceName
			cat &gt; &quot;$CHKCONFIG_SERVICE_FILE&quot; &lt;&lt; EOF
#!/bin/bash
$(eval $headerCommand)

. /etc/rc.d/init.d/functions

v_startIt() {
	echo -n &quot;Starting \$NAME: &quot;
	startIt &amp;&amp; success || failure
	echo
}

v_stopIt() {
	echo -n &quot;Stopping \$NAME: &quot;
	stopIt &amp;&amp; success || failure
	echo
}

$(getLsbStartupFooter &quot;$CHKCONFIG_LOCK_FILE&quot;)
EOF
			[ $? -eq 0 ] || errorExit &quot;Could not write to file $CHKCONFIG_SERVICE_FILE. Run this script as root.&quot;
			installService_chkconfig2
			;;
		installAutodlService)
			local user=$2
			osHandler_$os _installService autodl_$user &quot;getLsbStartupHeader_autodl \&quot;$user\&quot; \&quot;\$CHKCONFIG_SERVICE_NAME\&quot;&quot;
			;;
		_installCommonWebServerStuff)
			PACKAGE=&quot;php-cli gzip curl openssl unrar logrotate&quot;
			installPackages
			# CentOS 4: will get an error about a php v4 dependency, so can&#39;t put it in above PACKAGE var
			PACKAGES=&quot;php-pecl-geoip&quot;
			installPackages
			;;
		installApache)
			osHandler_$os _installCommonWebServerStuff
			# Also add some extra tools for ruTorrent and some of its plugins
			PACKAGES=&quot;httpd httpd-tools mod_ssl mod_scgi php&quot;
			installPackages

			WWW_PHP_INI=/etc/php.ini
			APACHE_DIR=/etc/httpd
			local APACHE_CONF_D=$APACHE_DIR/conf.d
			APACHE_SCGI_FILE=$APACHE_CONF_D/scgi.conf
			initializeApacheVars apache apache &quot;$APACHE_CONF_D&quot;
			apacheCommonInitialization &quot;httpd-devel&quot; $APACHE_DIR/modules

			[ -f &quot;$APACHE_CONF_D/welcome.conf&quot; ] &amp;&amp; mv -f &quot;$APACHE_CONF_D/welcome.conf&quot; &quot;$APACHE_CONF_D/welcome.conf-bak&quot;
			# Remove an Apache warning by commenting out the default SSL VirtualHost
			sed_i &#39;/^&lt;VirtualHost _default_:443&gt;/,/^&lt;\/VirtualHost&gt;/s/^/#/&#39; $APACHE_CONF_D/ssl.conf

			resetWebServerPermissions
			chkconfig httpd on
			service httpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		restart_apache)
			service httpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		installVsftpd)
			installVsftpd_chkconfig /etc/vsftpd/vsftpd.conf
			;;
		preNginxInstall)
			WWW_PHP_INI=/etc/php.ini
			osHandler_$os _installCommonWebServerStuff
			PACKAGES=&quot;pcre-devel openssl-devel zlib-devel php-cgi&quot;
			installPackages
			;;
		installPhpCgiService)
			osHandler_$os _installService phpcgi getLsbStartupHeader_phpcgi
			;;
		installNginxService)
			osHandler_$os _installService nginx getLsbStartupHeader_nginx
			;;
		restart_nginx)
			service phpcgi restart || errorExit &quot;Could not start php-cgi&quot;
			service nginx restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		preLighttpdInstall)
			WWW_PHP_INI=/etc/php.ini
			osHandler_$os _installCommonWebServerStuff
			PACKAGES=&quot;pcre-devel openssl-devel zlib-devel php-cgi&quot;
			installPackages
			;;
		installLighttpdService)
			osHandler_$os _installService lighttpd getLsbStartupHeader_lighttpd
			;;
		restart_lighttpd)
			service phpcgi restart || errorExit &quot;Could not start php-cgi&quot;
			service lighttpd restart || errorExit &quot;Could not start $INSTALL_WEB_SERVER&quot;
			;;
		*)
			;;
	esac
}

isWebServerRpcModule() {
	! arrayIsPresent rpc $RUTORRENT_PLUGINS &amp;&amp; ! arrayIsPresent httprpc $RUTORRENT_PLUGINS &amp;&amp; return 0
	return 1
}

canInstallService() {
	return $(arrayIsPresent service $FEATURES)
}

canInstallRtorrent() {
	return $(arrayIsPresent rtorrent $FEATURES)
}

canInstallApache() {
	return $(arrayIsPresent apache $FEATURES)
}

canInstallNginx() {
	return $(arrayIsPresent nginx $FEATURES)
}

canInstallLighttpd() {
	return $(arrayIsPresent lighttpd $FEATURES)
}

canInstallVsftpd() {
	return $(arrayIsPresent vsftpd $FEATURES)
}

canInstallWebmin() {
	return $(arrayIsPresent webmin $FEATURES)
}

getRequiredPrograms() {
	REQUIRED_PROGRAMS=&quot;which svn wget unzip ed sed grep tar expr ps awk kill printf&quot;

	if [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ]; then
		REQUIRED_PROGRAMS=&quot;$REQUIRED_PROGRAMS perl&quot;

		# NetBSD and DragonFly BSD don&#39;t compile Irssi with Perl support by default
		[ &quot;$IGNORE_IRSSI&quot; != y ] &amp;&amp; REQUIRED_PROGRAMS=&quot;$REQUIRED_PROGRAMS irssi&quot;
	fi
}

verifyInstalledPrograms() {
	getRequiredPrograms

	local MISSING_PROGRAMS=
	for prog in $REQUIRED_PROGRAMS; do
		local name=$prog
		[ &quot;$prog&quot; = svn ] &amp;&amp; name=subversion
		isProgramInstalled &quot;$prog&quot; || MISSING_PROGRAMS=&quot;$MISSING_PROGRAMS $name&quot;
	done
	[ -n &quot;$MISSING_PROGRAMS&quot; ] &amp;&amp; errorExit &quot;Can&#39;t continue. The following programs are not installed: $MISSING_PROGRAMS&quot;
}

initPluginDirVar() {
	AUTODL_IRSSI_PLUGIN_DIR=&quot;$RUTORRENT_BASE_PATH/plugins/autodl-irssi&quot;
}

getRtorrentDirs() {
	local user=&quot;$1&quot;
	getUserDir &quot;$user&quot;
	RTORRENT_DOWNLOAD_DIR=&quot;$userDir/$RTORRENT_REL_DOWNLOAD_DIR&quot;
	RTORRENT_WATCH_DIR=&quot;$userDir/$RTORRENT_REL_WATCH_DIR&quot;
	RTORRENT_SESSION_DIR=&quot;$userDir/$RTORRENT_REL_SESSION_DIR&quot;
}

getUserScgiSocketPath() {
	local user=&quot;$1&quot;
	getRtorrentDirs &quot;$user&quot;
	scgiSocketPath=&quot;$RTORRENT_SESSION_DIR/rpc.socket&quot;
}

waitenter() {
	local msg=&quot;${1-Press ENTER to continue...}&quot;
	echo -n &quot;$CCYAN$msg$CEND&quot;
	read dummy
}

askQuestion() {
	local question=&quot;$1&quot;
	local default=&quot;$2&quot;

	if [ -z &quot;$default&quot; ]; then
		echo -n &quot;$CQUESTION$question$CEND &quot;
		read answer
	else
		echo -n &quot;$CQUESTION$question$CEND [$CGREEN$default$CEND] &quot;
		read answer
	fi
	if [ -z &quot;$answer&quot; ]; then
		answer=&quot;$default&quot;
	fi
}

# Asks the user a question, and sets answer to y or n depending on the user&#39;s answer
askYesNo() {
	local question=&quot;$1&quot;
	local default=&quot;$2&quot;

	while true; do
		askQuestion &quot;$question&quot; &quot;$default&quot;
		if echo &quot;$answer&quot; | grep -qiE &#39;^y(es)?$&#39;; then
			answer=y
			return 1
		elif echo &quot;$answer&quot; | grep -qiE &#39;^no?$&#39;; then
			answer=n
			return 0
		fi
	done
}

askOsUser() {
	local stopIfEmpty=${1:-n}
	local user=
	while true; do
		askQuestion &quot;Enter name of user:&quot; &quot;&quot;
		user=&quot;$answer&quot;
		[ -z &quot;$user&quot; ] &amp;&amp; [ &quot;$stopIfEmpty&quot; = y ] &amp;&amp; break
		userExists &quot;$user&quot; &amp;&amp; break

		echo &quot;${CWARNING}User $user does not exist.$CEND&quot;
		askYesNo &quot;Do you want to create user $user?&quot; &quot;No&quot;
		[ &quot;$answer&quot; = n ] &amp;&amp; continue

		echo &quot;${CMSG}Creating user $user.$CEND&quot;
		if ! useradd -m -s /bin/sh &quot;$user&quot;; then
			echo &quot;${CWARNING}Could not create user $user.$CEND&quot;
			continue
		fi
		echo &quot;${CMSG}Enter the user&#39;s password:$CEND&quot;
		if ! passwd &quot;$user&quot;; then
			echo &quot;${CWARNING}Failed to set password.$CEND&quot;
			continue
		fi
		userExists &quot;$user&quot; &amp;&amp; break
	done
	answer=&quot;$user&quot;
}

# Adds another user to USERS
addUser() {
	local osUser=&quot;$1&quot;
	local webUser=&quot;$2&quot;
	local autodlPassword=
	local webpass=

	if [ &quot;$INSTALL_RUTORRENT&quot; = y ] || [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
		if ! canGeneratePasswords; then
			cat &lt;&lt; EOF
$CQUESTION
The password makes sure only you can change your autodl-irssi settings. This is
NOT your login password. Use any password, but each user should use a unique
password. The password is used by the PHP code to access autodl-irssi settings.
You don&#39;t need to remember this password.  It can&#39;t contain any spaces or a
colon &#39;:&#39;.$CEND
EOF
			while true; do
				askQuestion &quot;Enter the autodl-irssi password (this is not your login password):&quot; &quot;&quot;
				autodlPassword=&quot;$answer&quot;
				isValidPassword &quot;$autodlPassword&quot; &amp;&amp; break
				echo &quot;${CWARNING}Invalid password. Try again.$CEND&quot;
			done
		fi

		if [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ]; then
			while true; do
				askQuestion &quot;Enter your ruTorrent password:&quot; &quot;&quot;
				webpass=&quot;$answer&quot;
				isValidPassword &quot;$webpass&quot; &amp;&amp; break
				echo &quot;${CWARNING}Invalid password. Try again.$CEND&quot;
			done
		fi

		USERS=&quot;$USERS $osUser:$autodlPassword:$webUser:$webpass&quot;
	else
		USERS=&quot;$USERS $osUser&quot;
	fi
}

installUser() {
	local userPluginDir=&quot;$1&quot;
	local osUser=&quot;$2&quot;
	local webUser=&quot;${3:-$osUser}&quot;
	local port=&quot;$4&quot;
	local autodlPassword=&quot;$5&quot;

	getUserGroup &quot;$osUser&quot;
	getUserDir &quot;$osUser&quot;

	cat &lt;&lt; EOF

========================= ${CGREEN}Installing autodl-irssi$CEND =========================
Use the ruTorrent plugin: $CGREEN$USE_RUTORRENT_PLUGIN$CEND
OS user: $CGREEN$osUser$CEND
EOF
	if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
		[ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ] &amp;&amp; echo &quot;ruTorrent user: $CGREEN$webUser$CEND&quot;
		echo &quot;port: $CGREEN$port$CEND&quot;
		echo &quot;password: $CGREEN$autodlPassword$CEND&quot;
	fi
	cat &lt;&lt; EOF
group: $CGREEN$group$CEND
home: $CGREEN$userDir$CEND

EOF
	if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
		isValidPortNumber &quot;$port&quot; || errorExit &quot;Invalid port number: $port&quot;
		isValidPassword &quot;$autodlPassword&quot; || errorExit &quot;Invalid password: $autodlPassword&quot;
		isValidWebUser &quot;$webUser&quot; || errorExit &quot;Invalid web user: $webUser&quot;
	fi

	mkdir -p &quot;$userDir/.irssi/scripts/autorun&quot;
	cd &quot;$userDir/.irssi/scripts&quot; || errorExit &quot;Could not CD into user dir. Run the script as root.&quot;
	echo &quot;${CMSG}Downloading autodl-irssi.zip...$CEND&quot;
	if ! downloadFile autodl-irssi.zip &quot;$AUTODL_IRSSI_ZIP_URL&quot;; then
		errorExit &quot;Could not download autodl-irssi zip file&quot;
	fi
	echo &quot;${CMSG}Unpacking autodl-irssi...$CEND&quot;
	unzip -o autodl-irssi.zip &gt; /dev/null || errorExit &quot;Could not unpack autodl-irssi zip file&quot;
	rm -f autodl-irssi.zip
	cp autodl-irssi.pl autorun/ || errorExit &quot;Could not copy autodl-irssi.pl to Irssi autorun dir.&quot;
	mkdir -p &quot;$userDir/.autodl&quot;
	touch &quot;$userDir/.autodl/autodl.cfg&quot;
	if ! [ -s &quot;$userDir/.autodl/autodl.cfg&quot; ]; then
		[ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; cat &gt; &quot;$userDir/.autodl/autodl.cfg&quot; &lt;&lt; EOF
[options]
upload-type = rtorrent
EOF
	fi

	if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
		if [ ! -d &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; ]; then
			errorExit &quot;The autodl-irssi ruTorrent plugin has not been installed. Install it.&quot;
		fi

		cat &gt; &quot;$userDir/.autodl/autodl2.cfg&quot; &lt;&lt; EOF
[options]
gui-server-port = $port
gui-server-password = $autodlPassword
EOF

		rm -f &quot;$AUTODL_IRSSI_PLUGIN_DIR/conf.php&quot;
		mkdir -p &quot;$userPluginDir&quot;
		cat &gt; &quot;$userPluginDir/conf.php&quot; &lt;&lt; EOF
&lt;?php
\$autodlPort = $port;
\$autodlPassword = &quot;$autodlPassword&quot;;
?&gt;
EOF
		[ $? -eq 0 ] || errorExit &quot;Could not write to $userPluginDir/conf.php. Run this script as root.&quot;
		# Only set perms to 0400 if the code knows the owner (web server owner) and will reset it
		[ &quot;$ISROOT&quot; = y ] &amp;&amp; [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; chmod 0400 &quot;$userPluginDir/conf.php&quot;
	else
		# Don&#39;t use the autodl-irssi ruTorrent plugin
		: &gt; &quot;$userDir/.autodl/autodl2.cfg&quot;
	fi

	# The Perl module isn&#39;t loaded by default
	if [ &quot;$IRSSI_LOAD_PERL&quot; = y ]; then
		if [ ! -f &quot;$userDir/.irssi/startup&quot; ] || ! grep -q &#39;load perl&#39; &quot;$userDir/.irssi/startup&quot;; then
			echo &quot;load perl&quot; &gt;&gt; &quot;$userDir/.irssi/startup&quot;
		fi
	fi

	# Make sure we redownload the tracker files since the ones in the zip file are possibly
	# old versions.
	local autodlStateFile=&quot;$userDir/.autodl/AutodlState.xml&quot;
	[ -f &quot;$autodlStateFile&quot; ] &amp;&amp; sed_i &#39;g/&lt;trackers-version&gt;/d&#39; &quot;$autodlStateFile&quot;

	resetOwner &quot;$osUser&quot; &quot;$userDir/.autodl&quot; &quot;$userDir/.irssi&quot;
	chmod 0700 &quot;$userDir/.autodl&quot; &quot;$userDir/.irssi&quot;
}

getRutorrentUserConfDir() {
	userConfDir=&quot;$RUTORRENT_BASE_PATH/conf/users/$webUser&quot;
}

getRutorrentUserShareDir() {
	userShareDir=&quot;$RUTORRENT_BASE_PATH/share/users/$webUser&quot;
}

resetRutorrentUserPermissions() {
	for packedUser in $USERS; do
		extractPackedUser $packedUser
		getRutorrentUserConfDir
		getRutorrentUserShareDir
		# Make sure only the web server and the user itself can access its share/conf dirs
		chown $osUser:$WWW_GROUP &quot;$userShareDir&quot; &quot;$userConfDir&quot;
		chmod 0770 &quot;$userShareDir&quot; &quot;$userConfDir&quot;
	done
}

############################################################################
#
# This is where we start
#
############################################################################

SELINUX_ENABLED=n
isProgramInstalled selinuxenabled &amp;&amp; selinuxenabled &amp;&amp; SELINUX_ENABLED=y
echo &quot;SELinux enabled: $SELINUX_ENABLED&quot;

ISROOT=n
[ $(id -u) -eq 0 ] &amp;&amp; ISROOT=y
echo &quot;Is root user: $ISROOT&quot;

if [ $# -gt 0 ]; then
	parseCommandLine &quot;$@&quot;
	INTERACTIVE=n
else
	INTERACTIVE=y
fi

detectOs
cat &lt;&lt; EOF
Detected OS: $CGREEN$os_long$CEND
Type: $CGREEN$os$CEND

Type sh $0 --help for all command line options.
EOF

osHandler_$os init

if [ &quot;$INTERACTIVE&quot; = y ]; then
	if [ &quot;$ISROOT&quot; = n ]; then
		cat &lt;&lt; EOF
$CRED
You&#39;re not the root user! This install script may fail if you&#39;re not the root
user. To start it as the root user do one of the following:

Ubuntu and Ubuntu clones:
	${CGREEN}sudo sh $0$CRED

Any other OS:
	${CGREEN}su
	sh $0$CRED
$CEND
EOF
		waitenter &quot;Press Ctrl+C to exit or ENTER to continue...&quot;
	fi

	cat &lt;&lt; EOF
$CMSG
Press ENTER to use the default answer in [brackets].$CEND
EOF

	webServers=
	canInstallLighttpd	&amp;&amp; webServers=&quot;$webServers lighttpd&quot;
	canInstallNginx		&amp;&amp; webServers=&quot;$webServers nginx&quot;
	canInstallApache	&amp;&amp; webServers=&quot;$webServers apache&quot;
	if [ -n &quot;$webServers&quot; ]; then
		cat &lt;&lt; EOF
$CQUESTION
If you want to install ruTorrent you must install a web server, eg. Apache.
If you&#39;ve already installed another web server, you must first uninstall it or
disable it. List of supported web servers:$CEND
EOF
		canInstallLighttpd	&amp;&amp; echo &quot;  ${CGREEN}lighttpd$CEND ${CQUESTION}lighttpd web server (lightweight)$CEND&quot;
		canInstallNginx		&amp;&amp; echo &quot;  ${CGREEN}nginx$CEND    ${CQUESTION}nginx web server (lightweight)$CEND&quot;
		canInstallApache	&amp;&amp; echo &quot;  ${CGREEN}apache$CEND   ${CQUESTION}Apache web server$CEND&quot;
							   echo &quot;  ${CGREEN}none$CEND     ${CQUESTION}Don&#39;t install a web server$CEND&quot;
		while true; do
			INSTALL_WEB_SERVER=
			echo &quot;${CQUESTION}Select one of:$CGREEN$webServers none$CEND&quot;
			askQuestion &quot;Enter name of web server&quot; &quot;$(getFirst $webServers)&quot;
			[ &quot;$answer&quot; = none ] &amp;&amp; break
			INSTALL_WEB_SERVER=&quot;$answer&quot;
			arrayIsPresent $INSTALL_WEB_SERVER $webServers &amp;&amp; break
		done
		if [ -n &quot;$INSTALL_WEB_SERVER&quot; ]; then
			askYesNo &quot;Do you want to install ruTorrent?&quot; &quot;Yes&quot;
			INSTALL_RUTORRENT=&quot;$answer&quot;
		else
			INSTALL_RUTORRENT=n
		fi
	fi

	if canInstallRtorrent; then
		cat &lt;&lt; EOF
$CQUESTION
ruTorrent requires a working rtorrent built with XML-RPC support.$CEND
EOF
		askYesNo &quot;Do you want to build rtorrent?&quot; &quot;Yes&quot;
		BUILD_RTORRENT=&quot;$answer&quot;
	fi

	askYesNo &quot;Do you want to install the autodl-irssi ruTorrent plugin?&quot; &quot;Yes&quot;
	USE_RUTORRENT_PLUGIN=&quot;$answer&quot;

	if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		REINSTALL_RUTORRENT_PLUGIN=n
		RUTORRENT_PASSWORD_PROTECTED=y
	elif [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
		echo &quot;&quot;
		while true; do
			echo &quot;${CQUESTION}The ruTorrent www base path is where you installed ruTorrent.$CEND&quot;
			askQuestion &quot;What is the ruTorrent www base path, eg. /var/www/rutorrent:&quot; &quot;&quot;
			RUTORRENT_BASE_PATH=&quot;$answer&quot;
			isValidRutorrentBasePath &quot;$RUTORRENT_BASE_PATH&quot; &amp;&amp; break

			echo &quot;$CWARNING$RUTORRENT_BASE_PATH is not the ruTorrent base path.$CEND&quot;
		done

		initPluginDirVar
		if [ -d &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; ]; then
			echo &quot;&quot;
			askYesNo &quot;The autodl-irssi ruTorrent plugin seems to be installed. Do you want to re-install it?&quot; &quot;No&quot;
			REINSTALL_RUTORRENT_PLUGIN=&quot;$answer&quot;
		else
			REINSTALL_RUTORRENT_PLUGIN=n
		fi

		cat &lt;&lt; EOF
$CQUESTION
To use more than one ruTorrent user, you must password protect ruTorrent.$CEND
EOF
		askYesNo &quot;Is ruTorrent password protected?&quot; &quot;No&quot;
		RUTORRENT_PASSWORD_PROTECTED=&quot;$answer&quot;
	else
		RUTORRENT_PASSWORD_PROTECTED=n
	fi

	if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
		INSTALL_AUTODL_IRSSI=y
	else
		askYesNo &quot;Do you want to install autodl-irssi?&quot; &quot;Yes&quot;
		INSTALL_AUTODL_IRSSI=&quot;$answer&quot;
	fi

	if canInstallService &amp;&amp; ([ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] || [ &quot;$INSTALL_RUTORRENT&quot; = y ]); then
		cat &lt;&lt; EOF
$CQUESTION
If you want to automatically start Irssi and rtorrent when the computer boots,
install the startup script.$CEND
EOF
		askYesNo &quot;Do you want to install the startup script?&quot; &quot;Yes&quot;
		INSTALL_STARTUP_SCRIPT=&quot;$answer&quot;
	fi

	askUser=n
	if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] || [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] || \
		[ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] || [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		askUser=y
	fi
	if [ &quot;$askUser&quot; = y ]; then
		if [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = n ]; then
				cat &lt;&lt; EOF
$CQUESTION
This is the user running rtorrent and/or Irssi.$CEND
${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND
EOF
				askOsUser
				addUser &quot;$answer&quot; &quot;&quot;
		else
			while true; do
				cat &lt;&lt; EOF
$CQUESTION
===================== USER =====================
This is the user running rtorrent and/or Irssi.
${CWARNING}Don&#39;t use the root user. Use a normal user!$CEND
${CCYAN}Press ENTER to stop adding users.$CEND
EOF
				askOsUser y
				osUser=&quot;$answer&quot;
				[ -z &quot;$osUser&quot; ] &amp;&amp; break

				while true; do
					cat &lt;&lt; EOF
$CQUESTION
The ruTorrent user is the name you use to log in to ruTorrent.$CEND
EOF
					askQuestion &quot;Enter ruTorrent user:&quot; &quot;$osUser&quot;
					webUser=&quot;$answer&quot;
					isValidWebUser &quot;$webUser&quot; &amp;&amp; break
					echo &quot;${CWARNING}Invalid web user name &#39;$webUser&#39;. Use only lower case letters.&quot;
				done

				addUser &quot;$osUser&quot; &quot;$webUser&quot;
			done
		fi
	fi

	if canInstallVsftpd; then
		cat &lt;&lt; EOF
$CQUESTION
vsftpd is a very secure FTP daemon.$CEND
EOF
		askYesNo &quot;Do you want to install vsftpd?&quot; &quot;Yes&quot;
		INSTALL_VSFTPD=&quot;$answer&quot;

		if [ &quot;$INSTALL_VSFTPD&quot; = y ]; then
			askYesNo &quot;Do you want to use encrypted FTP (FTPES)&quot; &quot;Yes&quot;
			USE_ENCRYPTED_FTP=&quot;$answer&quot;

			port=$DEFAULT_PORT_FTP
			[ &quot;$USE_ENCRYPTED_FTP&quot; = y ] &amp;&amp; port=$DEFAULT_PORT_FTPES
			askQuestion &quot;Enter FTP port number&quot; &quot;$port&quot;
			FTP_PORT=&quot;$answer&quot;
		fi
	fi

	if canInstallWebmin; then
		cat &lt;&lt; EOF
$CQUESTION
Webmin is a web-based administration tool for your OS.$CEND
EOF
		askYesNo &quot;Do you want to install Webmin?&quot; &quot;Yes&quot;
		INSTALL_WEBMIN=&quot;$answer&quot;
	fi
fi

cmdline=&quot;sh $0&quot;
[ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -p&quot;
[ &quot;$REINSTALL_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -i&quot;
[ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -a&quot;
for user in $USERS; do cmdline=&quot;$cmdline -u $user&quot;; done
[ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -w&quot;
[ -n &quot;$RUTORRENT_BASE_PATH&quot; ] &amp;&amp; cmdline=&quot;$cmdline -r &#39;$RUTORRENT_BASE_PATH&#39;&quot;
[ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline -s&quot;
if [ -z &quot;$INSTALL_WEB_SERVER&quot; ]; then
	:
elif [ &quot;$INSTALL_WEB_SERVER&quot; = apache ]; then
	cmdline=&quot;$cmdline --apache&quot;
elif [ &quot;$INSTALL_WEB_SERVER&quot; = nginx ]; then
	cmdline=&quot;$cmdline --nginx&quot;
elif [ &quot;$INSTALL_WEB_SERVER&quot; = lighttpd ]; then
	cmdline=&quot;$cmdline --lighttpd&quot;
else
	errorExit &quot;Invalid web server: $INSTALL_WEB_SERVER&quot;
fi
[ &quot;$BUILD_RTORRENT&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --rtorrent&quot;
[ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --rutorrent&quot;
[ &quot;$INSTALL_VSFTPD&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --vsftpd&quot;
[ -n &quot;$FTP_PORT&quot; ] &amp;&amp; cmdline=&quot;$cmdline --ftp-port $FTP_PORT&quot;
[ &quot;$USE_ENCRYPTED_FTP&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --ftpes&quot;
[ &quot;$INSTALL_WEBMIN&quot; = y ] &amp;&amp; cmdline=&quot;$cmdline --webmin&quot;

cat &lt;&lt; EOF

You can execute this command as the root user (Ubuntu: use ${CRED}sudo$CEND):
  $CGREEN$cmdline$CEND

Use the autodl-irssi ruTorrent plugin: $USE_RUTORRENT_PLUGIN
Re-install the autodl-irssi ruTorrent plugin: $REINSTALL_RUTORRENT_PLUGIN
Install autodl-irssi: $INSTALL_AUTODL_IRSSI
Users: $USERS
ruTorrent is password protected: $RUTORRENT_PASSWORD_PROTECTED
ruTorrent base path: $RUTORRENT_BASE_PATH
Install startup script: $INSTALL_STARTUP_SCRIPT
Install web server: $INSTALL_WEB_SERVER
Build rtorrent: $BUILD_RTORRENT
Install ruTorrent: $INSTALL_RUTORRENT
Install vsftpd: $INSTALL_VSFTPD
FTP port: $FTP_PORT
Use FTPES: $USE_ENCRYPTED_FTP
Install Webmin: $INSTALL_WEBMIN
EOF

if [ -n &quot;$INSTALL_WEB_SERVER&quot; ]; then
	for port in $HTTP_PORT $HTTPS_PORT; do
		isPortUsed $port || continue
		cat &lt;&lt; EOF
$CWARNING
Port $port is in use. If it&#39;s not used by $INSTALL_WEB_SERVER, you may need to disable or
uninstall that other web server before continuing.$CEND
EOF
	done
fi

if [ &quot;$INTERACTIVE&quot; = y ]; then
	echo &quot;&quot;
	waitenter &quot;Press Ctrl+C to cancel or ENTER to install.&quot;
fi

osHandler_$os init2
initUsers
initPluginDirVar

[ -n &quot;$INSTALL_WEB_SERVER&quot; ] || [ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; RUTORRENT_PASSWORD_PROTECTED=y
[ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; [ -z &quot;$INSTALL_WEB_SERVER&quot; ] &amp;&amp; errorExit &quot;You must install a web server if you want to install ruTorrent, eg. use --apache --rutorrent&quot;
[ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; REINSTALL_RUTORRENT_PLUGIN=n

[ &quot;$BUILD_RTORRENT&quot; = y ] &amp;&amp; ! canInstallRtorrent &amp;&amp; errorExit &quot;Can&#39;t build rtorrent.&quot;
[ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] &amp;&amp; ! canInstallService &amp;&amp; errorExit &quot;Can&#39;t install startup script.&quot;
[ &quot;$INSTALL_VSFTPD&quot; = y ] &amp;&amp; ! canInstallVsftpd &amp;&amp; errorExit &quot;Can&#39;t install vsftpd.&quot;
[ &quot;$INSTALL_WEBMIN&quot; = y ] &amp;&amp; ! canInstallWebmin &amp;&amp; errorExit &quot;Can&#39;t install webmin.&quot;

if [ -z &quot;$INSTALL_WEB_SERVER&quot; ]; then
	:
elif [ &quot;$INSTALL_WEB_SERVER&quot; = apache ]; then
	canInstallApache || errorExit &quot;Can&#39;t install Apache.&quot;
elif [ &quot;$INSTALL_WEB_SERVER&quot; = nginx ]; then
	canInstallNginx || errorExit &quot;Can&#39;t install nginx.&quot;
elif [ &quot;$INSTALL_WEB_SERVER&quot; = lighttpd ]; then
	canInstallLighttpd || errorExit &quot;Can&#39;t install lighttpd.&quot;
else
	errorExit &quot;Invalid web server: $INSTALL_WEB_SERVER&quot;
fi

[ -n &quot;$FTP_PORT&quot; ] &amp;&amp; [ &quot;$FTP_PORT&quot; -lt 1 -o &quot;$FTP_PORT&quot; -gt 65535 ] &amp;&amp; errorExit &quot;Invalid FTP port: $FTP_PORT&quot;

if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
	if [ -z &quot;$INSTALL_WEB_SERVER&quot; ] &amp;&amp; ! isValidRutorrentBasePath &quot;$RUTORRENT_BASE_PATH&quot;; then
		errorExit &quot;$RUTORRENT_BASE_PATH is not a valid ruTorrent base path.&quot;
	fi
fi

if [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ]; then
	cat &lt;&lt; EOF
${CMSG}Installing required tools and Perl modules...
Some Perl modules may not be present, but will be installed from CPAN.$CEND
EOF
else
	echo &quot;${CMSG}Installing required tools...$CEND&quot;
fi
osHandler_$os installTools
setSvnOpts
[ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; osHandler_$os installAutodlTools

verifyInstalledPrograms

[ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; installMissingPerlModules

cat &lt;&lt; EOF
$CMSG
All required programs and Perl modules are now installed. Ignore any errors you
saw.$CEND
EOF

INSTALLED_RTORRENT=n
if [ &quot;$BUILD_RTORRENT&quot; = y ]; then
	cat &lt;&lt; EOF
$CMSG
Building rtorrent and dependencies...$CEND
EOF
	installRtorrent
	INSTALLED_RTORRENT=y
fi

if [ -z &quot;$INSTALL_WEB_SERVER&quot; ]; then
	:
elif [ &quot;$INSTALL_WEB_SERVER&quot; = apache ]; then
	echo &quot;&quot;
	echo &quot;${CMSG}Installing Apache$CEND&quot;
	osHandler_$os installApache
	installUnrar
elif [ &quot;$INSTALL_WEB_SERVER&quot; = nginx ]; then
	echo &quot;&quot;
	echo &quot;${CMSG}Installing nginx$CEND&quot;
	installNginx
elif [ &quot;$INSTALL_WEB_SERVER&quot; = lighttpd ]; then
	echo &quot;&quot;
	echo &quot;${CMSG}Installing lighttpd$CEND&quot;
	installLighttpd
else
	errorExit &quot;Invalid web server: $INSTALL_WEB_SERVER&quot;
fi

if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
	if isProgramInstalled php; then
		installMissingPhpModules
	else
		cat &lt;&lt; EOF
$CWARNING
Could not find the php executable. PHP is not installed or the PHP CLI version
is not installed.  The autodl-irssi ruTorrent plugin requires the following PHP
modules:
	$CGREEN$REQUIRED_PHP_MODULES$CWARNING
They&#39;re normally installed and enabled by default. If not you will need to
install them (if needed) and then enable each one in php.ini, eg.
extension=MODULE.so and then restart your web server.$CEND
EOF
	fi
fi

if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
	isProgramInstalled php || errorExit &quot;php is not installed!&quot;
	verifyWebServerVars
	echo &quot;&quot;
	echo &quot;${CMSG}Installing ruTorrent$CEND&quot;
	[ -d &quot;$WWW_ROOT&quot; ] || errorExit &quot;Invalid web root: &#39;$WWW_ROOT&#39; (does not exist)&quot;
	RUTORRENT_DIRNAME=rutorrent

	[ -f &quot;$WWW_ROOT/index.html&quot; ] || cat &gt; &quot;$WWW_ROOT/index.html&quot; &lt;&lt; EOF
&lt;html&gt;&lt;head&gt;&lt;title&gt;Root page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
&lt;a href=&quot;$RUTORRENT_DIRNAME/&quot;&gt;ruTorrent&lt;/a&gt;
&lt;/body&gt;&lt;/html&gt;
EOF

	cd &quot;$WWW_ROOT&quot;
	rm -rf &quot;$RUTORRENT_DIRNAME&quot;
	tmpName=rutorrent-tmp
	rm -rf $tmpName
	if ! svn co $SVN_OPTS &quot;$RUTORRENT_TRUNK_DIR&quot; $tmpName &gt;/dev/null; then
		# Subversion failed. Try the official tar balls
		mkdir -p $tmpName
		cd $tmpName
		downloadFile &quot;$RUTORRENT_CORE_NAME&quot; &quot;$RUTORRENT_CORE_URL&quot; &quot;$RUTORRENT_CORE_URL2&quot; || errorExit &quot;Could not download ruTorrent.&quot;
		downloadFile &quot;$RUTORRENT_PLUGINS_NAME&quot; &quot;$RUTORRENT_PLUGINS_URL&quot; &quot;$RUTORRENT_PLUGINS_URL2&quot; || errorExit &quot;Could not download ruTorrent plugins.&quot;
		for name in &quot;$RUTORRENT_CORE_NAME&quot; &quot;$RUTORRENT_PLUGINS_NAME&quot;; do
			tar xzf &quot;$name&quot; || errorExit &quot;Could not unpack $name&quot;
			rm -f &quot;$name&quot;
		done
		cd ..
	fi
	cd $tmpName
	RUTORRENT_BASE_PATH=&quot;$WWW_ROOT/$RUTORRENT_DIRNAME&quot;
	initPluginDirVar
	mv rutorrent/ &quot;$RUTORRENT_BASE_PATH&quot;
	mkdir -p &quot;$RUTORRENT_BASE_PATH/plugins&quot;
	for plugin in $RUTORRENT_PLUGINS; do
		if [ -d &quot;plugins/$plugin/&quot; ]; then
			echo &quot;${CMSG}Installing ruTorrent plugin: $plugin$CEND...&quot;
			mv plugins/$plugin/ &quot;$RUTORRENT_BASE_PATH/plugins/&quot; || errorExit &quot;Could not install plugin &#39;$plugin&#39;.&quot;
		else
			echo &quot;${CWARNING}Can&#39;t install missing plugin $plugin!$CEND&quot;
		fi
	done
	cd ..
	rm -rf $tmpName
	cp &quot;$RUTORRENT_BASE_PATH/favicon.ico&quot; &quot;$WWW_ROOT&quot;

	i=1
	touch &quot;$WWW_PASSWORD_FILE&quot;
	resetAuthPasswordFilePermissions
	detectHtpasswd
	for packedUser in $USERS; do
		extractPackedUser $packedUser
		getRutorrentUserConfDir
		getRutorrentUserShareDir
		getUserScgiSocketPath &quot;$osUser&quot;
		getRtorrentDirs &quot;$osUser&quot;

		# Create user&#39;s ruTorrent config.php
		rpcMount=&quot;$(getUserRpcMount $i)&quot;
		mkdir -p &quot;$userConfDir&quot;

		rutConfigFile=&quot;$userConfDir/config.php&quot;
		if [ &quot;$SCGI_USE_UNIX_DOMAIN_SOCKET&quot; = y ]; then
			cat &gt; &quot;$rutConfigFile&quot; &lt;&lt; EOF
&lt;?php
\$scgi_port = 0;
\$scgi_host = &quot;unix://$scgiSocketPath&quot;;
\$XMLRPCMountPoint = &quot;$rpcMount&quot;;
?&gt;
EOF
			exitCode=$?
		else
			cat &gt; &quot;$rutConfigFile&quot; &lt;&lt; EOF
&lt;?php
\$scgi_port = $scgiPort;
\$scgi_host = &quot;$SCGI_HOST&quot;;
\$XMLRPCMountPoint = &quot;$rpcMount&quot;;
?&gt;
EOF
			exitCode=$?
		fi
		[ $exitCode -eq 0 ] || errorExit &quot;Could not write to file $rutConfigFile&quot;

		# Create user&#39;s directory to prevent certain errors the first time ruTorrent is started
		mkdir -p &quot;$userShareDir/settings&quot;
		mkdir -p &quot;$userShareDir/torrents&quot;
		chmod 0777  &quot;$userShareDir/settings&quot; &quot;$userShareDir/torrents&quot;

		# Setup rtorrent
		mkdir -p &quot;$RTORRENT_DOWNLOAD_DIR&quot;
		mkdir -p &quot;$RTORRENT_WATCH_DIR&quot;
		mkdir -p &quot;$RTORRENT_SESSION_DIR&quot;
		rtorrentRc=&quot;$userDir/.rtorrent.rc&quot;
		[ -f &quot;$rtorrentRc&quot; ] &amp;&amp; mv -f &quot;$rtorrentRc&quot; &quot;$rtorrentRc-backup&quot;
		cat &gt; &quot;$rtorrentRc&quot; &lt;&lt; EOF
$(if [ &quot;$SCGI_USE_UNIX_DOMAIN_SOCKET&quot; = y ]; then
	cat &lt;&lt; EOF2
execute = {sh,-c,rm -f $scgiSocketPath}
scgi_local = $scgiSocketPath
execute = {sh,-c,chmod 0666 $scgiSocketPath}
EOF2
else
	echo &quot;scgi_port = $SCGI_HOST:$scgiPort&quot;
fi)
encoding_list = UTF-8
system.umask.set = $DEFAULT_UMASK
port_range = $rtorrentPort-$rtorrentPort
port_random = no
check_hash = no
directory = $RTORRENT_DOWNLOAD_DIR
session = $RTORRENT_SESSION_DIR
encryption = allow_incoming, try_outgoing, enable_retry
schedule = watch_directory,1,1,&quot;load_start=$RTORRENT_WATCH_DIR/*.torrent&quot;
#schedule = untied_directory,5,5,&quot;stop_untied=$RTORRENT_WATCH_DIR/*.torrent&quot;
trackers.enable = 1
#min_peers = 40
#max_peers = 100
#min_peers_seed = 10
#max_peers_seed = 50
#max_uploads = 15
#download_rate = 0
#upload_rate = 0
use_udp_trackers = yes
dht = auto
dht_port = 6881
peer_exchange = yes
#hash_read_ahead = 10
#hash_interval = 100
#hash_max_tries = 10
EOF
		PHP_BIN_PATH=$(which php 2&gt; /dev/null)
		COMMENT=
		[ -x &quot;$PHP_BIN_PATH&quot; ] || COMMENT=&quot;#&quot; PHP_BIN_PATH=/path/to/php
		cat &gt;&gt; &quot;$rtorrentRc&quot; &lt;&lt; EOF
${COMMENT}execute = {sh,-c,$PHP_BIN_PATH $RUTORRENT_BASE_PATH/php/initplugins.php $webUser &amp;}
EOF

		# Add user to web server&#39;s password file
		sed_i &quot;g/^$webUser:/d&quot; &quot;$WWW_PASSWORD_FILE&quot;
		$htpasswd -b &quot;$WWW_PASSWORD_FILE&quot; &quot;$webUser&quot; &quot;$webPass&quot; || errorExit &quot;Could not add user to password file&quot;
		resetAuthPasswordFilePermissions

		resetOwner &quot;$osUser&quot; &quot;$rtorrentRc&quot; &quot;$userDir&quot; &quot;$RTORRENT_DOWNLOAD_DIR&quot; &quot;$RTORRENT_WATCH_DIR&quot; &quot;$RTORRENT_SESSION_DIR&quot;

		# Required so some ruTorrent plugins work, eg. _getdir
		chmod 0755 &quot;$userDir&quot;

		# Protect some dirs and files, giving only the user and the web server
		# access. We need to do this since we set perms to 0755 above, or if
		# the perms already were 0755 to begin with.
		if [ -n &quot;$WWW_GROUP&quot; ]; then
			chmod 0600 &quot;$rtorrentRc&quot;
			for dir in $RTORRENT_REL_DOWNLOAD_DIR $RTORRENT_REL_WATCH_DIR $RTORRENT_REL_SESSION_DIR; do
				chown $osUser:$WWW_GROUP &quot;$userDir/$dir&quot;
				chmod 0770 &quot;$userDir/$dir&quot;
			done
		fi

		i=$(expr $i + 1)
	done

	[ &quot;$CREATE_ONE_PASSWORD_FILE_PER_USER&quot; = y ] &amp;&amp; createOnePasswordFilePerUser
fi

if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
	[ -z &quot;$RUTORRENT_BASE_PATH&quot; ] &amp;&amp; errorExit &quot;Invalid ruTorrent base path.&quot;

	[ &quot;$REINSTALL_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; rm -rf &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot;
	mkdir -p &quot;$RUTORRENT_BASE_PATH/plugins&quot;
	cd &quot;$RUTORRENT_BASE_PATH/plugins&quot;

	if [ -d &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; ]; then
		echo &quot;${CMSG}The autodl-irssi ruTorrent plugin dir already exists. Updating it...$CEND&quot;
		cd &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot;
		if ! svn up $SVN_OPTS &gt; /dev/null; then
			errorExit &quot;Could not update the autodl-irssi ruTorrent plugin. Run the script as root.&quot;
		fi
	else
		echo &quot;${CMSG}Downloading the autodl-irssi ruTorrent plugin...$CEND&quot;
		if ! git clone &quot;$GIT_PATH_RUTORRENT_PLUGIN&quot; autodl-irssi &gt; /dev/null; then
			errorExit &quot;Could not check out the autodl-irssi ruTorrent plugin&quot;
		fi
	fi
fi

if [ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ]; then
	if [ &quot;$RUTORRENT_PASSWORD_PROTECTED&quot; = y ]; then
		for packedUser in $USERS; do
			extractPackedUser $packedUser
			installUser &quot;$RUTORRENT_BASE_PATH/conf/users/$webUser/plugins/autodl-irssi&quot; &quot;$osUser&quot; &quot;$webUser&quot; &quot;$autodlPort&quot; &quot;$autodlPassword&quot;
		done
	else
		for packedUser in $USERS; do
			extractPackedUser $packedUser
			installUser &quot;$AUTODL_IRSSI_PLUGIN_DIR&quot; &quot;$osUser&quot; &quot;$webUser&quot; &quot;$autodlPort&quot; &quot;$autodlPassword&quot;
			[ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; break
		done
	fi
fi

if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
	verifyWebServerVars
	resetWebServerPermissions
	resetRutorrentUserPermissions
	# Restart it just in case we enabled/installed PHP modules.
	osHandler_$os restart_$INSTALL_WEB_SERVER
fi

if [ &quot;$INSTALL_VSFTPD&quot; = y ]; then
	echo &quot;${CMSG}Installing vsftpd...$CEND&quot;
	osHandler_$os installVsftpd
fi

if [ &quot;$INSTALL_WEBMIN&quot; = y ]; then
	cd
	rm -rf webmin-*/ webmin*.tar.gz
	if ! downloadFile webmin.tar.gz &quot;$WEBMIN_URL&quot;; then
		errorExit &quot;Could not download Webmin.&quot;
	fi
	tar xzf webmin.tar.gz
	rm -f webmin.tar.gz
	cd webmin-*/ || errorExit &quot;Could not CD to webmin dir&quot;
	osHandler_$os preWebminInstall
	[ -x &quot;setup.sh&quot; ] || errorExit &quot;Missing Webmin setup.sh file or not executable.&quot;
	cat &lt;&lt; EOF
$CMSG
Starting Webmin installer. Use another port than 10000, enable SSL, start webmin
at boot, and use a strong admin password.$CEND
$CWARNING
When it asks you if it should use SSL and whether it should start at boot,
type y.$CEND
EOF
	./setup.sh /usr/local/webmin
	osHandler_$os postWebminInstall
	cd
	rm -rf webmin-*/
fi

if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
	# Some plugins will fail unless they can write to the /tmp directory
	# We MUST do this AFTER installing Webmin since it will reset the perms!
	chmod 1777 /tmp
fi

if [ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ]; then
	for packedUser in $USERS; do
		extractPackedUser $packedUser
		echo &quot;${CMSG}Installing service for user $osUser.$CEND&quot;
		osHandler_$os installAutodlService $osUser
	done
fi

echo &quot;&quot;
echo &quot;${CGREEN}================================= DONE =================================$CEND&quot;
[ &quot;$INSTALLED_RTORRENT&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Built and installed rtorrent with XML-RPC support$CEND&quot;
[ -n &quot;$INSTALL_WEB_SERVER&quot; ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed and configured web server ($INSTALL_WEB_SERVER)$CEND&quot;
[ &quot;$INSTALL_VSFTPD&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed and configured FTP server (vsftpd)$CEND&quot;
[ &quot;$INSTALL_RUTORRENT&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed ruTorrent$CEND&quot;
[ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed/updated the autodl-irssi ruTorrent plugin$CEND&quot;
[ &quot;$INSTALL_AUTODL_IRSSI&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed autodl-irssi$CEND&quot;
[ &quot;$INSTALL_STARTUP_SCRIPT&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed and started Irssi and rtorrent service$CEND&quot;
[ &quot;$INSTALL_WEBMIN&quot; = y ] &amp;&amp; echo &quot;${CDGREEN}[+]$CEND ${CGREEN}Installed Webmin$CEND&quot;

if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
	getIpAddress
	cat &lt;&lt; EOF

${CMSG}ruTorrent URLs.$CEND ${CWARNING}Verify that the IP address below is correct!$CEND
	${CMAGENTA}http://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND
	${CMAGENTA}https://$OUR_IP_ADDRESS/$RUTORRENT_DIRNAME/$CEND
EOF
fi

if [ &quot;$INSTALL_RUTORRENT&quot; = y ]; then
		cat &lt;&lt; EOF

${CMSG}rtorrent directories$CEND:
EOF
	for packedUser in $USERS; do
		extractPackedUser $packedUser
		getRtorrentDirs &quot;$osUser&quot;
	cat &lt;&lt; EOF
${CMSG}User $CGREEN$osUser$CEND:
	${CGREEN}Downloads$CEND    : $CMAGENTA$RTORRENT_DOWNLOAD_DIR$CEND
	${CGREEN}Watch dir$CEND    : $CMAGENTA$RTORRENT_WATCH_DIR$CEND
	${CGREEN}Session dir$CEND  : $CMAGENTA$RTORRENT_SESSION_DIR$CEND
	${CGREEN}rtorrent port$CEND: $CMAGENTA$rtorrentPort$CEND
EOF
	done
fi

if [ -n &quot;$INSTALL_WEB_SERVER&quot; ]; then
	cat &lt;&lt; EOF

${CMSG}Web server info$CEND:
	${CGREEN}Web server root$CEND: ${CMAGENTA}$WWW_ROOT$CEND
	${CGREEN}ruTorrent dir$CEND  : ${CMAGENTA}$RUTORRENT_BASE_PATH$CEND
EOF
fi

if [ &quot;$INSTALL_VSFTPD&quot; = y ]; then
	getIpAddress
	cat &lt;&lt; EOF
$CMSG
To log in to the FTP server, use your $(uname -s) login name and password. I
guessed the IP address below. Make sure it&#39;s correct.$CEND
	${CGREEN}FTP IP address$CEND: ${CMAGENTA}$OUR_IP_ADDRESS$CEND
	${CGREEN}FTP port$CEND: ${CMAGENTA}$FTP_PORT$CEND
	${CGREEN}FTP server type$CEND: $CMAGENTA$FTP_SERVER_TYPE$CEND
EOF
fi

if [ &quot;$INSTALL_WEBMIN&quot; = y ]; then
	getIpAddress

	WEBMIN_PORT=
	WEBMIN_SSL=
	WEBMIN_NAME=
	WEBMIN_CONFIG=/etc/webmin/miniserv.conf
	WEBMIN_USERS=/etc/webmin/miniserv.users
	if [ -f $WEBMIN_CONFIG ]; then
		WEBMIN_PORT=$(grep &#39;^port=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^port=\([0-9]*\).*/\1/&#39;)
		WEBMIN_SSL=$(grep &#39;^ssl=&#39; $WEBMIN_CONFIG | tail -n1 | sed -e &#39;s/^ssl=\([0-9]*\).*/\1/&#39;)
		WEBMIN_NAME=$(head -n1 $WEBMIN_USERS | cut -d: -f1)
	fi
	WEBMIN_PORT=${WEBMIN_PORT:-UNKNOWN}
	WEBMIN_NAME=${WEBMIN_NAME:-UNKNOWN}

	cat &lt;&lt; EOF
$CMSG
Webmin was installed. Port is $WEBMIN_PORT and the user is $WEBMIN_NAME.
${CRED}Verify the IP address below.$CEND
EOF
	if [ -z &quot;$WEBMIN_SSL&quot; ]; then
		echo &quot;	${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot;
		echo &quot;${CMSG}or:$CEND&quot;
		echo &quot;	${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot;
	elif [ &quot;$WEBMIN_SSL&quot; = 0 ]; then
		echo &quot;	${CMAGENTA}http://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot;
	else
		echo &quot;	${CMAGENTA}https://$OUR_IP_ADDRESS:$WEBMIN_PORT/$CEND&quot;
	fi
fi

if [ -n &quot;$INSTALL_WEB_SERVER&quot; ] || [ &quot;$INSTALL_VSFTPD&quot; = y ] || \
	[ &quot;$INSTALL_RUTORRENT&quot; = y ] || [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
	if [ &quot;$SELINUX_ENABLED&quot; = y ]; then
		cat &lt;&lt; EOF
$CWARNING
SELinux is enabled. It could cause some problems with the web server, vsftpd or
ruTorrent.
EOF
	fi
fi

if [ &quot;$CREATED_CERT_FILE&quot; = y ]; then
	cat &lt;&lt; EOF
$CWARNING
A self-signed certificate was created. Your browser or FTP client will most
likely warn you about a non-trusted certificate.$CEND
EOF
fi

if [ &quot;$USE_RUTORRENT_PLUGIN&quot; = y ]; then
	if isProgramInstalled php; then
		detectMissingPhpModules
		if [ -n &quot;$MISSING_PHP_MODULES&quot; ]; then
			cat &lt;&lt; EOF
$CWARNING
The following PHP modules seem to be missing. It&#39;s possible that the
autodl-irssi ruTorrent plugin won&#39;t work. Missing PHP modules:
	$MISSING_PHP_MODULES$CEND
EOF
		fi
	else
		cat &lt;&lt; EOF
$CWARNING
Could not find the php executable. Make sure the following PHP modules are
enabled or the autodl-irssi ruTorrent plugin won&#39;t work:
	$REQUIRED_PHP_MODULES$CEND
EOF
	fi
fi</pre
            >
          </noscript>
          <script src="https://gist.github.com/PartTimeLegend/d71482792011133f46bb.js"></script>
        </article>
      </div>
    </main>
  </body>
</html>
